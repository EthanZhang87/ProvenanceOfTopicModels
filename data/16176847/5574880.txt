title: Minix 3
id: 5574880
Minix is a small Unix like operating system It is published under a BSD Clause license and is a successor project to the earlier versions Minix and br The project s main goal is for the system to be fault tolerant by detecting and repairing its faults on the fly with no user intervention The main uses of the system are envisaged to be embedded systems and education br As of Minix supports IA and ARM architecture processors It can also run on emulators or virtual machines such as Bochs VMware Workstation Microsoft Virtual PC Oracle VirtualBox and QEMU A port to PowerPC architecture is in development The distribution comes on a live CD and does not support live USB installation The project has been dormant since and the latest release is rc from although the Minix discussion group is still active br Minix is believed to have inspired the Intel Management Engine ME OS found in Intel s Platform Controller Hub starting with the introduction of ME which is used with Skylake and Kaby Lake processors It was debated that Minix could have been the most widely used OS on x AMD processors with more installations than Microsoft Windows Linux or macOS because of its use in the Intel ME br br br Goals of the project br br Reflecting on the nature of monolithic kernel based systems where a driver which has according to Minix creator Tanenbaum approximately times as many bugs as a usual program can bring down the whole system Minix aims to create an operating system that is a reliable self healing multiserver Unix clone br To achieve that the code running in kernel must be minimal with the file server process server and each device driver running as separate user mode processes Each driver is carefully monitored by a part of the system named the reincarnation server If a driver fails to respond to pings from this server it is shut down and replaced by a fresh copy of the driver br In a monolithic system a bug in a driver can easily crash the whole kernel This is far less likely to occur in Minix br br br History br br Minix was publicly announced on October by Andrew Tanenbaum during his keynote speech on top of the Association for Computing Machinery ACM Symposium Operating Systems Principles conference Although it still serves as an example for the new edition of Tanenbaum and Woodhull s textbook it is comprehensively redesigned to be usable as a serious system on resource limited and embedded computers and for applications requiring high reliability br Initially released under the same BSD Clause license that Minix was licensed under since In late the copyright owner was changed and a fourth clause was added br br br Reliability policies br One of the main goals of Minix is reliability Below some of the more important principles that enhance its reliability are discussed br br br Reduce kernel size br Monolithic operating systems such as Linux and FreeBSD and hybrids like Windows have millions of lines of kernel code In contrast Minix has about lines of executable kernel code which can make problems easier to find in the code br br br Cage the bugs br In monolithic kernels device drivers reside in the kernel Thus when a new peripheral is installed unknown untrusted code is inserted in the kernel One bad line of code in a driver can bring down the system br Instead in Minix each device driver is a separate user mode process Drivers cannot execute privileged instructions change the page tables perform arbitrary input output I O or write to absolute memory They must make kernel calls for these services and the kernel checks each call for authority br br br Limit drivers memory access br In monolithic kernels a driver can write to any word of memory and thus accidentally corrupt user programs br In Minix when a user expects data from for example the file system it builds a descriptor telling who has access and at what addresses It then passes an index to this descriptor to the file system which may pass it to a driver The file system or driver then asks the kernel to write via the descriptor making it impossible for them to write to addresses outside the buffer br br br Survive bad pointers br Dereferencing a bad pointer within a driver will crash the driver process but will have no effect on the system as a whole The reincarnation server will restart the crashed driver automatically Users will not notice recovery for some drivers e g disk and network but for others e g audio and printer they might In monolithic kernels dereferencing a bad pointer in a driver normally leads to a system crash br br br Tame infinite loops br If a driver gets into an infinite loop the scheduler will gradually lower its priority until it becomes idle Eventually the reincarnation server will see that it is not responding to status requests so it will kill and restart the looping driver In a monolithic kernel a looping driver could hang the system br br br Limit damage from buffer overflows br Minix uses fixed length messages for internal communication which eliminates certain buffer overflows and buffer management problems Also many exploits work by overrunning a buffer to trick the program into returning from a function call using an overwritten stack return address pointing into attacker controlled memory usually the overrun buffer In Minix this attack is mitigated because instruction and data space are split and only code in read only instruction space can be executed termed executable space protection However attacks which rely on running legitimately executable memory in a malicious way return to libc return oriented programming are not prevented by this mitigation br br br Restrict access to kernel functions br Device drivers obtain kernel services such as copying data to users address spaces by making kernel calls The Minix kernel has a bit map for each driver specifying which calls it is authorized to make In monolithic kernels every driver can call every kernel function authorized or not br br br Restrict access to I O ports br The kernel also maintains a table telling which I O ports each driver may access Thus a driver can only touch its own I O ports In monolithic kernels a buggy driver can access I O ports belonging to another device br br br Restrict communication with OS components br Not every driver and server needs to communicate with every other driver and server Accordingly a per process bit map determines which destinations each process may send to br br br Reincarnate dead or sick drivers br A special process called the reincarnation server periodically pings each device driver If the driver dies or fails to respond correctly to pings the reincarnation server automatically replaces it with a fresh copy Detecting and replacing non functioning drivers is automatic with no user action needed This feature does not work for disk drivers at present but in the next release the system will be able to recover even disk drivers which will be shadowed in random access memory RAM Driver recovery does not affect running processes br br br Integrate interrupts and messages br When an interrupt occurs it is converted at a low level to a notification sent to the appropriate driver If the driver is waiting for a message it gets the interrupt immediately otherwise it gets the notification the next time it does a RECEIVE to get a message This scheme eliminates nested interrupts and makes driver programming easier br br br Architecture br br As can be seen at the bottom level is the microkernel which is about lines of code mostly in C plus a small amount of assembly language It handles interrupts scheduling and message passing It also supports an application programming interface API of about kernel calls that authorized servers and drivers can make User programs cannot make these calls Instead they can issue POSIX system calls which send messages to the servers The kernel calls perform functions such as setting interrupts and copying data between address spaces br At the next level up there are the device drivers each one running as a separate userland process Each one controls some I O device such as a disk or printer The drivers do not have access to the I O port space and cannot issue I O instructions directly Instead they must make kernel calls giving a list of I O ports to write to and the values to be written While there is a small amount of overhead in doing this typically ns this scheme makes it possible for the kernel to check authorization so that for example the audio driver cannot write on the disk br At the next level there are the servers This is where nearly all the operating system functionality is located User processes obtain file service for example by sending messages to the file server to open close read and write files In turn the file server gets disk I O performed by sending messages to the disk driver which controls the disk br One of the key servers is the reincarnation server Its job is to poll all the other servers and drivers to check on their health periodically If a component fails to respond correctly or exits or gets into an infinite loop the reincarnation server which is the parent process of the drivers and servers kills the faulty component and replaces it with a fresh copy In this way the system is automatically made self healing without interfering with running programs br Currently the reincarnation server the process server and the microkernel are part of the trusted computing base If any of them fail the system crashes Nevertheless reducing the trusted computing base from million lines of code as in Linux and Windows systems to about lines greatly enhances system reliability br br br Differences between Minix and prior versions br br Minix and were developed as tools to help people learn about the design of operating systems br Minix released in was lines of C and some x assembly language Source code of the kernel memory manager and file system of Minix are printed in the book Tanenbaum originally developed Minix for compatibility with the IBM PC and IBM PC AT microcomputers available at the time br Minix released in included support for MicroChannel IBM PS systems and was also ported to the Motorola and SPARC architectures supporting the Atari ST Commodore Amiga Apple Macintosh and Sun Microsystems SPARCstation computer platforms A version of Minix running as a user process under SunOS was also available br Minix released in was only available for the x and Solaris hosted SPARC architectures Minix vmd was created by two Vrije Universiteit researchers and added virtual memory and support for the X Window System br Minix does the same and provides a modern operating system with many newer tools and many Unix applications Prof Tanenbaum once said br br Please be aware that MINIX is not your grandfather s MINIX MINIX was written as an educational tool MINIX is that plus a start at building a highly reliable self healing bloat free operating system MINIX and MINIX are related in the same way as Windows and Windows XP are same first name br Many improvements have also been made in the structure of the kernel since the Minix release making the system more reliable Minix version was released Nov It contains X Emacs vi cc GCC Perl Python Almquist shell Bash Z shell FTP client SSH client Telnet client Pine and over other common Unix utility programs With the addition of X this version marks the transition away from a text only system Another feature of this version which will be improved in future ones is the ability of the system to withstand device driver crashes and in many cases having them automatically replaced without affecting running processes In this way Minix is self healing and can be used in applications demanding high reliability br Minix was released in February This version has many new features including the Clang compiler experimental symmetric multiprocessing support procfs and ext fs filesystem support and GNU Debugger GDB Several parts of NetBSD are also integrated in the release including the bootloader libc and various utilities and other libraries br Minix was released in September This release is the first version to support the ARM architecture in addition to x It also supports a NetBSD userland with thousands of NetBSD packages running right out of the box br br br Mascot br br Rocky Raccoon is the mascot of Minix br br br MINIXCon br MINIXCon is a conference on sharing talks efforts and researches related to Minix br It was held once in MINIXCon was cancelled due to lack of talks submitted br br br See also br br MINIX file system br Xinu br xv br Comparison of operating system kernels br List of computing mascots br Category Computing mascots br br br Notes br br br br br br Further reading br br br External links br br Official website br Stichting MINIX Research Foundation on GitHub