title: Collision detection
id: 171552
Collision detection is the computational problem of detecting an intersection of two or more spatial objects commonly computer graphics objects It has applications in various computing fields primarily in computer graphics computer games computer simulations robotics and computational physics Collision detection is a classic problem of computational geometry Collision detection algorithms can be divided into operating on D or D spatial objects br br br Overview br br In physical simulation experiments such as playing billiards are conducted The physics of bouncing billiard balls are well understood under the umbrella of rigid body motion and elastic collisions An initial description of the situation would be given with a very precise physical description of the billiard table and balls as well as initial positions of all the balls Given a force applied to the cue ball probably resulting from a player hitting the ball with their cue stick we want to calculate the trajectories precise motion and eventual resting places of all the balls with a computer program A program to simulate this game would consist of several portions one of which would be responsible for calculating the precise impacts between the billiard balls This particular example also turns out to be ill conditioned a small error in any calculation will cause drastic changes in the final position of the billiard balls br Video games have similar requirements with some crucial differences While some computer simulations need to simulate real world physics as precisely as possible computer games need to simulate real world physics in an acceptable way in real time and robustly Compromises are allowed so long as the resulting simulation is satisfying to the game players br br br Collision detection in computer simulation br br Physical simulators differ in the way they react on a collision Some use the softness of the material to calculate a force which will resolve the collision in the following time steps like it is in reality This is very CPU intensive for low softness materials Some simulators estimate the time of collision by linear interpolation roll back the simulation and calculate the collision by the more abstract methods of conservation laws br Some iterate the linear interpolation Newton s method to calculate the time of collision with a much higher precision than the rest of the simulation Collision detection utilizes time coherence to allow even finer time steps without much increasing CPU demand such as in air traffic control br After an inelastic collision special states of sliding and resting can occur and for example the Open Dynamics Engine uses constraints to simulate them Constraints avoid inertia and thus instability Implementation of rest by means of a scene graph avoids drift br In other words physical simulators usually function one of two ways where the collision is detected a posteriori after the collision occurs or a priori before the collision occurs In addition to the a posteriori and a priori distinction almost all modern collision detection algorithms are broken into a hierarchy of algorithms Often the terms discrete and continuous are used rather than a posteriori and a priori br br br A posteriori discrete versus a priori continuous br br In the a posteriori case the physical simulation is advanced by a small step then checked to see if any objects are intersecting or visibly considered intersecting At each simulation step a list of all intersecting bodies is created and the positions and trajectories of these objects are fixed to account for the collision This method is called a posteriori because it typically misses the actual instant of collision and only catches the collision after it has actually happened br In the a priori methods there is a collision detection algorithm which will be able to predict very precisely the trajectories of the physical bodies The instants of collision are calculated with high precision and the physical bodies never actually interpenetrate This is called a priori because the collision detection algorithm calculates the instants of collision before it updates the configuration of the physical bodies br The main benefits of the a posteriori methods are as follows In this case the collision detection algorithm need not be aware of the myriad of physical variables a simple list of physical bodies is fed to the algorithm and the program returns a list of intersecting bodies The collision detection algorithm doesn t need to understand friction elastic collisions or worse nonelastic collisions and deformable bodies In addition the a posteriori algorithms are in effect one dimension simpler than the a priori algorithms An a priori algorithm must deal with the time variable which is absent from the a posteriori problem br On the other hand a posteriori algorithms cause problems in the fixing step where intersections which aren t physically correct need to be corrected Moreover if the discrete step is too large the collision could go undetected resulting in an object which passes through another if it is sufficiently fast or small br The benefits of the a priori algorithms are increased fidelity and stability It is difficult but not completely impossible to separate the physical simulation from the collision detection algorithm However in all but the simplest cases the problem of determining ahead of time when two bodies will collide given some initial data has no closed form solution a numerical root finder is usually involved br Some objects are in resting contact that is in collision but neither bouncing off nor interpenetrating such as a vase resting on a table In all cases resting contact requires special treatment If two objects collide a posteriori or slide a priori and their relative motion is below a threshold friction becomes stiction and both objects are arranged in the same branch of the scene graph br br br Optimization br The obvious approaches to collision detection for multiple objects are very slow br Checking every object against every other object will of course work but is too inefficient to be used when the number of objects is at all large Checking objects with complex geometry against each other in the obvious way by checking each face against each other face is itself quite slow Thus considerable research has been applied to speed up the problem br br br Exploiting temporal coherence br br In many applications the configuration of physical bodies from one time step to the next changes very little Many of the objects may not move at all br Algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step resulting in faster completion of the calculation br At the coarse level of collision detection the objective is to find pairs of objects which might potentially intersect Those pairs will require further analysis An early high performance algorithm for this was developed by Ming C Lin at the University of California Berkeley who suggested using axis aligned bounding boxes for all n bodies in the scene br Each box is represented by the product of three intervals i e a box would be br br br br br I br br br br br br br I br br br br br br br I br br br br br br br br a br br br br br br br b br br br br br br br br br a br br br br br br br b br br br br br br br br br a br br br br br br br b br br br br br br br br displaystyle I times I times I a b times a b times a b br br A common algorithm for collision detection of bounding boxes is sweep and prune Observe that two such boxes br br br br br I br br br br br br br I br br br br br br br I br br br br br br br displaystyle I times I times I br br and br br br br br J br br br br br br br J br br br br br br br J br br br br br br br displaystyle J times J times J br br intersect if and only if br br br br br I br br br br br br br displaystyle I br br intersects br br br br br J br br br br br br br displaystyle J br br br br br br br I br br br br br br br displaystyle I br br intersects br br br br br J br br br br br br br displaystyle J br br and br br br br br I br br br br br br br displaystyle I br br intersects br br br br br J br br br br br br br displaystyle J br br It is supposed that from one time step to the next if br br br br br I br br k br br br br br displaystyle I k br br and br br br br br J br br k br br br br br displaystyle J k br br intersect then it is very likely that at the next time step they will still intersect Likewise if they did not intersect in the previous time step then they are very likely to continue not to br So we reduce the problem to that of tracking from frame to frame which intervals do intersect We have three lists of intervals one for each axis and all lists are the same length since each list has length br br br br n br br br displaystyle n br br the number of bounding boxes In each list each interval is allowed to intersect all other intervals in the list So for each list we will have an br br br br n br br n br br br displaystyle n times n br br matrix br br br br M br br br br m br br i br j br br br br br br displaystyle M m ij br br of zeroes and ones br br br br br m br br i br j br br br br br displaystyle m ij br br is if intervals br br br br i br br br displaystyle i br br and br br br br j br br br displaystyle j br br intersect and if they do not intersect br By our assumption the matrix br br br br M br br br displaystyle M br br associated to a list of intervals will remain essentially unchanged from one time step to the next To exploit this the list of intervals is actually maintained as a list of labeled endpoints Each element of the list has the coordinate of an endpoint of an interval as well as a unique integer identifying that interval Then we sort the list by coordinates and update the matrix br br br br M br br br displaystyle M br br as we go It s not so hard to believe that this algorithm will work relatively quickly if indeed the configuration of bounding boxes does not change significantly from one time step to the next br In the case of deformable bodies such as cloth simulation it may not be possible to use a more specific pairwise pruning algorithm as discussed below and an n body pruning algorithm is the best that can be done br If an upper bound can be placed on the velocity of the physical bodies in a scene then pairs of objects can be pruned based on their initial distance and the size of the time step br br br Pairwise pruning br br Once we ve selected a pair of physical bodies for further investigation we need to check for collisions more carefully However in many applications individual objects if they are not too deformable are described by a set of smaller primitives mainly triangles So now we have two sets of triangles br br br br S br br br br S br br br br br br br S br br br br br br br br br S br br n br br br br br br displaystyle S S S dots S n br br and br br br br T br br br br T br br br br br br br T br br br br br br br br br T br br n br br br br br br displaystyle T T T dots T n br br for simplicity we will assume that each set has the same number of triangles br The obvious thing to do is to check all triangles br br br br br S br br j br br br br br displaystyle S j br br against all triangles br br br br br T br br k br br br br br displaystyle T k br br for collisions but this involves br br br br br n br br br br br br br displaystyle n br br comparisons which is highly inefficient If possible it is desirable to use a pruning algorithm to reduce the number of pairs of triangles we need to check br The most widely used family of algorithms is known as the hierarchical bounding volumes method As a preprocessing step for each object in our example br br br br S br br br displaystyle S br br and br br br br T br br br displaystyle T br br we will calculate a hierarchy of bounding volumes Then at each time step when we need to check for collisions between br br br br S br br br displaystyle S br br and br br br br T br br br displaystyle T br br the hierarchical bounding volumes are used to reduce the number of pairs of triangles under consideration For simplicity we will give an example using bounding spheres although it has been noted that spheres are undesirable in many cases br If br br br br E br br br displaystyle E br br is a set of triangles we can pre calculate a bounding sphere br br br br B br br E br br br br displaystyle B E br br There are many ways of choosing br br br br B br br E br br br br displaystyle B E br br we only assume that br br br br B br br E br br br br displaystyle B E br br is a sphere that completely contains br br br br E br br br displaystyle E br br and is as small as possible br Ahead of time we can compute br br br br B br br S br br br br displaystyle B S br br and br br br br B br br T br br br br displaystyle B T br br Clearly if these two spheres do not intersect and that is very easy to test then neither do br br br br S br br br displaystyle S br br and br br br br T br br br displaystyle T br br This is not much better than an n body pruning algorithm however br If br br br br E br br br br E br br br br br br br E br br br br br br br br br E br br m br br br br br br displaystyle E E E dots E m br br is a set of triangles then we can split it into two halves br br br br L br br E br br br br br E br br br br br br br E br br br br br br br br br E br br m br br br br br br br br br br displaystyle L E E E dots E m br br and br br br br R br br E br br br br br E br br m br br br br br br br br br br br br br E br br m br br br br br br br E br br m br br br br br br displaystyle R E E m dots E m E m br br We can do this to br br br br S br br br displaystyle S br br and br br br br T br br br displaystyle T br br and we can calculate ahead of time the bounding spheres br br br br B br br L br br S br br br br B br br R br br S br br br br br displaystyle B L S B R S br br and br br br br B br br L br br T br br br br B br br R br br T br br br br br displaystyle B L T B R T br br The hope here is that these bounding spheres are much smaller than br br br br B br br S br br br br displaystyle B S br br and br br br br B br br T br br br br displaystyle B T br br And if for instance br br br br B br br S br br br br displaystyle B S br br and br br br br B br br L br br T br br br br br displaystyle B L T br br do not intersect then there is no sense in checking any triangle in br br br br S br br br displaystyle S br br against any triangle in br br br br L br br T br br br br displaystyle L T br br br As a precomputation we can take each physical body represented by a set of triangles and recursively decompose it into a binary tree where each node br br br br N br br br displaystyle N br br represents a set of triangles and its two children represent br br br br L br br N br br br br displaystyle L N br br and br br br br R br br N br br br br displaystyle R N br br At each node in the tree we can pre compute the bounding sphere br br br br B br br N br br br br displaystyle B N br br br When the time comes for testing a pair of objects for collision their bounding sphere tree can be used to eliminate many pairs of triangles br Many variants of the algorithms are obtained by choosing something other than a sphere for br br br br B br br T br br br br displaystyle B T br br If one chooses axis aligned bounding boxes one gets AABBTrees Oriented bounding box trees are called OBBTrees Some trees are easier to update if the underlying object changes Some trees can accommodate higher order primitives such as splines instead of simple triangles br br br Exact pairwise collision detection br br Once we re done pruning we are left with a number of candidate pairs to check for exact collision detection br A basic observation is that for any two convex objects which are disjoint one can find a plane in space so that one object lies completely on one side of that plane and the other object lies on the opposite side of that plane This allows the development of very fast collision detection algorithms for convex objects br Early work in this area involved separating plane methods Two triangles collide essentially only when they can not be separated by a plane going through three vertices That is if the triangles are br br br br br br v br br br br br br br v br br br br br br br v br br br br br br br br displaystyle v v v br br and br br br br br br v br br br br br br br v br br br br br br br v br br br br br br br br displaystyle v v v br br where each br br br br br v br br j br br br br br displaystyle v j br br is a vector in br br br br br br R br br br br br br br br displaystyle mathbb R br br then we can take three vertices br br br br br v br br i br br br br br v br br j br br br br br v br br k br br br br br displaystyle v i v j v k br br find a plane going through all three vertices and check to see if this is a separating plane If any such plane is a separating plane then the triangles are deemed to be disjoint On the other hand if none of these planes are separating planes then the triangles are deemed to intersect There are twenty such planes br If the triangles are coplanar this test is not entirely successful One can add some extra planes for instance planes that are normal to triangle edges to fix the problem entirely In other cases objects that meet at a flat face must necessarily also meet at an angle elsewhere hence the overall collision detection will be able to find the collision br Better methods have since been developed Very fast algorithms are available for finding the closest points on the surface of two convex polyhedral objects Early work by Ming C Lin used a variation on the simplex algorithm from linear programming The Gilbert Johnson Keerthi distance algorithm has superseded that approach These algorithms approach constant time when applied repeatedly to pairs of stationary or slow moving objects when used with starting points from the previous collision check br The end result of all this algorithmic work is that collision detection can be done efficiently for thousands of moving objects in real time on typical personal computers and game consoles br br br A priori pruning br Where most of the objects involved are fixed as is typical of video games a priori methods using precomputation can be used to speed up execution br Pruning is also desirable here both n body pruning and pairwise pruning but the algorithms must take time and the types of motions used in the underlying physical system into consideration br When it comes to the exact pairwise collision detection this is highly trajectory dependent and one almost has to use a numerical root finding algorithm to compute the instant of impact br As an example consider two triangles moving in time br br br br br br v br br br br br br t br br br br v br br br br br br t br br br br v br br br br br br t br br br br br displaystyle v t v t v t br br and br br br br br br v br br br br br br t br br br br v br br br br br br t br br br br v br br br br br br t br br br br br displaystyle v t v t v t br br At any point in time the two triangles can be checked for intersection using the twenty planes previously mentioned However we can do better since these twenty planes can all be tracked in time If br br br br P br br u br br v br br w br br br br displaystyle P u v w br br is the plane going through points br br br br u br br v br br w br br br displaystyle u v w br br in br br br br br br R br br br br br br br br displaystyle mathbb R br br then there are twenty planes br br br br P br br br v br br i br br br br t br br br br v br br j br br br br t br br br br v br br k br br br br t br br br br br displaystyle P v i t v j t v k t br br to track Each plane needs to be tracked against three vertices this gives sixty values to track Using a root finder on these sixty functions produces the exact collision times for the two given triangles and the two given trajectory We note here that if the trajectories of the vertices are assumed to be linear polynomials in br br br br t br br br displaystyle t br br then the final sixty functions are in fact cubic polynomials and in this exceptional case it is possible to locate the exact collision time using the formula for the roots of the cubic Some numerical analysts suggest that using the formula for the roots of the cubic is not as numerically stable as using a root finder for polynomials br br br Spatial partitioning br Alternative algorithms are grouped under the spatial partitioning umbrella which includes octrees binary space partitioning or BSP trees and other similar approaches If one splits space into a number of simple cells and if two objects can be shown not to be in the same cell then they need not be checked for intersection Since BSP trees can be precomputed that approach is well suited to handling walls and fixed obstacles in games These algorithms are generally older than the algorithms described above br br br Bounding boxes br Bounding boxes or bounding volumes are most often a D rectangle or D cuboid but other shapes are possible A bounding box in a video game is sometimes called a Hitbox br The bounding diamond the minimum bounding parallelogram the convex hull the bounding circle or bounding ball and the bounding ellipse have all been tried but bounding boxes remain the most popular due to their simplicity Bounding boxes are typically used in the early pruning stage of collision detection so that only objects with overlapping bounding boxes need be compared in detail br br br Triangle centroid segments br A triangle mesh object is commonly used in D body modeling Normally the collision function is a triangle to triangle intercept or a bounding shape associated with the mesh A triangle centroid is a center of mass location such that it would balance on a pencil tip The simulation need only add a centroid dimension to the physics parameters Given centroid points in both object and target it is possible to define the line segment connecting these two points br The position vector of the centroid of a triangle is the average of the position vectors of its vertices So if its vertices have Cartesian coordinates br br br br br br x br br br br br br br y br br br br br br br z br br br br br br br br displaystyle x y z br br br br br br br br x br br br br br br br y br br br br br br br z br br br br br br br br displaystyle x y z br br and br br br br br br x br br br br br br br y br br br br br br br z br br br br br br br br displaystyle x y z br br then the centroid is br br br br br br br br br br br br x br br br br br br br x br br br br br br br x br br br br br br br br br br br br br br br br y br br br br br br br y br br br br br br br y br br br br br br br br br br br br br br br br z br br br br br br br z br br br br br br br z br br br br br br br br br br br br br br br displaystyle left frac x x x frac y y y frac z z z right br br br Here is the function for a line segment distance between two D points br br br br br d br i br s br t br a br n br c br e br br br br br br br z br br br br br br br z br br br br br br br br br br br br br br x br br br br br br br x br br br br br br br br br br br br br br y br br br br br br br y br br br br br br br br br br br br br br br displaystyle mathrm distance sqrt z z x x y y br br br Here the length distance of the segment is an adjustable hit criteria size of segment As the objects approach the length decreases to the threshold value A triangle sphere becomes the effective geometry test A sphere centered at the centroid can be sized to encompass all the triangle s vertices br br br Video games br Video games have to split their very limited computing time between several tasks Despite this resource limit and the use of relatively primitive collision detection algorithms programmers have been able to create believable if inexact systems for use in games br For a long time video games had a very limited number of objects to treat and so checking all pairs was not a problem In two dimensional games in some cases the hardware was able to efficiently detect and report overlapping pixels between sprites on the screen In other cases simply tiling the screen and binding each sprite into the tiles it overlaps provides sufficient pruning and for pairwise checks bounding rectangles or circles called hitboxes are used and deemed sufficiently accurate br Three dimensional games have used spatial partitioning methods for br br br br n br br br displaystyle n br br body pruning and for a long time used one or a few spheres per actual D object for pairwise checks Exact checks are very rare except in games attempting to simulate reality closely Even then exact checks are not necessarily used in all cases br Because games do not need to mimic actual physics stability is not as much of an issue Almost all games use a posteriori collision detection and collisions are often resolved using very simple rules For instance if a character becomes embedded in a wall they might be simply moved back to their last known good location Some games will calculate the distance the character can move before getting embedded into a wall and only allow them to move that far br In many cases for video games approximating the characters by a point is sufficient for the purpose of collision detection with the environment In this case binary space partitioning trees provide a viable efficient and simple algorithm for checking if a point is embedded in the scenery or not Such a data structure can also be used to handle resting position situation gracefully when a character is running along the ground Collisions between characters and collisions with projectiles and hazards are treated separately br A robust simulator is one that will react to any input in a reasonable way For instance if we imagine a high speed racecar video game from one simulation step to the next it is conceivable that the cars would advance a substantial distance along the race track If there is a shallow obstacle on the track such as a brick wall it is not entirely unlikely that the car will completely leap over it and this is very undesirable In other instances the fixing that posteriori algorithms require isn t implemented correctly resulting in bugs that can trap characters in walls or allow them to pass through them and fall into an endless void where there may or may not be a deadly bottomless pit sometimes referred to as black hell blue hell or green hell depending on the predominant color These are the hallmarks of a failing collision detection and physical simulation system Big Rigs Over the Road Racing is an infamous example of a game with a failing or possibly missing collision detection system br br br Hitbox br br A hitbox is an invisible shape commonly used in video games for real time collision detection it is a type of bounding box It is often a rectangle in D games or cuboid in D that is attached to and follows a point on a visible object such as a model or a sprite Circular or spheroidial shapes are also common though they are still most often called boxes It is common for animated objects to have hitboxes attached to each moving part to ensure accuracy during motion br Hitboxes are used to detect one way collisions such as a character being hit by a punch or a bullet They are unsuitable for the detection of collisions with feedback e g bumping into a wall due to the difficulty experienced by both humans and AI in managing a hitbox s ever changing locations these sorts of collisions are typically handled with much simpler axis aligned bounding boxes instead Players may use the term hitbox to refer to these types of interactions regardless br A hurtbox is a hitbox used to detect incoming sources of damage In this context the term hitbox is typically reserved for those which deal damage For example an attack may only land if the hitbox around an attacker s punch connects with one of the opponent s hurtboxes on their body while opposing hitboxes colliding may result in the players trading or cancelling blows and opposing hurtboxes do not interact with each other The term is not standardized across the industry some games reverse their definitions of hitbox and hurtbox while others only use hitbox for both sides br br br See also br br br br br br External links br University of North Carolina at Chapel Hill collision detection research website br Prof Steven Cameron Oxford University web site on collision detection br How to Avoid a Collision by George Beck Wolfram Demonstrations Project br Bounding boxes and their usage br Separating Axis Theorem br Unity D Collision br Godot Physics Collision