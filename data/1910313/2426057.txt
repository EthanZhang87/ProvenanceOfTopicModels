title: Pathfinding
id: 2426057
Pathfinding or pathing is the search by a computer application for the shortest route between two points It is a more practical variant on solving mazes This field of research is based heavily on Dijkstra s algorithm for finding the shortest path on a weighted graph br Pathfinding is closely related to the shortest path problem within graph theory which examines how to identify the path that best meets some criteria shortest cheapest fastest etc between two points in a large network br br br Algorithms br At its core a pathfinding method searches a graph by starting at one vertex and exploring adjacent nodes until the destination node is reached generally with the intent of finding the cheapest route Although graph searching methods such as a breadth first search would find a route if given enough time other methods which explore the graph would tend to reach the destination sooner An analogy would be a person walking across a room rather than examining every possible route in advance the person would generally walk in the direction of the destination and only deviate from the path to avoid an obstruction and make deviations as minor as possible br Two primary problems of pathfinding are to find a path between two nodes in a graph and the shortest path problem to find the optimal shortest path Basic algorithms such as breadth first and depth first search address the first problem by exhausting all possibilities starting from the given node they iterate over all potential paths until they reach the destination node These algorithms run in br br br br O br br br br br V br br br br br br br br E br br br br br br br displaystyle O V E br br or linear time where V is the number of vertices and E is the number of edges between vertices br The more complicated problem is finding the optimal path The exhaustive approach in this case is known as the Bellman Ford algorithm which yields a time complexity of br br br br O br br br br br V br br br br br br br E br br br br br br br displaystyle O V E br br or quadratic time However it is not necessary to examine all possible paths to find the optimal one Algorithms such as A and Dijkstra s algorithm strategically eliminate paths either through heuristics or through dynamic programming By eliminating impossible paths these algorithms can achieve time complexities as low as br br br br O br br br br br E br br br br log br br br br br br V br br br br br br br br displaystyle O E log V br br br The above algorithms are among the best general algorithms which operate on a graph without preprocessing However in practical travel routing systems even better time complexities can be attained by algorithms which can pre process the graph to attain better performance One such algorithm is contraction hierarchies br br br Dijkstra s algorithm br A common example of a graph based pathfinding algorithm is Dijkstra s algorithm This algorithm begins with a start node and an open set of candidate nodes At each step the node in the open set with the lowest distance from the start is examined The node is marked closed and all nodes adjacent to it are added to the open set if they have not already been examined This process repeats until a path to the destination has been found Since the lowest distance nodes are examined first the first time the destination is found the path to it will be the shortest path br Dijkstra s algorithm fails if there is a negative edge weight In the hypothetical situation where Nodes A B and C form a connected undirected graph with edges AB AC and BC the optimal path from A to C costs and the optimal path from A to B costs Dijkstra s Algorithm starting from A will first examine B as that is the closest It will assign a cost of to it and mark it closed meaning that its cost will never be reevaluated Therefore Dijkstra s cannot evaluate negative edge weights However since for many practical purposes there will never be a negative edgeweight Dijkstra s algorithm is largely suitable for the purpose of pathfinding br br br A algorithm br A is a variant of Dijkstra s algorithm commonly used in games A assigns a weight to each open node equal to the weight of the edge to that node plus the approximate distance between that node and the finish This approximate distance is found by the heuristic and represents a minimum possible distance between that node and the end This allows it to eliminate longer paths once an initial path is found If there is a path of length x between the start and finish and the minimum distance between a node and the finish is greater than x that node need not be examined br A uses this heuristic to improve on the behavior relative to Dijkstra s algorithm When the heuristic evaluates to zero A is equivalent to Dijkstra s algorithm As the heuristic estimate increases and gets closer to the true distance A continues to find optimal paths but runs faster by virtue of examining fewer nodes When the value of the heuristic is exactly the true distance A examines the fewest nodes However it is generally impractical to write a heuristic function that always computes the true distance as the same comparison result can often be reached using simpler calculations for example using Chebyshev distance over Euclidean distance in two dimensional space As the value of the heuristic increases A examines fewer nodes but no longer guarantees an optimal path In many applications such as video games this is acceptable and even desirable in order to keep the algorithm running quickly br br br In video games br br Chris Crawford in described how he expended a great deal of time trying to solve a problem with pathfinding in Tanktics in which computer tanks became trapped on land within U shaped lakes After much wasted effort I discovered a better solution delete U shaped lakes from the map he said br br br Hierarchical path finding br br The idea was first described by the video game industry which had a need for planning in large maps with a low amount of CPU time The concept of using abstraction and heuristics is older and was first mentioned under the name ABSTRIPS Abstraction Based STRIPS which was used to efficiently search the state spaces of logic games A similar technique are navigation meshes navmesh which are used for geometrical planning in games and multimodal transportation planning which is utilized in travelling salesman problems with more than one transport vehicle br A map is separated into clusters On the high level layer the path between the clusters is planned After the plan was found a second path is planned within a cluster on the lower level That means the planning is done in two steps which is a guided local search in the original space The advantage is that the number of nodes is smaller and the algorithm performs very well The disadvantage is that a hierarchical pathplanner is difficult to implement br br br Example br A map has a size of x nodes Planning a path on a node base would take very long Even an efficient algorithm will need to compute many possible graphs The reason is that such a map would contain million nodes overall and the possibilities to explore the geometrical space are exceedingly large The first step for a hierarchical path planner is to divide the map into smaller sub maps Each cluster has a size of x nodes The number of clusters overall is x In the newly created graph the amount of nodes is small it is possible to navigate between the clusters but not within the detailed map If a valid path was found in the high level graph the next step is to plan the path within each cluster The submap has x nodes which can be handled by a normal A pathplanner easily br br br Algorithms used in pathfinding br Dijkstra s algorithm br A search algorithm a special case of the Dijkstra s algorithm br br D a family of incremental heuristic search algorithms for problems in which constraints vary over time or are not completely known when the agent first plans its path br Any angle path planning algorithms a family of algorithms for planning paths that are not restricted to move along the edges in the search graph designed to be able to take on any angle and thus find shorter and straighter paths br br br Multi agent pathfinding br br Multi agent pathfinding is to find the paths for multiple agents from their current locations to their target locations without colliding with each other while at the same time optimizing a cost function such as the sum of the path lengths of all agents It is a generalization of pathfinding Many multi agent pathfinding algorithms are generalized from A or based on reduction to other well studied problems such as integer linear programming However such algorithms are typically incomplete in other words not proven to produce a solution within polynomial time Some parallel approaches such as Collaborative Diffusion are based on embarrassingly parallel algorithms spreading multi agent pathfinding into computational grid structures e g cells similar to cellular automata A different category of algorithms sacrifice optimality for performance by either making use of known navigation patterns such as traffic flow or the topology of the problem space br br br See also br Motion planning br Any angle path planning br br br br br br External links br https melikpehlivanov github io AlgorithmVisualizer br http sourceforge net projects argorha br StraightEdge Open Source Java D path finding using A and lighting project Includes applet demos br python pathfinding Open Source Python D path finding using Dijkstra s Algorithm and lighting project br Daedalus Lib Open Source Daedalus Lib manages fully dynamic triangulated D environment modeling and pathfinding through A and funnel algorithms 