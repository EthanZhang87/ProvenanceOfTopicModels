title: Design by contract
id: 39289
Design by contract DbC also known as contract programming programming by contract and design by contract programming is an approach for designing software br It prescribes that software designers should define formal precise and verifiable interface specifications for software components which extend the ordinary definition of abstract data types with preconditions postconditions and invariants These specifications are referred to as contracts in accordance with a conceptual metaphor with the conditions and obligations of business contracts br The DbC approach assumes all client components that invoke an operation on a server component will meet the preconditions specified as required for that operation br Where this assumption is considered too risky as in multi channel or distributed computing the inverse approach is taken meaning that the server component tests that all relevant preconditions hold true before or while processing the client component s request and replies with a suitable error message if not br br br History br The term was coined by Bertrand Meyer in connection with his design of the Eiffel programming language and first described in various articles starting in and the two successive editions of his book Object Oriented Software Construction Eiffel Software applied for trademark registration for Design by Contract in December and it was granted in December The current owner of this trademark is Eiffel Software br Design by contract has its roots in work on formal verification formal specification and Hoare logic The original contributions include br br A clear metaphor to guide the design process br The application to inheritance in particular a formalism for redefinition and dynamic binding br The application to exception handling br The connection with automatic software documentation br br br Description br The central idea of DbC is a metaphor on how elements of a software system collaborate with each other on the basis of mutual obligations and benefits The metaphor comes from business life where a client and a supplier agree on a contract that defines for example that br br The supplier must provide a certain product obligation and is entitled to expect that the client has paid its fee benefit br The client must pay the fee obligation and is entitled to get the product benefit br Both parties must satisfy certain obligations such as laws and regulations applying to all contracts br Similarly if the method of a class in object oriented programming provides a certain functionality it may br br Expect a certain condition to be guaranteed on entry by any client module that calls it the method s precondition an obligation for the client and a benefit for the supplier the method itself as it frees it from having to handle cases outside of the precondition br Guarantee a certain property on exit the method s postcondition an obligation for the supplier and obviously a benefit the main benefit of calling the method for the client br Maintain a certain property assumed on entry and guaranteed on exit the class invariant br The contract is semantically equivalent to a Hoare triple which formalises the obligations This can be summarised by the three questions that the designer must repeatedly answer in the contract br br What does the contract expect br What does the contract guarantee br What does the contract maintain br Many programming languages have facilities to make assertions like these However DbC considers these contracts to be so crucial to software correctness that they should be part of the design process In effect DbC advocates writing the assertions first Contracts can be written by code comments enforced by a test suite or both even if there is no special language support for contracts br The notion of a contract extends down to the method procedure level the contract for each method will normally contain the following pieces of information br br Acceptable and unacceptable input values or types and their meanings br Return values or types and their meanings br Error and exception condition values or types that can occur and their meanings br Side effects br Preconditions br Postconditions br Invariants br more rarely Performance guarantees e g for time or space used br Subclasses in an inheritance hierarchy are allowed to weaken preconditions but not strengthen them and strengthen postconditions and invariants but not weaken them These rules approximate behavioural subtyping br All class relationships are between client classes and supplier classes A client class is obliged to make calls to supplier features where the resulting state of the supplier is not violated by the client call Subsequently the supplier is obliged to provide a return state and data that does not violate the state requirements of the client br For instance a supplier data buffer may require that data is present in the buffer when a delete feature is called Subsequently the supplier guarantees to the client that when a delete feature finishes its work the data item will indeed be deleted from the buffer Other design contracts are concepts of class invariant The class invariant guarantees for the local class that the state of the class will be maintained within specified tolerances at the end of each feature execution br When using contracts a supplier should not try to verify that the contract conditions are satisfied a practice known as offensive programming the general idea being that code should fail hard with contract verification being the safety net br DbC s fail hard property simplifies the debugging of contract behavior as the intended behaviour of each method is clearly specified br This approach differs substantially from that of defensive programming where the supplier is responsible for figuring out what to do when a precondition is broken More often than not the supplier throws an exception to inform the client that the precondition has been broken and in both cases DbC and defensive programming alike the client must figure out how to respond to that In such cases DbC makes the supplier s job easier br Design by contract also defines criteria for correctness for a software module br br If the class invariant AND precondition are true before a supplier is called by a client then the invariant AND the postcondition will be true after the service has been completed br When making calls to a supplier a software module should not violate the supplier s preconditions br Design by contract can also facilitate code reuse since the contract for each piece of code is fully documented The contracts for a module can be regarded as a form of software documentation for the behavior of that module br br br Performance implications br Contract conditions should never be violated during execution of a bug free program Contracts are therefore typically only checked in debug mode during software development Later at release the contract checks are disabled to maximize performance br In many programming languages contracts are implemented with assert Asserts are by default compiled away in release mode in C C and similarly deactivated in C and Java br Launching the Python interpreter with O for optimize as an argument will likewise cause the Python code generator to not emit any bytecode for asserts br This effectively eliminates the run time costs of asserts in production code irrespective of the number and computational expense of asserts used in development as no such instructions will be included in production by the compiler br br br Relationship to software testing br Design by contract does not replace regular testing strategies such as unit testing integration testing and system testing Rather it complements external testing with internal self tests that can be activated both for isolated tests and in production code during a test phase br The advantage of internal self tests is that they can detect errors before they manifest themselves as invalid results observed by the client This leads to earlier and more specific error detection br The use of assertions can be considered to be a form of test oracle a way of testing the design by contract implementation br br br Language support br br br Languages with native support br Languages that implement most DbC features natively include br br Ada br Ciao br Clojure br Cobra br D br Dafny br Eiffel br Fortress br Kotlin br Mercury br Oxygene formerly Chrome and Delphi Prism br Racket including higher order contracts and emphasizing that contract violations must blame the guilty party and must do so with an accurate explanation br Sather br Scala br SPARK via static analysis of Ada programs br Vala br VDM br Additionally the standard method combination in the Common Lisp Object System has the method qualifiers before after and around that allow writing contracts as auxiliary methods among other uses br br br Languages with third party support br br Various libraries preprocessors and other tools have been developed for existing programming languages without native design by contract support br br Ada via GNAT pragmas for preconditions and postconditions br C br DBC for C preprocessor br GNU Nana br eCv formal verification tools br C br Boost Contract br eCv formal verification tools br Digital Mars C compiler via CTESK extension of C br Loki Library provides a mechanism named ContractChecker that verifies a class follows design by contract br DBC C Design by contract for C br C and other NET languages via Code Contracts a Microsoft Research project integrated into the NET Framework br Groovy via GContracts br Go via dbc or gocontracts br Java br Active br OVal with AspectJ br Contracts for Java Cofoja br Java Modeling Language JML br Bean Validation only pre and postconditions br valid j br SafeR with safe references br Inactive unknown br Jtest active but DbC seems not to be supported anymore br iContract JContracts br Contract J br jContractor br C J br Google CodePro Analytix br SpringContracts for the Spring Framework br Jass Archived at the Wayback Machine br Modern Jass successor is Cofoja br JavaDbC using AspectJ br JavaTESK using extension of Java br chex j using javassist br highly customizable java on contracts br JavaScript via decorator contracts AspectJS specifically AJS Validator Cerny js ecmaDebug jsContract dbc code contracts or jscategory br Common Lisp via the macro facility or the CLOS metaobject protocol br Nemerle via macros br Nim via macros br Perl via the CPAN modules Class Contract by Damian Conway or Carp Datum by Raphael Manfredi br PHP via PhpDeal Praspel or Stuart Herbert s ContractLib br Python using packages like deal icontract PyContracts dpcontracts or zope interface A permanent change to Python to support design by contracts was proposed in PEP in but is deferred br Ruby via Brian McCallister s DesignByContract Ruby DBC ruby contract or contracts ruby br Rust via the contracts crate br Swift via the cocoapod by Jim Boyd br Tcl via the XOTcl object oriented extension br br br See also br Component based software engineering br Correctness computer science br Defensive programming br Fail fast system br Formal methods br Hoare logic br Modular programming br Program derivation br Program refinement br Strong typing br Test driven development br Typestate analysis br br br Notes br br br Bibliography br br br External links br The Power of Design by Contract TM A top level description of DbC with links to additional resources br Building bug free O O software An introduction to Design by Contract TM Older material on DbC br Benefits and drawbacks implementation in RPS Obix br Using Code Contracts for Safer Code