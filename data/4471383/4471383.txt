title: Structural type system
id: 4471383
A structural type system or property based type system is a major class of type systems in which type compatibility and equivalence are determined by the type s actual structure or definition and not by other characteristics such as its name or place of declaration Structural systems are used to determine if types are equivalent and whether a type is a subtype of another It contrasts with nominative systems where comparisons are based on the names of the types or explicit declarations and duck typing in which only the part of the structure accessed at runtime is checked for compatibility br br br Description br In structural typing an element is considered to be compatible with another if for each feature within the second element s type a corresponding and identical feature exists in the first element s type Some languages may differ on the details such as whether the features must match in name This definition is not symmetric and includes subtype compatibility Two types are considered to be identical if each is compatible with the other br For example OCaml uses structural typing on methods for compatibility of object types Go uses structural typing on methods to determine compatibility of a type with an interface C template functions exhibit structural typing on type arguments Haxe uses structural typing but classes are not structurally subtyped br In languages which support subtype polymorphism a similar dichotomy can be formed based on how the subtype relationship is defined One type is a subtype of another if and only if it contains all the features of the base type or subtypes thereof The subtype may contain added features such as members not present in the base type or stronger invariants br A distinction exists between structural substitution for inferred and non inferred polymorphism Some languages such as Haskell do not substitute structurally in the case where an expected type is declared i e not inferred e g only substitute for functions that are signature based polymorphic via type inference Then it is not possible to accidentally subtype a non inferred type although it may still be possible to provide an explicit conversion to a non inferred type which is invoked implicitly br Structural subtyping is arguably more flexible than nominative subtyping as it permits the creation of ad hoc types and protocols in particular it permits creation of a type which is a supertype of an existing type without modifying the definition of the latter However this may not be desirable where the programmer wishes to create closed abstractions br A pitfall of structural typing versus nominative typing is that two separately defined types intended for different purposes but accidentally holding the same properties e g both composed of a pair of integers could be considered the same type by the type system simply because they happen to have identical structure One way this can be avoided is by creating one algebraic data type for each use br In Cook et al proved that inheritance is not subtyping in structurally typed OO languages br Checking that two types are compatible based on structural typing is a non trivial operation e g requires maintaining a stack of previous checked types br br br Example br Objects in OCaml are structurally typed by the names and types of their methods br Objects can be created directly immediate objects without going through a nominative class Classes only serve as functions for creating objects br br Here the OCaml interactive runtime prints out the inferred type of the object for convenience Its type get x int set x int unit is defined only by its methods In other words the type of x is defined by the method types get x int and set x int unit rather than by any name br To define another object which has the same methods and types of methods br br OCaml considers them the same type For example the equality operator is typed to only take two values of the same type br br So they must be the same type or else this wouldn t even type check This shows that equivalence of types is structural br One can define a function that invokes a method br br The inferred type for the first argument set x int a is interesting The means that the first argument can be any object which has a set x method which takes an int as argument br So it can be used on object x br br Another object can be made that happens to have that method and method type the other methods are irrelevant br br The set to function also works on it br br This shows that compatibility for things like method invocation is determined by structure br Let us define a type synonym for objects with only a get x method and no other methods br br The object x is not of this type but structurally x is of a subtype of this type since x contains a superset of its methods So x can be coerced to this type br br But not object z because it is not a structural subtype br br z simpler obj br This expression cannot be coerced to type simpler obj get x int br it has type blahblah float set x int unit but is here used with type br get x int br The first object type has no method get x br br This shows that compatibility for widening coercions are structural br br br br br Pierce Benjamin C Types and Programming Languages MIT Press ISBN br br br External links br NominativeAndStructuralTyping at WikiWikiWeb