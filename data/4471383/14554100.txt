title: Substructural type system
id: 14554100
Substructural type systems are a family of type systems analogous to substructural logics where one or more of the structural rules are absent or only allowed under controlled circumstances Such systems can constrain access to system resources such as files locks and memory by keeping track of changes of state and prohibiting invalid states br br br Different substructural type systems br Several type systems have emerged by discarding some of the structural rules of exchange weakening and contraction br br Ordered type systems discard exchange weakening and contraction Every variable is used exactly once in the order it was introduced br Linear type systems allow exchange but neither weakening nor contraction Every variable is used exactly once br Affine type systems allow exchange and weakening but not contraction Every variable is used at most once br Relevant type systems allow exchange and contraction but not weakening Every variable is used at least once br Normal type systems allow exchange weakening and contraction Every variable may be used arbitrarily br The explanation for affine type systems is best understood if rephrased as every occurrence of a variable is used at most once br br br Ordered type system br Ordered types correspond to noncommutative logic where exchange contraction and weakening are discarded This can be used to model stack based memory allocation contrast with linear types which can be used to model heap based memory allocation Without the exchange property an object may only be used when at the top of the modelled stack after which it is popped off resulting in every variable being used exactly once in the order it was introduced br br br Linear type systems br Linear types correspond to linear logic and ensure that objects are used exactly once This allows the system to safely deallocate an object after its use or to design software interfaces that guarantee a resource cannot be used once it has been closed or transitioned to a different state br The Clean programming language makes use of uniqueness types a variant of linear types to help support concurrency input output and in place update of arrays br Linear type systems allow references but not aliases To enforce this a reference goes out of scope after appearing on the right hand side of an assignment thus ensuring that only one reference to any object exists at once Note that passing a reference as an argument to a function is a form of assignment as the function parameter will be assigned the value inside the function and therefore such use of a reference also causes it to go out of scope br The single reference property makes linear type systems suitable as programming languages for quantum computing as it reflects the no cloning theorem of quantum states From the category theory point of view no cloning is a statement that there is no diagonal functor which could duplicate states similarly from the combinatory logic point of view there is no K combinator which can destroy states From the lambda calculus point of view a variable x can appear exactly once in a term br Linear type systems are the internal language of closed symmetric monoidal categories much in the same way that simply typed lambda calculus is the language of Cartesian closed categories More precisely one may construct functors between the category of linear type systems and the category of closed symmetric monoidal categories br br br Affine type systems br Affine types are a version of linear types allowing to discard i e not use a resource corresponding to affine logic An affine resource can be used at most once while a linear one must be used exactly once br br br Relevant type system br Relevant types correspond to relevant logic which allows exchange and contraction but not weakening which translates to every variable being used at least once br br br The resource interpretation br br The nomenclature offered by substructural type systems is useful to characterize resource management aspects of a language br Resource management is the aspect of language safety concerned with ensuring that each allocated resource is deallocated exactly once br Thus the resource interpretation is only concerned with uses that transfer ownership moving where ownership is the responsibility to free the resource br Uses that don t transfer ownership borrowing are not in scope of this interpretation but lifetime semantics further restrict these uses to be between allocation and deallocation br br br Resource affine types br Under the resource interpretation an affine type can not be spent more than once br As an example the same variant of Hoare s vending machine can be expressed in English logic and in Rust br br What it means for Coin to be an affine type in this example which it is unless it implements the Copy trait is that trying to spend the same coin twice is an invalid program that the compiler is entitled to reject br br In other words an affine type system can express the typestate pattern br Functions can consume and return an object wrapped in different types acting like state transitions in a state machine that stores its state as a type in the caller s context a typestate An API can exploit this to statically enforce that its functions are called in a correct order br What it doesn t mean however is that a variable can t be used without using it up br br What Rust is not able to express is a coin type that cannot go out of scope that would take a linear type br br br Resource linear types br Under the resource interpretation a linear type not only can be moved like an affine type but must be moved going out of scope is an invalid program br br An attraction with linear types is that destructors become regular functions that can take arguments can fail and so on This may for example avoid the need to keep state that is only used for destruction A general advantage of passing function dependencies explicitly is that the order of function calls destruction order becomes statically verifiable in terms of the arguments lifetimes Compared to internal references this does not require lifetime annotations as in Rust br As with manual resource management a practical problem is that any early return as is typical of error handling must achieve the same cleanup This becomes pedantic in languages that have stack unwinding where every function call is a potential early return However as a close analogy the semantic of implicitly inserted destructor calls can be restored with deferred function calls br br br Resource normal types br Under the resource interpretation a normal type does not restrict how many times a variable can be moved from C specifically nondestructive move semantics falls in this category br br br Programming languages br The following programming languages support linear or affine types br br br See also br Effect system br Linear logic br Affine logic br br br 