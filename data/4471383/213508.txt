title: Subtyping
id: 213508
In programming language theory subtyping also called subtype polymorphism or inclusion polymorphism is a form of type polymorphism A subtype is a datatype that is related to another datatype the supertype by some notion of substitutability meaning that program elements typically subroutines or functions written to operate on elements of the supertype can also operate on elements of the subtype br If S is a subtype of T the subtyping relation written as S T S T or S T means that any term of type S can safely be used in any context where a term of type T is expected The precise semantics of subtyping here crucially depends on the particulars of how safely be used and any context are defined by a given type formalism or programming language The type system of a programming language essentially defines its own subtyping relation which may well be trivial should the language support no or very little conversion mechanisms br Due to the subtyping relation a term may belong to more than one type Subtyping is therefore a form of type polymorphism In object oriented programming the term polymorphism is commonly used to refer solely to this subtype polymorphism while the techniques of parametric polymorphism would be considered generic programming br Functional programming languages often allow the subtyping of records Consequently simply typed lambda calculus extended with record types is perhaps the simplest theoretical setting in which a useful notion of subtyping may be defined and studied Because the resulting calculus allows terms to have more than one type it is no longer a simple type theory Since functional programming languages by definition support function literals which can also be stored in records records types with subtyping provide some of the features of object oriented programming Typically functional programming languages also provide some usually restricted form of parametric polymorphism In a theoretical setting it is desirable to study the interaction of the two features a common theoretical setting is system F Various calculi that attempt to capture the theoretical properties of object oriented programming may be derived from system F br The concept of subtyping is related to the linguistic notions of hyponymy and holonymy It is also related to the concept of bounded quantification in mathematical logic see Order sorted logic Subtyping should not be confused with the notion of class or object inheritance from object oriented languages subtyping is a relation between types interfaces in object oriented parlance whereas inheritance is a relation between implementations stemming from a language feature that allows new objects to be created from existing ones In a number of object oriented languages subtyping is called interface inheritance with inheritance referred to as implementation inheritance br br br Origins br The notion of subtyping in programming languages dates back to the s it was introduced in Simula derivatives The first formal treatments of subtyping were given by John C Reynolds in who used category theory to formalize implicit conversions and Luca Cardelli br The concept of subtyping has gained visibility and synonymy with polymorphism in some circles with the mainstream adoption of object oriented programming In this context the principle of safe substitution is often called the Liskov substitution principle after Barbara Liskov who popularized it in a keynote address at a conference on object oriented programming in Because it must consider mutable objects the ideal notion of subtyping defined by Liskov and Jeannette Wing called behavioral subtyping is considerably stronger than what can be implemented in a type checker See Function types below for details br br br Examples br br A simple practical example of subtypes is shown in the diagram The type bird has three subtypes duck cuckoo and ostrich Conceptually each of these is a variety of the basic type bird that inherits many bird characteristics but has some specific differences The UML notation is used in this diagram with open headed arrows showing the direction and type of the relationship between the supertype and its subtypes br As a more practical example a language might allow integer values to be used wherever floating point values are expected Integer Float or it might define a generic type Number as a common supertype of integers and the reals In this second case we only have Integer Number and Float Number but Integer and Float are not subtypes of each other br Programmers may take advantage of subtyping to write code in a more abstract manner than would be possible without it Consider the following example br br If integer and real are both subtypes of Number and an operator of comparison with an arbitrary Number is defined for both types then values of either type can be passed to this function However the very possibility of implementing such an operator highly constrains the Number type for example one can t compare an integer with a complex number and actually only comparing integers with integers and reals with reals makes sense Rewriting this function so that it would only accept x and y of the same type requires bounded polymorphism br br br Subsumption br In type theory the concept of subsumption is used to define or evaluate whether a type S is a subtype of type T br A type is a set of values The set can be described extensionally by listing all the values or it can be described intensionally by stating the membership of the set by a predicate over a domain of possible values In common programming languages enumeration types are defined extensionally by listing values User defined types like records structs interfaces or classes are defined intensionally by an explicit type declaration or by using an existing value which encodes type information as a prototype to be copied or extended br In discussing the concept of subsumption the set of values of a type is indicated by writing its name in mathematical italics T The type viewed as a predicate over a domain is indicated by writing its name in bold T The conventional symbol means is a subtype of and means is a supertype of br br A type T subsumes S if the set of values T which it defines is a superset of the set S so that every member of S is also a member of T br A type may be subsumed by more than one type the supertypes of S intersect at S br If S T and therefore S T then T the predicate which circumscribes the set T must be part of the predicate S over the same domain which defines S br If S subsumes T and T subsumes S then the two types are equal although they may not be the same type if the type system distinguishes types by name br In terms of information specificity a subtype is considered more specific than any one of its supertypes because it holds at least as much information as each of them This may increase the applicability or relevance of the subtype the number of situations where it can be accepted or introduced as compared to its more general supertypes The disadvantage of having this more detailed information is that it represents incorporated choices which reduce the prevalence of the subtype the number of situations which are able to generate or produce it br In the context of subsumption the type definitions can be expressed using Set builder notation which uses a predicate to define a set Predicates can be defined over a domain set of possible values D Predicates are partial functions that compare values to selection criteria For example is an integer value greater than or equal to and less than If a value matches the criteria then the function returns the value If not the value is not selected and nothing is returned List comprehensions are a form of this pattern used in many programming languages br If there are two predicates br br br br br P br br T br br br br br displaystyle P T br br which applies selection criteria for the type T and br br br br br P br br s br br br br br displaystyle P s br br which applies additional criteria for the type S then sets for the two types can be defined br br br br br T br br br v br br D br br br br P br br T br br br br v br br br br br displaystyle T v in D mid P T v br br br br br br S br br br v br br D br br br br P br br T br br br br v br br br and br br br P br br s br br br br v br br br br br displaystyle S v in D mid P T v text and P s v br br br The predicate br br br br br T br br br br P br br T br br br br br displaystyle mathbf T P T br br is applied alongside br br br br br P br br s br br br br br displaystyle P s br br as part of the compound predicate S defining S The two predicates are conjoined so both must be true for a value to be selected The predicate br br br br br S br br br br T br br br br P br br s br br br br br P br br T br br br br br P br br s br br br br br displaystyle mathbf S mathbf T land P s P T land P s br br subsumes the predicate T so S T br For example there is a subfamily of cat species called Felinae which is part of the family Felidae The genus Felis to which the domestic cat species Felis catus belongs is part of that subfamily br br br br br br br F br e br l br i br n br a br e br br br c br a br t br br F br e br l br i br d br a br e br br br o br f br S br u br b br f br a br m br i br l br y br br c br a br t br br f br e br l br i br n br a br e br S br u br b br f br a br m br i br l br y br N br a br m br e br br br br br br br displaystyle mathit Felinae cat in Felidae mid ofSubfamily cat felinaeSubfamilyName br br br br br br br br F br e br l br i br s br br br c br a br t br br F br e br l br i br n br a br e br br br o br f br G br e br n br u br s br br c br a br t br br f br e br l br i br s br G br e br n br u br s br N br a br m br e br br br br br br br displaystyle mathit Felis cat in Felinae mid ofGenus cat felisGenusName br br br The conjunction of predicates has been expressed here through application of the second predicate over the domain of values conforming to the first predicate Viewed as types Felis Felinae Felidae br If T subsumes S T S then a procedure function or expression given a value br br br br s br br S br br br displaystyle s in S br br as an operand parameter value or term will therefore be able to operate over that value as one of type T because br br br br s br br T br br br displaystyle s in T br br In the example above we could expect the function ofSubfamily to be applicable to values of all three types Felidae Felinae and Felis br br br Subtyping schemes br Type theorists make a distinction between nominal subtyping in which only types declared in a certain way may be subtypes of each other and structural subtyping in which the structure of two types determines whether or not one is a subtype of the other The class based object oriented subtyping described above is nominal a structural subtyping rule for an object oriented language might say that if objects of type A can handle all of the messages that objects of type B can handle that is if they define all the same methods then A is a subtype of B regardless of whether either inherits from the other This so called duck typing is common in dynamically typed object oriented languages Sound structural subtyping rules for types other than object types are also well known br Implementations of programming languages with subtyping fall into two general classes inclusive implementations in which the representation of any value of type A also represents the same value at type B if A B and coercive implementations in which a value of type A can be automatically converted into one of type B The subtyping induced by subclassing in an object oriented language is usually inclusive subtyping relations that relate integers and floating point numbers which are represented differently are usually coercive br In almost all type systems that define a subtyping relation it is reflexive meaning A A for any type A and transitive meaning that if A B and B C then A C This makes it a preorder on types br br br Record types br br br Width and depth subtyping br Types of records give rise to the concepts of width and depth subtyping These express two different ways of obtaining a new type of record that allows the same operations as the original record type br Recall that a record is a collection of named fields Since a subtype is a type which allows all operations allowed on the original type a record subtype should support the same operations on the fields as the original type supported br One kind of way to achieve such support called width subtyping adds more fields to the record More formally every named field appearing in the width supertype will appear in the width subtype Thus any operation feasible on the supertype will be supported by the subtype br The second method called depth subtyping replaces the various fields with their subtypes That is the fields of the subtype are subtypes of the fields of the supertype Since any operation supported for a field in the supertype is supported for its subtype any operation feasible on the record supertype is supported by the record subtype Depth subtyping only makes sense for immutable records for example you can assign to the x field of a real point a record with two real fields but you can t do the same to the x field of an integer point which however is a deep subtype of the real point type because is not an integer see Variance br Subtyping of records can be defined in System F which combines parametric polymorphism with subtyping of record types and is a theoretical basis for many functional programming languages that support both features br Some systems also support subtyping of labeled disjoint union types such as algebraic data types The rule for width subtyping is reversed every tag appearing in the width subtype must appear in the width supertype br br br Function types br If T T is a function type then a subtype of it is any function type S S with the property that T S and S T This can be summarised using the following typing rule br br br br br br br br T br br br br br br br S br br br br br br br S br br br br br br br T br br br br br br br br br S br br br br br br br S br br br br br br br T br br br br br br br T br br br br br br br br displaystyle T leq S quad S leq T over S rightarrow S leq T rightarrow T br br br The parameter type of S S is said to be contravariant because the subtyping relation is reversed for it whereas the return type is covariant Informally this reversal occurs because the refined type is more liberal in the types it accepts and more conservative in the type it returns This is what exactly works in Scala a n ary function is internally a class that inherits the br br br br br br F br u br n br c br t br i br o br br n br br N br br br br br br br A br br br br br br br br br br A br br br br br br br br br br br br A br br n br br br br br br br B br br br br br br br displaystyle mathtt Function N A A dots A n B br br trait which can be seen as a general interface in Java like languages where br br br br br br br A br br br br br br br A br br br br br br br br br A br br n br br br br br br br displaystyle mathtt A A dots A n br br are the parameter types and br br br br br br B br br br br br displaystyle mathtt B br br is its return type before the type means the type is contravariant while means covariant br In languages that allow side effects like most object oriented languages subtyping is generally not sufficient to guarantee that a function can be safely used in the context of another Liskov s work in this area focused on behavioral subtyping which besides the type system safety discussed in this article also requires that subtypes preserve all invariants guaranteed by the supertypes in some contract This definition of subtyping is generally undecidable so it cannot be verified by a type checker br The subtyping of mutable references is similar to the treatment of parameter values and return values Write only references or sinks are contravariant like parameter values read only references or sources are covariant like return values Mutable references which act as both sources and sinks are invariant br br br Relationship with inheritance br Subtyping and inheritance are independent orthogonal relationships They may coincide but none is a special case of the other In other words between two types S and T all combinations of subtyping and inheritance are possible br br S is neither a subtype nor a derived type of T br S is a subtype but is not a derived type of T br S is not a subtype but is a derived type of T br S is both a subtype and a derived type of T br The first case is illustrated by independent types such as Boolean and Float br The second case can be illustrated by the relationship between Int and Int In most object oriented programming languages Int are unrelated by inheritance to Int However Int can be considered a subtype of Int since any bit integer value can be promoted into a bit integer value br br The third case is a consequence of function subtyping input contravariance Assume a super class of type T having a method m returning an object of the same type i e the type of m is T T also note that the first parameter of m is this self and a derived class type S from T By inheritance the type of m in S is S S In order for S to be a subtype of T the type of m in S must be a subtype of the type of m in T in other words S S T T By bottom up application of the function subtyping rule this means S T and T S which is only possible if S and T are the same Since inheritance is an irreflexive relation S can t be a subtype of T br Subtyping and inheritance are compatible when all inherited fields and methods of the derived type have types which are subtypes of the corresponding fields and methods from the inherited type br br br Coercions br In coercive subtyping systems subtypes are defined by implicit type conversion functions from subtype to supertype For each subtyping relationship S T a coercion function coerce S T is provided and any object s of type S is regarded as the object coerceS T s of type T A coercion function may be defined by composition if S T and T U then s may be regarded as an object of type u under the compound coercion coerceT U coerceS T The type coercion from a type to itself coerceT T is the identity function idT br Coercion functions for records and disjoint union subtypes may be defined componentwise in the case of width extended records type coercion simply discards any components which are not defined in the supertype The type coercion for function types may be given by f t coerceS T f coerceT S t reflecting the contravariance of parameter values and covariance of return values br The coercion function is uniquely determined given the subtype and supertype Thus when multiple subtyping relationships are defined one must be careful to guarantee that all type coercions are coherent For instance if an integer such as int can be coerced to a floating point number say float then it is not admissible to coerce float to int because the compound coercion coercefloat float given by coerceint float coercefloat int would then be distinct from the identity coercion idfloat br br br See also br br Covariance and contravariance br The circle ellipse problem for the perils of subtyping variable types on the same basis as value types br Class based programming br Top type br Refinement type br Behavioral subtyping br br br Notes br br br br Textbooks br br Papers br br br Further reading 