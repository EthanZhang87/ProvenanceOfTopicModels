title: Algebraic data type
id: 283867
In computer programming especially functional programming and type theory an algebraic data type ADT is a kind of composite type i e a type formed by combining other types br Two common classes of algebraic types are product types i e tuples and records and sum types i e tagged or disjoint unions coproduct types or variant types br The values of a product type typically contain several values called fields All values of that type have the same combination of field types The set of all possible values of a product type is the set theoretic product i e the Cartesian product of the sets of all possible values of its field types br The values of a sum type are typically grouped into several classes called variants A value of a variant type is usually created with a quasi functional entity called a constructor Each variant has its own constructor which takes a specified number of arguments with specified types The set of all possible values of a sum type is the set theoretic sum i e the disjoint union of the sets of all possible values of its variants Enumerated types are a special case of sum types in which the constructors take no arguments as exactly one value is defined for each constructor br Values of algebraic types are analyzed with pattern matching which identifies a value by its constructor or field names and extracts the data it contains br br br History br Algebraic data types were introduced in Hope a small functional programming language developed in the s at the University of Edinburgh br br br Examples br br br Singly Linked List br One of the most common examples of an algebraic data type is the singly linked list A list type is a sum type with two variants Nil for an empty list and Cons x xs for the combination of a new element x with a list xs to create a new list Here is an example of how a singly linked list would be declared in Haskell br br or br br Cons is an abbreviation of construct Many languages have special syntax for lists defined in this way For example Haskell and ML use for Nil or for Cons respectively and square brackets for entire lists So Cons Cons Cons Nil would normally be written as or in Haskell or as or in ML br br br Binary Tree br For a slightly more complex example binary trees may be implemented in Haskell as follows br br or br br Here Empty represents an empty tree Leaf represents a leaf node and Node organizes the data into branches br In most languages that support algebraic data types it is possible to define parametric types Examples are given later in this article br Somewhat similar to a function a data constructor is applied to arguments of an appropriate type yielding an instance of the data type to which the type constructor belongs For example the data constructor Leaf is logically a function Int Tree meaning that giving an integer as an argument to Leaf produces a value of the type Tree As Node takes two arguments of the type Tree itself the datatype is recursive br Operations on algebraic data types can be defined by using pattern matching to retrieve the arguments For example consider a function to find the depth of a Tree given here in Haskell br br Thus a Tree given to depth can be constructed using any of Empty Leaf or Node and must be matched for any of them respectively to deal with all cases In case of Node the pattern extracts the subtrees l and r for further processing br br br Abstract Syntax br Algebraic data types are highly suited to implementing abstract syntax For example the following algebraic data type describes a simple language representing numerical expressions br br An element of such a data type would have a form such as Mult Add Number Minus Number Number Number br Writing an evaluation function for this language is a simple exercise however more complex transformations also become feasible For example an optimization pass in a compiler might be written as a function taking an abstract expression as input and returning an optimized form br br br Pattern matching br br Algebraic data types are used to represent values that can be one of several types of things Each type of thing is associated with an identifier called a constructor which can be considered a tag for that kind of data Each constructor can carry with it a different type of data br For example considering the binary Tree example shown above a constructor could carry no data e g Empty or one piece of data e g Leaf has one Int value or multiple pieces of data e g Node has two Tree values br To do something with a value of this Tree algebraic data type it is deconstructed using a process called pattern matching This involves matching the data with a series of patterns The example function depth above pattern matches its argument with three patterns When the function is called it finds the first pattern that matches its argument performs any variable bindings that are found in the pattern and evaluates the expression corresponding to the pattern br Each pattern above has a form that resembles the structure of some possible value of this datatype The first pattern simply matches values of the constructor Empty The second pattern matches values of the constructor Leaf Patterns are recursive so then the data that is associated with that constructor is matched with the pattern n In this case a lowercase identifier represents a pattern that matches any value which then is bound to a variable of that name in this case a variable n is bound to the integer value stored in the data type to be used in the expression to evaluate br The recursion in patterns in this example are trivial but a possible more complex recursive pattern would be something like br Node Node Leaf x Node y Node Empty z br Recursive patterns several layers deep are used for example in balancing red black trees which involve cases that require looking at colors several layers deep br The example above is operationally equivalent to the following pseudocode br br The advantages of algebraic data types can be highlighted by comparison of the above pseudocode with a pattern matching equivalent br Firstly there is type safety In the pseudocode example above programmer diligence is required to not access field when the constructor is a Leaf Also the type of field is different for Leaf and Node For Leaf it is Int but for Node it is Tree The type system would have difficulties assigning a static type in a safe way for traditional record data structures However in pattern matching such problems are not faced The type of each extracted value is based on the types declared by the relevant constructor The number of values that can be extracted is known based on the constructor br Secondly in pattern matching the compiler performs exhaustiveness checking to ensure all cases are handled If one of the cases of the depth function above were missing the compiler would issue a warning Exhaustiveness checking may seem easy for simple patterns but with many complex recursive patterns the task soon becomes difficult for the average human or compiler if it must check arbitrary nested if else constructs Similarly there may be patterns which never match i e are already covered by prior patterns The compiler can also check and issue warnings for these as they may indicate an error in reasoning br Algebraic data type pattern matching should not be confused with regular expression string pattern matching The purpose of both is similar to extract parts from a piece of data matching certain constraints however the implementation is very different Pattern matching on algebraic data types matches on the structural properties of an object rather than on the character sequence of strings br br br Theory br br A general algebraic data type is a possibly recursive sum type of product types Each constructor tags a product type to separate it from others or if there is only one constructor the data type is a product type Further the parameter types of a constructor are the factors of the product type A parameterless constructor corresponds to the empty product If a datatype is recursive the entire sum of products is wrapped in a recursive type and each constructor also rolls the datatype into the recursive type br For example the Haskell datatype br br is represented in type theory as br br br br br br br br br br br br br br br br br displaystyle lambda alpha mu beta alpha times beta br br br with constructors br br br br br br n br i br l br br br br br br br br r br o br l br l br br br br br i br n br l br br br br br br br br displaystyle mathrm nil alpha mathrm roll mathrm inl langle rangle br br and br br br br br br c br o br n br s br br br br br br br x br br l br br br r br o br l br l br br br br br i br n br r br br br br x br br l br br br br br displaystyle mathrm cons alpha x l mathrm roll mathrm inr langle x l rangle br br br The Haskell List datatype can also be represented in type theory in a slightly different form thus br br br br br br br br br br br br br br br br br br br displaystyle mu phi lambda alpha alpha times phi alpha br br br Note how the br br br br br br br displaystyle mu br br and br br br br br br br displaystyle lambda br br constructs are reversed relative to the original The original formation specified a type function whose body was a recursive type The revised version specifies a recursive function on types The type variable br br br br br br br displaystyle phi br br is used to suggest a function rather than a base type like br br br br br br br displaystyle beta br br since br br br br br br br displaystyle phi br br is like a Greek f The function must also now be applied br br br br br br br displaystyle phi br br to its argument type br br br br br br br displaystyle alpha br br in the body of the type br For the purposes of the List example these two formulations are not significantly different but the second form allows expressing so called nested data types i e those where the recursive type differs parametrically from the original For more information on nested data types see the works of Richard Bird Lambert Meertens and Ross Paterson br In set theory the equivalent of a sum type is a disjoint union a set whose elements are pairs consisting of a tag equivalent to a constructor and an object of a type corresponding to the tag equivalent to the constructor arguments br br br Programming languages with algebraic data types br br Many programming languages incorporate algebraic data types as a first class notion including br br br See also br Disjoint union br Generalized algebraic data type br Initial algebra br Quotient type br Tagged union br Type theory br Visitor pattern br br br 