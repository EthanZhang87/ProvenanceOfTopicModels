title: Intersection type
id: 24140211
In type theory an intersection type can be allocated to values that can be assigned both the type br br br br br br br displaystyle sigma br br and the type br br br br br br br displaystyle tau br br This value can be given the intersection type br br br br br br br br br displaystyle sigma cap tau br br in an intersection type system br Generally if the ranges of values of two types overlap then a value belonging to the intersection of the two ranges can be assigned the intersection type of these two types Such a value can be safely passed as argument to functions expecting either of the two types br For example in Java the class Boolean implements both the Serializable and the Comparable interfaces Therefore an object of type Boolean can be safely passed to functions expecting an argument of type Serializable and to functions expecting an argument of type Comparable br Intersection types are composite data types Similar to product types they are used to assign several types to an object br However product types are assigned to tuples so that each tuple element is assigned a particular product type component br In comparison underlying objects of intersection types are not necessarily composite A restricted form of intersection types are refinement types br Intersection types are useful for describing overloaded functions For example if number number is the type of function taking a number as an argument and returning a number and string string is the type of function taking a string as an argument and returning a string then the intersection of these two types can be used to describe overloaded functions that do one or the other based on what type of input they are given br Contemporary programming languages including Ceylon Flow Java Scala TypeScript and Whiley see comparison of languages with intersection types use intersection types to combine interface specifications and to express ad hoc polymorphism br Complementing parametric polymorphism intersection types may be used to avoid class hierarchy pollution from cross cutting concerns and reduce boilerplate code as shown in the TypeScript example below br The type theoretic study of intersection types is referred to as the intersection type discipline br Remarkably program termination can be precisely characterized using intersection types br br br TypeScript example br TypeScript supports intersection types improving expressiveness of the type system and reducing potential class hierarchy size demonstrated as follows br The following program code defines the classes Chicken Cow and RandomNumberGenerator that each have a method produce returning an object of either type Egg Milk or number br Additionally the functions eatEgg and drinkMilk require arguments of type Egg and Milk respectively br br The following program code defines the ad hoc polymorphic function animalToFood that invokes the member function produce of the given object animal br The function animalToFood has two type annotations namely Chicken Egg and Cow Milk connected via the intersection type constructor br Specifically animalToFood when applied to an argument of type Chicken returns an object of type type Egg and when applied to an argument of type Cow returns an object of type type Milk br Ideally animalToFood should not be applicable to any object having possibly by chance a produce method br br Finally the following program code demonstrates type safe use of the above definitions br br The above program code has the following properties br br Lines create objects chicken cow and randomNumberGenerator of their respective type br Lines print for the previously created objects the respective results provided as comments when invoking produce br Line resp demonstrates type safe use of the method animalToFood applied to chicken resp cow br Line if uncommented would result in a type error at compile time Although the implementation of animalToFood could invoke the produce method of randomNumberGenerator the type annotation of animalToFood disallows it This is in accordance with the intended meaning of animalToFood br Line resp demonstrates that applying animalToFood to chicken resp cow results in an object of type Egg resp Milk br Line resp demonstrates that applying animalToFood to cow resp chicken does not result in an object of type Egg resp Milk Therefore if uncommented line resp would result in a type error at compile time br br br Comparison to inheritance br The above minimalist example can be realized using inheritance for instance by deriving the classes Chicken and Cow from a base class Animal br However in a larger setting this could be disadvantageous br Introducing new classes into a class hierarchy is not necessarily justified for cross cutting concerns or maybe outright impossible for example when using an external library br Imaginably the above example could be extended with the following classes br br a class Horse that does not have a produce method br a class Sheep that has a produce method returning Wool br a class Pig that has a produce method which can be used only once returning Meat br This may require additional classes or interfaces specifying whether a produce method is available whether the produce method returns food and whether the produce method can be used repeatedly br Overall this may pollute the class hierarchy br br br Comparison to duck typing br The above minimalist example already shows that duck typing is less suited to realize the given scenario br While the class RandomNumberGenerator contains a produce method the object randomNumberGenerator should not be a valid argument for animalToFood br The above example can be realized using duck typing for instance by introducing a new field argumentForAnimalToFood to the classes Chicken and Cow signifying that objects of corresponding type are valid arguments for animalToFood br However this would not only increase the size of the respective classes especially with the introduction of more methods similar to animalToFood but is also a non local approach with respect to animalToFood br br br Comparison to function overloading br The above example can be realized using function overloading for instance by implementing two methods animalToFood animal Chicken Egg and animalToFood animal Cow Milk br In TypeScript such a solution is almost identical to the provided example br Other programming languages such as Java require distinct implementations of the overloaded method br This may lead to either code duplication or boilerplate code br br br Comparison to the visitor pattern br The above example can be realized using the visitor pattern br It would require each animal class to implement an accept method accepting an object implementing the interface AnimalVisitor adding non local boilerplate code br The function animalToFood would be realized as the visit method of an implementation of AnimalVisitor br Unfortunately the connection between the input type Chicken or Cow and the result type Egg or Milk would be difficult to represent br br br Limitations br On the one hand intersection types can be used to locally annotate different types to a function without introducing new classes or interfaces to the class hierarchy br On the other hand this approach requires all possible argument types and result types to be specified explicitly br If the behavior of a function can be specified precisely by either a unified interface parametric polymorphism or duck typing then the verbose nature of intersection types is unfavorable br Therefore intersection types should be considered complementary to existing specification methods br br br Dependent intersection type br A dependent intersection type denoted br br br br br x br br br br br br br br displaystyle x sigma cap tau br br is a dependent type in which the type br br br br br br br displaystyle tau br br may depend on the term variable br br br br x br br br displaystyle x br br br In particular if a term br br br br M br br br displaystyle M br br has the dependent intersection type br br br br br x br br br br br br br br displaystyle x sigma cap tau br br then the term br br br br M br br br displaystyle M br br has both the type br br br br br br br displaystyle sigma br br and the type br br br br br br x br br M br br br br displaystyle tau x M br br where br br br br br br x br br M br br br br displaystyle tau x M br br is the type which results from replacing all occurrences of the term variable br br br br x br br br displaystyle x br br in br br br br br br br displaystyle tau br br by the term br br br br M br br br displaystyle M br br br br br Scala example br Scala supports type declarations as object members This allows a type of an object member to depend on the value of another member which is called a path dependent type br For example the following program text defines a Scala trait Witness which can be used to implement the singleton pattern br br The above trait Witness declares the member T which can be assigned a type as its value and the member value which can be assigned a value of type T br The following program text defines an object booleanWitness as instance of the above trait Witness br The object booleanWitness defines the type T as Boolean and the value value as true br For example executing System out println booleanWitness value prints true on the console br br Let br br br br br br br x br br br br br br br br displaystyle langle textsf x sigma rangle br br be the type specifically a record type of objects having the member br br br br br br x br br br br br displaystyle textsf x br br of type br br br br br br br displaystyle sigma br br br In the above example the object booleanWitness can be assigned the dependent intersection type br br br br br x br br br br br T br br br br br Type br br br br br br br br value br br br br x br br br br T br br br br br br displaystyle x langle textsf T text Type rangle cap langle textsf value x textsf T rangle br br br The reasoning is as follows The object booleanWitness has the member T that is assigned the type Boolean as its value br Since Boolean is a type the object booleanWitness has the type br br br br br br br T br br br br br Type br br br br br displaystyle langle textsf T text Type rangle br br br Additionally the object booleanWitness has the member value that is assigned the value true of type Boolean br Since the value of booleanWitness T is Boolean the object booleanWitness has the type br br br br br br br value br br br br br br booleanWitness T br br br br br br displaystyle langle textsf value textsf booleanWitness T rangle br br br Overall the object booleanWitness has the intersection type br br br br br br br T br br br br br Type br br br br br br br value br br br br br br booleanWitness T br br br br br br displaystyle langle textsf T text Type rangle cap langle textsf value textsf booleanWitness T rangle br br br Therefore presenting self reference as dependency the object booleanWitness has the dependent intersection type br br br br br x br br br br br T br br br br br Type br br br br br br br br value br br br br x br br br br T br br br br br br displaystyle x langle textsf T text Type rangle cap langle textsf value x textsf T rangle br br br Alternatively the above minimalistic example can be described using dependent record types br In comparison to dependent intersection types dependent record types constitute a strictly more specialized type theoretic concept br br br Intersection of a type family br An intersection of a type family denoted br br br br br br br x br br br br br br br br textstyle bigcap x sigma tau br br is a dependent type in which the type br br br br br br br displaystyle tau br br may depend on the term variable br br br br x br br br displaystyle x br br In particular if a term br br br br M br br br displaystyle M br br has the type br br br br br br br x br br br br br br br br textstyle bigcap x sigma tau br br then for each term br br br br N br br br displaystyle N br br of type br br br br br br br displaystyle sigma br br the term br br br br M br br br displaystyle M br br has the type br br br br br br x br br N br br br br displaystyle tau x N br br This notion is also called implicit Pi type observing that the argument br br br br N br br br displaystyle N br br is not kept at term level br br br Comparison of languages with intersection types br br br 