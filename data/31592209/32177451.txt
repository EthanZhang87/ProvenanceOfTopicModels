title: Function (computer programming)
id: 32177451
In computer programming a function procedure method subroutine routine or subprogram is a callable unit of software logic that has a well defined interface and behavior and can be invoked multiple times br Callable units provide a powerful programming tool The primary purpose is to allow for the decomposition of a large and or complicated problem into chunks that have relatively low cognitive load and to assign the chunks meaningful names unless they are anonymous Judicious application can reduce the cost of developing and maintaining software while increasing its quality and reliability br Callable units are present at multiple levels of abstraction in the programming environment For example a programmer may write a function in source code that is compiled to machine code that implements similar semantics There is a callable unit in the source code and an associated one in the machine code but they are different kinds of callable units with different implications and features br br The meaning of each callable term function procedure method is in fact different They are not synonymous Nevertheless they each add a capability to programming that has commonality br The term used tends to reflect the context in which it is used usually based on the language being used For example br br Subprogram routine and subroutine were more commonly used in the past but are less common today br Routine and subroutine have essentially the same meaning but describe a hierarchical relationship much like how a subdirectory is structurally subordinate to its parent directory program and subprogram are similarly related br Some consider function to imply a mathematical function having no side effects but in many contexts function refers to any callable br In the context of Visual Basic and Ada Sub short for subroutine or subprocedure is the name of a callable that does not return a value whereas a Function does return a value br Object oriented languages such as C and Java use the term method to refer to a member function of an object br br The idea of a callable unit was initially conceived by John Mauchly and Kathleen Antonelli during their work on ENIAC and recorded in a January Harvard symposium on Preparation of Problems for EDVAC type Machines Maurice Wilkes David Wheeler and Stanley Gill are generally credited with the formal invention of this concept which they termed a closed sub routine contrasted with an open subroutine or macro However Alan Turing had discussed subroutines in a paper of on design proposals for the NPL ACE going so far as to invent the concept of a return address stack br The idea of a subroutine was worked out after computing machines had already existed for some time The arithmetic and conditional jump instructions were planned ahead of time and have changed relatively little but the special instructions used for procedure calls have changed greatly over the years The earliest computers and microprocessors such as the Manchester Baby and the RCA did not have a single subroutine call instruction Subroutines could be implemented but they required programmers to use the call sequence a series of instructions at each call site br Subroutines were implemented in Konrad Zuse s Z in br In Alan M Turing used the terms bury and unbury as a means of calling and returning from subroutines br In January John Mauchly presented general notes at A Symposium of Large Scale Digital Calculating Machinery br under the joint sponsorship of Harvard University and the Bureau of Ordnance United States Navy Here he discusses serial and parallel operation suggesting br br the structure of the machine need not be complicated one bit It is possible since all the logical characteristics essential to this procedure are available to evolve a coding instruction for placing the subroutines in the memory at places known to the machine and in such a way that they may easily be called into use In other words one can designate subroutine A as division and subroutine B as complex multiplication and subroutine C as the evaluation of a standard error of a sequence of numbers and so on through the list of subroutines needed for a particular problem All these subroutines will then be stored in the machine and all one needs to do is make a brief reference to them by number as they are indicated in the coding br Kay McNulty had worked closely with John Mauchly on the ENIAC team and developed an idea for subroutines for the ENIAC computer she was programming during World War II She and the other ENIAC programmers used the subroutines to help calculate missile trajectories br Goldstine and von Neumann wrote a paper dated August discussing the use of subroutines br Some very early computers and microprocessors such as the IBM the Intel and Intel and the PIC microcontrollers have a single instruction subroutine call that uses a dedicated hardware stack to store return addresses such hardware supports only a few levels of subroutine nesting but can support recursive subroutines Machines before the mid s such as the UNIVAC I the PDP and the IBM typically use a calling convention which saved the instruction counter in the first memory location of the called subroutine This allows arbitrarily deep levels of subroutine nesting but does not support recursive subroutines The IBM System had a subroutine call instruction that placed the saved instruction counter value into a general purpose register this can be used to support arbitrarily deep subroutine nesting and recursive subroutines The Burroughs B is one of the first computers to store subroutine return data on a stack br The DEC PDP is one of the first accumulator based machines to have a subroutine call instruction that saved the return address in a stack addressed by an accumulator or index register The later PDP PDP and VAX lines followed suit this feature also supports both arbitrarily deep subroutine nesting and recursive subroutines br br In the very early assemblers subroutine support was limited Subroutines were not explicitly separated from each other or from the main program and indeed the source code of a subroutine could be interspersed with that of other subprograms Some assemblers would offer predefined macros to generate the call and return sequences By the s assemblers usually had much more sophisticated support for both inline and separately assembled subroutines that could be linked together br One of the first programming languages to support user written subroutines and functions was FORTRAN II The IBM FORTRAN II compiler was released in ALGOL and other early programming languages also supported procedural programming br br Even with this cumbersome approach subroutines proved very useful They allowed the use of the same code in many different programs Memory was a very scarce resource on early computers and subroutines allowed significant savings in the size of programs br Many early computers loaded the program instructions into memory from a punched paper tape Each subroutine could then be provided by a separate piece of tape loaded or spliced before or after the main program or mainline and the same subroutine tape could then be used by many different programs A similar approach was used in computers that loaded program instructions from punched cards The name subroutine library originally meant a library in the literal sense which kept indexed collections of tapes or decks of cards for collective use br br To remove the need for self modifying code computer designers eventually provided an indirect jump instruction whose operand instead of being the return address itself was the location of a variable or processor register containing the return address br On those computers instead of modifying the function s return jump the calling program would store the return address in a variable so that when the function completed it would execute an indirect jump that would direct execution to the location given by the predefined variable br br Another advance was the jump to subroutine instruction which combined the saving of the return address with the calling jump thereby minimizing overhead significantly br In the IBM System for example the branch instructions BAL or BALR designed for procedure calling would save the return address in a processor register specified in the instruction by convention register To return the subroutine had only to execute an indirect branch instruction BR through that register If the subroutine needed that register for some other purpose such as calling another subroutine it would save the register s contents to a private memory location or a register stack br In systems such as the HP the JSB instruction would perform a similar task except that the return address was stored in the memory location that was the target of the branch Execution of the procedure would actually begin at the next memory location In the HP assembly language one would write for example br br to call a subroutine called MYSUB from the main program The subroutine would be coded as br br The JSB instruction placed the address of the NEXT instruction namely BB into the location specified as its operand namely MYSUB and then branched to the NEXT location after that namely AA MYSUB The subroutine could then return to the main program by executing the indirect jump JMP MYSUB I which branched to the location stored at location MYSUB br Compilers for Fortran and other languages could easily make use of these instructions when available This approach supported multiple levels of calls however since the return address parameters and return values of a subroutine were assigned fixed memory locations it did not allow for recursive calls br Incidentally a similar method was used by Lotus in the early s to discover the recalculation dependencies in a spreadsheet Namely a location was reserved in each cell to store the return address Since circular references are not allowed for natural recalculation order this allows a tree walk without reserving space for a stack in memory which was very limited on small computers such as the IBM PC br br Most modern implementations of a function call use a call stack a special case of the stack data structure to implement function calls and returns Each procedure call creates a new entry called a stack frame at the top of the stack when the procedure returns its stack frame is deleted from the stack and its space may be used for other procedure calls Each stack frame contains the private data of the corresponding call which typically includes the procedure s parameters and internal variables and the return address br The call sequence can be implemented by a sequence of ordinary instructions an approach still used in reduced instruction set computing RISC and very long instruction word VLIW architectures but many traditional machines designed since the late s have included special instructions for that purpose br The call stack is usually implemented as a contiguous area of memory It is an arbitrary design choice whether the bottom of the stack is the lowest or highest address within this area so that the stack may grow forwards or backwards in memory however many architectures chose the latter br Some designs notably some Forth implementations used two separate stacks one mainly for control information like return addresses and loop counters and the other for data The former was or worked like a call stack and was only indirectly accessible to the programmer through other language constructs while the latter was more directly accessible br When stack based procedure calls were first introduced an important motivation was to save precious memory With this scheme the compiler does not have to reserve separate space in memory for the private data parameters return address and local variables of each procedure At any moment the stack contains only the private data of the calls that are currently active namely which have been called but haven t returned yet Because of the ways in which programs were usually assembled from libraries it was and still is not uncommon to find programs that include thousands of functions of which only a handful are active at any given moment For such programs the call stack mechanism could save significant amounts of memory Indeed the call stack mechanism can be viewed as the earliest and simplest method for automatic memory management br However another advantage of the call stack method is that it allows recursive function calls since each nested call to the same procedure gets a separate instance of its private data br In a multi threaded environment there is generally more than one stack An environment that fully supports coroutines or lazy evaluation may use data structures other than stacks to store their activation records br br One disadvantage of the call stack mechanism is the increased cost of a procedure call and its matching return The extra cost includes incrementing and decrementing the stack pointer and in some architectures checking for stack overflow and accessing the local variables and parameters by frame relative addresses instead of absolute addresses The cost may be realized in increased execution time or increased processor complexity or both br This overhead is most obvious and objectionable in leaf procedures or leaf functions which return without making any procedure calls themselves To reduce that overhead many modern compilers try to delay the use of a call stack until it is really needed For example the call of a procedure P may store the return address and parameters of the called procedure in certain processor registers and transfer control to the procedure s body by a simple jump If the procedure P returns without making any other call the call stack is not used at all If P needs to call another procedure Q it will then use the call stack to save the contents of any registers such as the return address that will be needed after Q returns br br In general a callable unit is a list of instructions that starting at the first instruction executes sequentially except as directed via its internal logic It can be invoked called many times during the execution of a program Execution continues at the next instruction after the call instruction when it returns control br br The features of implementations of callable units evolved over time and varies by context br This section describes features of the various common implementations br br Most modern programming languages provide features to define and call functions including syntax for accessing such features including br br Delimit the implementation of a function from the rest of the program br Assign an identifier name to a function br Define formal parameters with a name and data type for each br Assign a data type to the return value if any br Specify a return value in the function body br Call a function br Provide actual parameters that correspond to a called function s formal parameters br Return control to the caller at the point of call br Consume the return value in the caller br Dispose of the values returned by a call br Provide a private naming scope for variables br Identify variables outside the function that are accessible within it br Propagate a exceptional condition out of a function and to handle it in the calling context br Package functions into a container such as module library object or class br br Some languages such as Pascal Fortran Ada and many dialects of BASIC use a different name for a callable unit that returns a value function or subprogram vs one that does not subroutine or procedure br Other languages such as C C C and Lisp use only one name for a callable unit function The C family languages use the keyword void to indicate no return value br br If declared to return a value a call can be embedded in an expression in order to consume the return value For example a square root callable unit might be called like y sqrt x br A callable unit that does not return a value is called as a stand alone statement like print hello This syntax can also be used for a callable unit that returns a value but the return value will be ignored br Some older languages require a keyword for calls that do not consume a return value like CALL print hello br br Most implementations especially in modern languages support parameters which the callable declares as formal parameters A caller passes actual parameters a k a arguments to match Different programming languages provide different conventions for passing arguments br br In some languages such as BASIC a callable has different syntax i e keyword for a callable that returns a value vs one that does not br In other languages the syntax is the same regardless br In some of these languages an extra keyword is used to declare no return value for example void in C C and C br In some languages such as Python the difference is whether the body contains a return statement with a value and a particular callable may return with or without a value based on control flow br br In many contexts a callable may have side effect behavior such as modifying passed or global data reading from or writing to a peripheral device accessing a file halting the program or the machine or temporarily pausing program execution br Side effects are considered undesireble by Robert C Martin who is known for promoting design principles Martin argues that side effects can result in temporal coupling or order dependencies br In strictly functional programming languages such as Haskell a function can have no side effects which means it cannot change the state of the program Functions always return the same result for the same input Such languages typically only support functions that return a value since there is no value in a function that has neither return value nor side effect br br br Most contexts support local variables memory owned by a callable to hold intermediate values These variables are typically stored in the call s activation record on the call stack along with other information such as the return address br br If supported by the language a callable may call itself causing its execution to suspend while another nested execution of the same callable executes Recursion is a useful means to simplify some complex algorithms and break down complex problems Recursive languages provide a new copy of local variables on each call If the programmer desires the recursive callable to use the same variables instead of using locals they typically declare them in a shared context such static or global br Languages going back to ALGOL PL I and C and modern languages almost invariably use a call stack usually supported by the instruction sets to provide an activation record for each call That way a nested call can modify its local variables without effecting any of the suspended calls variables br Recursion allows direct implementation of functionality defined by mathematical induction and recursive divide and conquer algorithms Here is an example of a recursive function in C C to find Fibonacci numbers br br Early languages like Fortran did not initially support recursion because only one set of variables and return address were allocated for each callable Early computer instruction sets made storing return addresses and variables on a stack difficult Machines with index registers or general purpose registers e g CDC series PDP GE System UNIVAC series could use one of those registers as a stack pointer br br Some languages e g Ada Pascal PL I Python support declaring and defining a function inside e g a function body such that the name of the inner is only visible within the body of the outer br br If a callable can be executed properly even when another execution of the same callable is already in progress that callable is said to be reentrant A reentrant callable is also useful in multi threaded situations since multiple threads can call the same callable without fear of interfering with each other In the IBM CICS transaction processing system quasi reentrant was a slightly less restrictive but similar requirement for application programs that were shared by many threads br br Some languages support overloading allow multiple callables with the same name in the same scope but operating on different types of input Consider the square root function applied to real number complex number and matrix input The algorithm for each type of input is different and the return value may have a different type By writing three separate callables with the same name i e sqrt the resulting code may be easier to write and to maintain since each one has a name that is relatively easy to understand and to remember instead of giving longer and more complicated names like sqrt real sqrt complex qrt matrix br Overloading is supported in many languages that support strong typing Often the compiler selects the overload to call based on the type of the input arguments or it fails if the input arguments do not select an overload Older and weakly typed languages generally do not support overloading br Here is an example of overloading in C two functions Area that accept different types br br PL I has the GENERIC attribute to define a generic name for a set of entry references called with different types of arguments Example br br DECLARE gen name GENERIC br name WHEN FIXED BINARY br flame WHEN FLOAT br pathname OTHERWISE br Multiple argument definitions may be specified for each entry A call to gen name will result in a call to name when the argument is FIXED BINARY flame when FLOAT etc If the argument matches none of the choices pathname will be called br br A closure is a callable plus values of some of its variables captured from the environment in which it was created Closures were a notable feature of the Lisp programming language introduced by John McCarthy Depending on the implementation closures can serve as a mechanism for side effects br br Besides its happy path behavior a callable may need to inform the caller about an exceptional condition that occurred during its execution br Most modern languages support exceptions which allows for exceptional control flow that pops the call stack until an exception handler is found to handle the condition br Languages that do not support exceptions can use the return value to indicate success or failure of a call Another approach is to use a well known location like a global variable for success indication A callable writes the value and the caller reads it after a call br In the IBM System where return code was expected from a subroutine the return value was often designed to be a multiple of so that it could be used as a direct branch table index into a branch table often located immediately after the call instruction to avoid extra conditional tests further improving efficiency In the System assembly language one would write for example br br A call has runtime overhead which may include but is not limited to br br Allocating and reclaiming call stack storage br Saving and restoring processor registers br Copying input variables br Copying values after the call into the caller s context br Automatic testing of the return code br Handling of exceptions br Dispatching such as for a virtual method in an object oriented language br Various techniques are employed to minimize the runtime cost of calls br br Some optimizations for minimizing call overhead may seem straight forward but cannot be used if the callable has side effects For example in the expression f x f x the function f cannot be called only once with its value used two times since the two calls may return different results Moreover in the few languages which define the order of evaluation of the division operator s operands the value of x must be fetched again before the second call since the first call may have changed it Determining whether a callable has a side effect is difficult indeed undecidable by virtue of Rice s theorem So while this optimization is safe in a purely functional programming language a compiler for an language not limited to functional typically assumes the worst case that every callable may have side effects br br Inlining eliminates calls for particular callables The compiler replaces each call with the compiled code of the callable Not only does this avoid the call overhead but it also allows the compiler to optimize code of the caller more effectively by taking into account the context and arguments at that call Inlining however usually increases the compiled code size except when only called once or the body is very short like one line br br Callables can be defined within a program or separately in a library that can be used by multiple programs br br A compiler translates call and return statements into machine instructions according to a well defined calling convention For code compiled by the same or a compatible compiler functions can be compiled separately from the programs that call them The instruction sequences corresponding to call and return statements are called the procedure s prologue and epilogue br br A built in function or builtin function or intrinsic function is a function for which the compiler generates code at compile time or provides in a way other than for other functions A built in function does not need to be defined like other functions since it is built in to the programming language br br Advantages of breaking a program into functions include br br Decomposing a complex programming task into simpler steps this is one of the two main tools of structured programming along with data structures br Reducing duplicate code within a program br Enabling reuse of code across multiple programs br Dividing a large programming task among various programmers or various stages of a project br Hiding implementation details from users of the function br Improving readability of code by replacing a block of code with a function call where a descriptive function name serves to describe the block of code This makes the calling code concise and readable even if the function is not meant to be reused br Improving traceability i e most languages offer ways to obtain the call trace which includes the names of the involved functions and perhaps even more information such as file names and line numbers by not decomposing the code into functions debugging would be severely impaired br br Compared to using in line code invoking a function imposes some computational overhead in the call mechanism br A function typically requires standard housekeeping code both at the entry to and exit from the function function prologue and epilogue usually saving general purpose registers and return address as a minimum br br Many programming conventions have been developed regarding callables br With respect to naming many developers name a callable with a phrase starting with a verb when it does a certain task with an adjective when it makes an inquiry and with a noun when it is used to substitute variables br Some programmers suggest that a callable should perform exactly one task and if it performs more than one task it should be split up into multiple callables They argue that callables are key components in software maintenance and their roles in the program must remain distinct br Proponents of modular programming advocate that each callable should have minimal dependency on the rest of the codebase For example the use of global variables is generally deemed unwise because it adds coupling between all callables that use the global variables If such coupling is not necessary they advise to refactor callables to accept passed parameters instead br br Early BASIC variants require each line to have a unique number line number that orders the lines for execution provides no separation of the code that is callable no mechanism for passing arguments or to return a value and all variables are global It provides the command GOSUB where sub is short for sub procedure subprocedure or subroutine Control jumps to the specified line number and then continues on the next line on return br br This code repeatedly asks the user to enter a number and reports the square root of the value Lines are the callable br br In Microsoft Small Basic targeted to the student first learning how to program in a text based language a callable unit is called a subroutine br The Sub keyword denotes the start of a subroutine and is followed by a name identifier Subsequent lines are the body which ends with the EndSub keyword br br This can be called as SayHello br br In later versions of Visual Basic VB including the latest product line and VB the term procedure is used for the callable unit concept The keyword Sub is used to return no value and Function to return a value When used in the context of a class a procedure is a method br br Each parameter has a data type that can be specified but if not defaults to Object for later versions based on NET and variant for VB br VB supports parameter passing conventions by value and by reference via the keywords ByVal and ByRef respectively br Unless ByRef is specified an argument is passed ByVal Therefore ByVal is rarely explicitly specified br For a simple type like a number these conventions are relatively clear Passing ByRef allows the procedure to modify the passed variable whereas passing ByVal does not For an object semantics can confuse programmers since an object is always treated as a reference Passing an object ByVal copies the reference not the state of the object The called procedure can modify the state of the object via its methods yet cannot modify the object reference of the actual parameter br br The does not return a value and has to be called stand alone like DoSomething br br This returns the value and a call can be part of an expression like y x GiveMeFive br br This has a side effect modifies the variable passed by reference and could be called for variable v like AddTwo v Giving v is before the call it will be after br br In C and C a callable unit is called a function br A function definition starts with the name of the type of value that it returns or void to indicate that it does not return a value This is followed by the function name formal arguments in parentheses and body lines in braces br In C a function declared in a class as non static is called a member function or method A function outside of a class can be called a free function to distinguish it from a member function br br This function does not return a value and is always called stand alone like doSomething br br This function returns the integer value The call can be stand alone or in an expression like y x giveMeFive br br This function has a side effect modifies the value passed by address to the input value plus It could be called for variable v as addTwo v where the ampersand tells the compiler to pass the address of a variable Giving v is before the call it will be after br br This function requires C would not compile as C It has the same behavior as the preceding example but passes the actual parameter by reference rather than passing its address A call such as addTwo v does not include an ampersand since the compiler handles passing by reference without syntax in the call br br In PL I a called procedure may be passed a descriptor providing information about the argument such as string lengths and array bounds This allows the procedure to be more general and eliminates the need for the programmer to pass such information By default PL I passes arguments by reference A trivial function to change the sign of each element of a two dimensional array might look like br br change sign procedure array br declare array float br array array br end change sign br br This could be called with various arrays as follows br br first array bounds from to and to br declare array float br second array bounds from to and to br declare array float br call change sign array br call change sign array br br In Python the keyword def denotes the start of a function definition The statements of the function body follow as indented on subsequent lines and end at the line that is indented the same as the first line or end of file br br The first function returns greeting text that includes the name passed by the caller The second function calls the first and is called like greet martin to write Welcome Martin to the console br br In the procedural interpretation of logic programs logical implications behave as goal reduction procedures A rule or clause of the form br br A B br which has the logical reading br br A if B br behaves as a procedure that reduces goals that unify with A to subgoals that are instances ofB br Consider for example the Prolog program br br Notice that the motherhood function X mother Y is represented by a relation as in a relational database However relations in Prolog function as callable units br For example the procedure call parent child X charles produces the output X elizabeth But the same procedure can be called with other input output patterns For example br br Asynchronous procedure call a subprogram that is called after its parameters are set by other activities br Command query separation CQS br Compound operation br Coroutines subprograms that call each other as if both were the main programs br Evaluation strategy br Event handler a subprogram that is called in response to an input event or interrupt br Function mathematics br Functional programming br Fused operation br Intrinsic function br Lambda function computer programming a function that is not bound to an identifier br Logic programming br Method computer programming br Modular programming br Operator overloading br Protected procedure br Transclusion