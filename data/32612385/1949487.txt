title: Dependent type
id: 1949487
In computer science and logic a dependent type is a type whose definition depends on a value It is an overlapping feature of type theory and type systems In intuitionistic type theory dependent types are used to encode logic s quantifiers like for all and there exists In functional programming languages like Agda ATS Coq F Epigram Idris and Lean dependent types help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations br Two common examples of dependent types are dependent functions and dependent pairs The return type of a dependent function may depend on the value not just type of one of its arguments For instance a function that takes a positive integer br br br br n br br br displaystyle n br br may return an array of length br br br br n br br br displaystyle n br br where the array length is part of the type of the array Note that this is different from polymorphism and generic programming both of which include the type as an argument A dependent pair may have a second value the type of which depends on the first value Sticking with the array example a dependent pair may be used to pair an array with its length in a type safe way br Dependent types add complexity to a type system Deciding the equality of dependent types in a program may require computations If arbitrary values are allowed in dependent types then deciding type equality may involve deciding whether two arbitrary programs produce the same result hence the decidability of type checking may depend on the given type theory s semantics of equality that is whether the type theory is intensional or extensional br br br History br In Haskell Curry noticed that the types used in typed lambda calculus and in its combinatory logic counterpart followed the same pattern as axioms in propositional logic Going further for every proof in the logic there was a matching function term in the programming language One of Curry s examples was the correspondence between simply typed lambda calculus and intuitionistic logic br Predicate logic is an extension of propositional logic adding quantifiers Howard and de Bruijn extended lambda calculus to match this more powerful logic by creating types for dependent functions which correspond to for all and dependent pairs which correspond to there exists br Because of this and other work by Howard propositions as types is known as the Curry Howard correspondence br br br Formal definition br Loosely speaking dependent types are similar to the type of an indexed family of sets More formally given a type br br br br A br br br br U br br br br br displaystyle A mathcal U br br in a universe of types br br br br br br U br br br br br displaystyle mathcal U br br one may have a family of types br br br br B br br A br br br br U br br br br br displaystyle B A to mathcal U br br which assigns to each term br br br br a br br A br br br displaystyle a A br br a type br br br br B br br a br br br br br U br br br br br displaystyle B a mathcal U br br We say that the type B a varies with a br br br type br A function whose type of return value varies with its argument i e there is no fixed codomain is a dependent function and the type of this function is called dependent product type pi type type or dependent function type From a family of types br br br br B br br A br br br br U br br br br br displaystyle B A to mathcal U br br we may construct the type of dependent functions br br br br br br br x br br A br br br B br br x br br br br textstyle prod x A B x br br whose terms are functions that take a term br br br br a br br A br br br displaystyle a A br br and return a term in br br br br B br br a br br br br displaystyle B a br br For this example the dependent function type is typically written as br br br br br br br x br br A br br br B br br x br br br br textstyle prod x A B x br br or br br br br br br br x br br A br br br B br br x br br br br textstyle prod x A B x br br br If br br br br B br br A br br br br U br br br br br displaystyle B A to mathcal U br br is a constant function the corresponding dependent product type is equivalent to an ordinary function type That is br br br br br br br x br br A br br br B br br br textstyle prod x A B br br is judgmentally equal to br br br br A br br B br br br displaystyle A to B br br when B does not depend on x br The name type comes from the idea that these may be viewed as a Cartesian product of types types can also be understood as models of universal quantifiers br For example if we write br br br br Vec br br br br R br br br n br br br br displaystyle operatorname Vec mathbb R n br br for n tuples of real numbers then br br br br br br br n br br br N br br br br Vec br br br br R br br br n br br br br textstyle prod n mathbb N operatorname Vec mathbb R n br br would be the type of a function which given a natural number n returns a tuple of real numbers of size n The usual function space arises as a special case when the range type does not actually depend on the input E g br br br br br br br n br br br N br br br br br br R br br br br br textstyle prod n mathbb N mathbb R br br is the type of functions from natural numbers to the real numbers which is written as br br br br br N br br br br R br br br br displaystyle mathbb N to mathbb R br br in typed lambda calculus br For a more concrete example taking A to be the type of unsigned integers from to the ones that fit into bits or byte and B a Xa for a A then br br br br br br br x br br A br br br B br br x br br br br textstyle prod x A B x br br devolves into the product of X X X X X X br br br type br br The dual of the dependent product type is the dependent pair type dependent sum type sigma type or confusingly dependent product type Sigma types can also be understood as existential quantifiers Continuing the above example if in the universe of types br br br br br br U br br br br br displaystyle mathcal U br br there is a type br br br br A br br br br U br br br br br displaystyle A mathcal U br br and a family of types br br br br B br br A br br br br U br br br br br displaystyle B A to mathcal U br br then there is a dependent pair type br br br br br br br x br br A br br br B br br x br br br br textstyle sum x A B x br br The alternative notations are similar to that of types br The dependent pair type captures the idea of an ordered pair where the type of the second term is dependent on the value of the first If br br br br br a br br b br br br br br br x br br A br br br B br br x br br br br br textstyle a b sum x A B x br br then br br br br a br br A br br br displaystyle a A br br and br br br br b br br B br br a br br br br displaystyle b B a br br If B is a constant function then the dependent pair type becomes is judgementally equal to the product type that is an ordinary Cartesian product br br br br A br br B br br br displaystyle A times B br br br For a more concrete example taking A to again be type of unsigned integers from to and B a to again be equal to Xa for more arbitrary Xa then br br br br br br br x br br A br br br B br br x br br br br textstyle sum x A B x br br devolves into the sum X X X X X X br br br Example as existential quantification br Let br br br br A br br br br U br br br br br displaystyle A mathcal U br br be some type and let br br br br B br br A br br br br U br br br br br displaystyle B A to mathcal U br br By the Curry Howard correspondence B can be interpreted as a logical predicate on terms of A For a given br br br br a br br A br br br displaystyle a A br br whether the type B a is inhabited indicates whether a satisfies this predicate The correspondence can be extended to existential quantification and dependent pairs the proposition br br br br br br a br br br br br A br br B br br a br br br br displaystyle exists a in A B a br br is true if and only if the type br br br br br br br a br br A br br br B br br a br br br br textstyle sum a A B a br br is inhabited br For example br br br br m br br br N br br br br displaystyle m mathbb N br br is less than or equal to br br br br n br br br N br br br br displaystyle n mathbb N br br if and only if there exists another natural number br br br br k br br br N br br br br displaystyle k mathbb N br br such that m k n In logic this statement is codified by existential quantification br br br br br m br br n br br br br br br k br br br br br br N br br br m br br k br br n br br br br displaystyle m leq n iff exists k in mathbb N m k n br br br This proposition corresponds to the dependent pair type br br br br br br br br k br br br N br br br br m br br k br br n br br br br displaystyle sum k mathbb N m k n br br br That is a proof of the statement that m is less than or equal to n is a pair that contains both a non negative number k which is the difference between m and n and a proof of the equality m k n br br br Systems of the lambda cube br Henk Barendregt developed the lambda cube as a means of classifying type systems along three axes The eight corners of the resulting cube shaped diagram each correspond to a type system with simply typed lambda calculus in the least expressive corner and calculus of constructions in the most expressive The three axes of the cube correspond to three different augmentations of the simply typed lambda calculus the addition of dependent types the addition of polymorphism and the addition of higher kinded type constructors functions from types to types for example The lambda cube is generalized further by pure type systems br br br First order dependent type theory br The system br br br br br br br br displaystyle lambda Pi br br of pure first order dependent types corresponding to the logical framework LF is obtained by generalising the function space type of the simply typed lambda calculus to the dependent product type br br br Second order dependent type theory br The system br br br br br br br br br displaystyle lambda Pi br br of second order dependent types is obtained from br br br br br br br br displaystyle lambda Pi br br by allowing quantification over type constructors In this theory the dependent product operator subsumes both the br br br br br br br displaystyle to br br operator of simply typed lambda calculus and the br br br br br br br displaystyle forall br br binder of System F br br br Higher order dependently typed polymorphic lambda calculus br The higher order system br br br br br br br br br displaystyle lambda Pi omega br br extends br br br br br br br br br displaystyle lambda Pi br br to all four forms of abstraction from the lambda cube functions from terms to terms types to types terms to types and types to terms The system corresponds to the calculus of constructions whose derivative the calculus of inductive constructions is the underlying system of the Coq proof assistant br br br Simultaneous programming language and logic br The Curry Howard correspondence implies that types can be constructed that express arbitrarily complex mathematical properties If the user can supply a constructive proof that a type is inhabited i e that a value of that type exists then a compiler can check the proof and convert it into executable computer code that computes the value by carrying out the construction The proof checking feature makes dependently typed languages closely related to proof assistants The code generation aspect provides a powerful approach to formal program verification and proof carrying code since the code is derived directly from a mechanically verified mathematical proof br br br Comparison of languages with dependent types br br br See also br Typed lambda calculus br Intuitionistic type theory br br br br br br Further reading br br br External links br Dependently Typed Programming br Dependently Typed Programming br Dependently Typed Programming br Dependent type at the Haskell Wiki br dependent type theory at the nLab br dependent type at the nLab br dependent product type at the nLab br dependent sum type at the nLab br dependent product at the nLab br dependent sum at the nLab