title: Lambda calculus
id: 18203
Lambda calculus also written as calculus is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution Untyped lambda calculus the topic of this article is a universal model of computation that can be used to simulate any Turing machine and vice versa It was introduced by the mathematician Alonzo Church in the s as part of his research into the foundations of mathematics In Church found a formulation which was logically consistent and documented it in br Lambda calculus consists of constructing lambda terms and performing reduction operations on them In the simplest form of lambda calculus terms are built using only the following rules br br br br br x br br br textstyle x br br A variable is a character or string representing a parameter br br br br br br br x br br M br br br br textstyle lambda x M br br A lambda abstraction is a function definition taking as input the bound variable br br br br x br br br displaystyle x br br between the and the punctum dot and returning the body br br br br M br br br textstyle M br br br br br br br br M br br N br br br br textstyle M N br br An application applying a function br br br br M br br br textstyle M br br to an argument br br br br N br br br textstyle N br br Both br br br br M br br br textstyle M br br and br br br br N br br br textstyle N br br are lambda terms br The reduction operations include br br br br br br br x br br M br br x br br br br br br y br br M br br y br br br br br textstyle lambda x M x rightarrow lambda y M y br br conversion renaming the bound variables in the expression Used to avoid name collisions br br br br br br br br x br br M br br br N br br br br M br br x br br N br br br br br textstyle lambda x M N rightarrow M x N br br reduction replacing the bound variables with the argument expression in the body of the abstraction br If De Bruijn indexing is used then conversion is no longer required as there will be no name collisions If repeated application of the reduction steps eventually terminates then by the Church Rosser theorem it will produce a normal form br Variable names are not needed if using a universal lambda function such as Iota and Jot which can create any function behavior by calling it on itself in various combinations br br br Explanation and applications br Lambda calculus is Turing complete that is it is a universal model of computation that can be used to simulate any Turing machine Its namesake the Greek letter lambda is used in lambda expressions and lambda terms to denote binding a variable in a function br Lambda calculus may be untyped or typed In typed lambda calculus functions can be applied only if they are capable of accepting the given input s type of data Typed lambda calculi are weaker than the untyped lambda calculus which is the primary subject of this article in the sense that typed lambda calculi can express less than the untyped calculus can On the other hand typed lambda calculi allow more things to be proven For example in the simply typed lambda calculus it is a theorem that every evaluation strategy terminates for every simply typed lambda term whereas evaluation of untyped lambda terms need not terminate see below One reason there are many different typed lambda calculi has been the desire to do more of what the untyped calculus can do without giving up on being able to prove strong theorems about the calculus br Lambda calculus has applications in many different areas in mathematics philosophy linguistics and computer science br Lambda calculus has played an important role in the development of the theory of programming languages Functional programming languages implement lambda calculus Lambda calculus is also a current research topic in category theory br br br History br Lambda calculus was introduced by mathematician Alonzo Church in the s as part of an investigation into the foundations of mathematics The original system was shown to be logically inconsistent in when Stephen Kleene and J B Rosser developed the Kleene Rosser paradox br Subsequently in Church isolated and published just the portion relevant to computation what is now called the untyped lambda calculus In he also introduced a computationally weaker but logically consistent system known as the simply typed lambda calculus br Until the s when its relation to programming languages was clarified the lambda calculus was only a formalism Thanks to Richard Montague and other linguists applications in the semantics of natural language the lambda calculus has begun to enjoy a respectable place in both linguistics and computer science br br br Origin of the symbol br br There is some uncertainty over the reason for Church s use of the Greek letter lambda as the notation for function abstraction in the lambda calculus perhaps in part due to conflicting explanations by Church himself According to Cardone and Hindley br br By the way why did Church choose the notation In an unpublished letter to Harald Dickson he stated clearly that it came from the notation br br br br br br br x br br br br br br br displaystyle hat x br br used for class abstraction by Whitehead and Russell by first modifying br br br br br br br x br br br br br br br displaystyle hat x br br to br br br br br x br br br displaystyle land x br br to distinguish function abstraction from class abstraction and then changing br br br br br br br displaystyle land br br to for ease of printing br This origin was also reported in Rosser p On the other hand in his later years Church told two enquirers that the choice was more accidental a symbol was needed and just happened to be chosen br br Dana Scott has also addressed this question in various public lectures br Scott recounts that he once posed a question about the origin of the lambda symbol to Church s former student and son in law John W Addison Jr who then wrote his father in law a postcard br br Dear Professor Church br Russell had the iota operator Hilbert had the epsilon operator Why did you choose lambda for your operator br br According to Scott Church s entire response consisted of returning the postcard with the following annotation eeny meeny miny moe br br br Informal description br br br Motivation br Computable functions are a fundamental concept within computer science and mathematics The lambda calculus provides simple semantics for computation which are useful for formally studying properties of computation The lambda calculus incorporates two simplifications that make its semantics simple br The first simplification is that the lambda calculus treats functions anonymously it does not give them explicit names For example the function br br br br br br s br q br u br a br r br e br br s br u br m br br br br x br br y br br br br x br br br br br br br y br br br br br br br displaystyle operatorname square sum x y x y br br br can be rewritten in anonymous form as br br br br br br x br br y br br br br x br br br br br br br y br br br br br br br displaystyle x y mapsto x y br br br which is read as a tuple of x and y is mapped to br br br br br x br br br br br br br y br br br br br br br textstyle x y br br Similarly the function br br br br br id br br br x br br br x br br br displaystyle operatorname id x x br br br can be rewritten in anonymous form as br br br br br x br br x br br br displaystyle x mapsto x br br br where the input is simply mapped to itself br The second simplification is that the lambda calculus only uses functions of a single input An ordinary function that requires two inputs for instance the br br br br br s br q br u br a br r br e br br s br u br m br br br br textstyle operatorname square sum br br function can be reworked into an equivalent function that accepts a single input and as output returns another function that in turn accepts a single input For example br br br br br br x br br y br br br br x br br br br br br br y br br br br br br br displaystyle x y mapsto x y br br br can be reworked into br br br br br x br br br y br br br x br br br br br br br y br br br br br br br br displaystyle x mapsto y mapsto x y br br br This method known as currying transforms a function that takes multiple arguments into a chain of functions each with a single argument br Function application of the br br br br br s br q br u br a br r br e br br s br u br m br br br br textstyle operatorname square sum br br function to the arguments yields at once br br br br br br br x br br y br br br br x br br br br br br br y br br br br br br br br br br br br br textstyle x y mapsto x y br br br br br br br br br br br br br br br br br br br br br br textstyle br br br br br br br br br br textstyle br br br whereas evaluation of the curried version requires one more step br br br br br br br br br br br br br br br x br br br y br br br x br br br br br br br y br br br br br br br br br br br br br br br br br br br br br br br br textstyle Bigl bigl x mapsto y mapsto x y bigr Bigr br br br br br br br br y br br br br br br br br br br y br br br br br br br br br br br textstyle y mapsto y br br the definition of br br br br x br br br displaystyle x br br has been used with br br br br br br br displaystyle br br in the inner expression This is like reduction br br br br br br br br br br br br br br br br br br br br br textstyle br br the definition of br br br br y br br br displaystyle y br br has been used with br br br br br br br displaystyle br br Again similar to reduction br br br br br br br br br textstyle br br br to arrive at the same result br br br The lambda calculus br The lambda calculus consists of a language of lambda terms that are defined by a certain formal syntax and a set of transformation rules for manipulating the lambda terms These transformation rules can be viewed as an equational theory or as an operational definition br As described above having no names all functions in the lambda calculus are anonymous functions They only accept one input variable so currying is used to implement functions of several variables br br br Lambda terms br The syntax of the lambda calculus defines some expressions as valid lambda calculus expressions and some as invalid just as some strings of characters are valid C programs and some are not A valid lambda calculus expression is called a lambda term br The following three rules give an inductive definition that can be applied to build all syntactically valid lambda terms br br variable x is itself a valid lambda term br if t is a lambda term and x is a variable then br br br br br br x br br t br br br br displaystyle lambda x t br br is a lambda term called an abstraction br if t and s are lambda terms then br br br br br t br br br displaystyle t br br br br br br s br br br br displaystyle s br br is a lambda term called an application br Nothing else is a lambda term That is a lambda term is valid if and only if it can be obtained by repeated application of these three rules For convenience some parentheses can be omitted when writing a lambda term For example the outermost parentheses are usually not written See Notation below for an explicit description of which parentheses are optional It is also common to extend the syntax presented here with additional operations which allows making sense of terms such as br br br br br x br br br x br br br br br br br br displaystyle lambda x x br br The focus of this article is the pure lambda calculus without extensions but lambda terms extended with arithmetic operations are used for explanatory purposes br An abstraction br br br br br x br br t br br br displaystyle lambda x t br br denotes an anonymous function that takes a single input x and returns t For example br br br br br x br br br br x br br br br br br br br br br displaystyle lambda x x br br is an abstraction representing the function br br br br f br br br displaystyle f br br defined by br br br br f br br x br br br br x br br br br br br br br br br displaystyle f x x br br using the term br br br br br x br br br br br br br br br displaystyle x br br for t The name br br br br f br br br displaystyle f br br is superfluous when using abstraction The syntax br br br br br br x br br t br br br br displaystyle lambda x t br br binds the variable x in the term t The definition of a function with an abstraction merely sets up the function but does not invoke it br An application br br br br t br br br displaystyle t br br br br br br s br br br displaystyle s br br represents the application of a function t to an input s that is it represents the act of calling function t on input s to produce br br br br t br br s br br br br displaystyle t s br br br A lambda term may refer to a variable that has not been bound such as the term br br br br br x br br br x br br y br br br br displaystyle lambda x x y br br which represents the function definition br br br br f br br x br br br x br br y br br br displaystyle f x x y br br In this term the variable y has not been defined and is considered an unknown The abstraction br br br br br x br br br x br br y br br br br displaystyle lambda x x y br br is a syntactically valid term and represents a function that adds its input to the yet unknown y br Parentheses may be used and might be needed to disambiguate terms For example br br br br br br x br br br br br x br br x br br x br br br br displaystyle lambda x lambda x x x br br is of form br br br br br x br br B br br br displaystyle lambda x B br br and is therefore an abstraction while br br br br br br br x br br br br x br br x br br br br br displaystyle lambda x lambda x x br br br br br br x br br br displaystyle x br br is of form br br br br M br br br displaystyle M br br br br br br N br br br displaystyle N br br and is therefore an application br The examples and denote different terms differing only in where the parentheses are placed They have different meanings example is a function definition while example is a function application The lambda variable x is a placeholder in both examples br Here example defines a function br br br br br x br br B br br br displaystyle lambda x B br br where br br br br B br br br displaystyle B br br is br br br br br br x br br x br br x br br br displaystyle lambda x x x br br an anonymous function br br br br br br x br br x br br br br displaystyle lambda x x br br with input br br br br x br br br displaystyle x br br while example br br br br M br br br displaystyle M br br br br br br N br br br displaystyle N br br is M applied to N where br br br br M br br br displaystyle M br br is the lambda term br br br br br br x br br br br x br br x br br br br br displaystyle lambda x lambda x x br br being applied to the input br br br br N br br br displaystyle N br br which is br br br br x br br br displaystyle x br br Both examples and would evaluate to the identity function br br br br br x br br x br br br displaystyle lambda x x br br br br br Functions that operate on functions br In lambda calculus functions are taken to be first class values so functions may be used as the inputs or be returned as outputs from other functions br For example the lambda term br br br br br x br br x br br br displaystyle lambda x x br br represents the identity function br br br br x br br x br br br displaystyle x mapsto x br br Further br br br br br x br br y br br br displaystyle lambda x y br br represents the constant function br br br br x br br y br br br displaystyle x mapsto y br br the function that always returns br br br br y br br br displaystyle y br br no matter the input As an example of a function operating on functions the function composition can be defined as br br br br br f br br br g br br br x br br br f br br g br x br br br br br displaystyle lambda f lambda g lambda x f gx br br br There are several notions of equivalence and reduction that allow lambda terms to be reduced to equivalent lambda terms br br br Alpha equivalence br A basic form of equivalence definable on lambda terms is alpha equivalence It captures the intuition that the particular choice of a bound variable in an abstraction does not usually matter br For instance br br br br br x br br x br br br displaystyle lambda x x br br and br br br br br y br br y br br br displaystyle lambda y y br br are alpha equivalent lambda terms and they both represent the same function the identity function br The terms br br br br x br br br displaystyle x br br and br br br br y br br br displaystyle y br br are not alpha equivalent because they are not bound in an abstraction br In many presentations it is usual to identify alpha equivalent lambda terms br The following definitions are necessary in order to be able to define reduction br br br Free variables br The free variables br of a term are those variables not bound by an abstraction The set of free variables of an expression is defined inductively br br The free variables of br br br br x br br br displaystyle x br br are just br br br br x br br br displaystyle x br br br The set of free variables of br br br br br x br br t br br br displaystyle lambda x t br br is the set of free variables of br br br br t br br br displaystyle t br br but with br br br br x br br br displaystyle x br br removed br The set of free variables of br br br br t br br br displaystyle t br br br br br br s br br br displaystyle s br br is the union of the set of free variables of br br br br t br br br displaystyle t br br and the set of free variables of br br br br s br br br displaystyle s br br br For example the lambda term representing the identity br br br br br x br br x br br br displaystyle lambda x x br br has no free variables but the function br br br br br x br br y br br br displaystyle lambda x y br br br br br br x br br br displaystyle x br br has a single free variable br br br br y br br br displaystyle y br br br br br Capture avoiding substitutions br Suppose br br br br t br br br displaystyle t br br br br br br s br br br displaystyle s br br and br br br br r br br br displaystyle r br br are lambda terms and br br br br x br br br displaystyle x br br and br br br br y br br br displaystyle y br br are variables br The notation br br br br t br br x br br r br br br br displaystyle t x r br br indicates substitution of br br br br r br br br displaystyle r br br for br br br br x br br br displaystyle x br br in br br br br t br br br displaystyle t br br in a capture avoiding manner This is defined so that br br br br br x br br x br br r br br br r br br br displaystyle x x r r br br with br br br br r br br br displaystyle r br br substituted for br br br br x br br br displaystyle x br br br br br br x br br br displaystyle x br br becomes br br br br r br br br displaystyle r br br br br br br y br br x br br r br br br y br br br displaystyle y x r y br br if br br br br x br br y br br br displaystyle x neq y br br with br br br br r br br br displaystyle r br br substituted for br br br br x br br br displaystyle x br br br br br br y br br br displaystyle y br br which is not br br br br x br br br displaystyle x br br remains br br br br y br br br displaystyle y br br br br br br br t br br br displaystyle t br br br br br br s br br br x br br r br br br br t br br x br br r br br br br s br br x br br r br br br br br displaystyle s x r t x r s x r br br substitution distributes to both sides of an application br br br br br br br x br br t br br br x br br r br br br br x br br t br br br displaystyle lambda x t x r lambda x t br br a variable bound by an abstraction is not subject to substitution substituting such variable leaves the abstraction unchanged br br br br br br br y br br t br br br x br br r br br br br y br br br t br br x br br r br br br br br displaystyle lambda y t x r lambda y t x r br br if br br br br x br br y br br br displaystyle x neq y br br and br br br br y br br br displaystyle y br br does not appear among the free variables of br br br br r br br br displaystyle r br br br br br br y br br br displaystyle y br br is said to be fresh for br br br br r br br br displaystyle r br br substituting a variable which is not bound by an abstraction proceeds in the abstraction s body provided that the abstracted variable br br br br y br br br displaystyle y br br is fresh for the substitution term br br br br r br br br displaystyle r br br br For example br br br br br br x br br x br br br y br br y br br br br x br br br x br br y br br y br br br br br x br br x br br br displaystyle lambda x x y y lambda x x y y lambda x x br br and br br br br br br br x br br y br br x br br br x br br y br br br br br br x br br y br br br x br br y br br br br x br br x br br y br br br br br br x br br y br br y br br br displaystyle lambda x y x x y lambda x y x y x x y lambda x y y br br br The freshness condition requiring that br br br br y br br br displaystyle y br br is not in the free variables of br br br br r br br br displaystyle r br br is crucial in order to ensure that substitution does not change the meaning of functions br For example a substitution that ignores the freshness condition could lead to errors br br br br br br x br br y br br br y br br x br br br br x br br br y br br y br br x br br br br br x br br x br br br displaystyle lambda x y y x lambda x y y x lambda x x br br This erroneous substitution would turn the constant function br br br br br x br br y br br br displaystyle lambda x y br br into the identity br br br br br x br br x br br br displaystyle lambda x x br br br In general failure to meet the freshness condition can be remedied by alpha renaming first with a suitable fresh variable br For example switching back to our correct notion of substitution in br br br br br br x br br y br br br y br br x br br br br displaystyle lambda x y y x br br the abstraction can be renamed with a fresh variable br br br br z br br br displaystyle z br br to obtain br br br br br br z br br y br br br y br br x br br br br z br br br y br br y br br x br br br br br z br br x br br br displaystyle lambda z y y x lambda z y y x lambda z x br br and the meaning of the function is preserved by substitution br br br reduction br The reduction rule states that an application of the form br br br br br br x br br t br br s br br br displaystyle lambda x t s br br reduces to the term br br br br t br br x br br s br br br br displaystyle t x s br br The notation br br br br br br x br br t br br s br br t br br x br br s br br br br displaystyle lambda x t s to t x s br br is used to indicate that br br br br br br x br br t br br s br br br displaystyle lambda x t s br br reduces to br br br br t br br x br br s br br br br displaystyle t x s br br br For example for every br br br br s br br br displaystyle s br br br br br br br br x br br x br br s br br x br br x br br s br br br s br br br displaystyle lambda x x s to x x s s br br This demonstrates that br br br br br x br br x br br br displaystyle lambda x x br br really is the identity br Similarly br br br br br br x br br y br br s br br y br br x br br s br br br y br br br displaystyle lambda x y s to y x s y br br which demonstrates that br br br br br x br br y br br br displaystyle lambda x y br br is a constant function br The lambda calculus may be seen as an idealized version of a functional programming language like Haskell or Standard ML Under this view reduction corresponds to a computational step This step can be repeated by additional reductions until there are no more applications left to reduce In the untyped lambda calculus as presented here this reduction process may not terminate For instance consider the term br br br br br br br br x br br x br x br br br br x br br x br x br br br br displaystyle Omega lambda x xx lambda x xx br br br Here br br br br br br x br br x br x br br br br x br br x br x br br br br x br x br br br x br br br x br br x br x br br br br x br br x br br br x br br x br x br br br br x br br x br br br x br br x br x br br br br br br x br br x br x br br br br x br br x br x br br br br displaystyle lambda x xx lambda x xx to xx x lambda x xx x x lambda x xx x x lambda x xx lambda x xx lambda x xx br br br That is the term reduces to itself in a single reduction and therefore the reduction process will never terminate br Another aspect of the untyped lambda calculus is that it does not distinguish between different kinds of data For instance it may be desirable to write a function that only operates on numbers However in the untyped lambda calculus there is no way to prevent a function from being applied to truth values strings or other non number objects br br br Formal definition br br br Definition br Lambda expressions are composed of br br variables v v br the abstraction symbols lambda and dot br parentheses br The set of lambda expressions can be defined inductively br br If x is a variable then x br If x is a variable and M then x M br If M N then M N br Instances of rule are known as abstractions and instances of rule are known as applications See reducible expression br This set of rules may be written in Backus Naur form as br br br Notation br To keep the notation of lambda expressions uncluttered the following conventions are usually applied br br Outermost parentheses are dropped M N instead of M N br Applications are assumed to be left associative M N P may be written instead of M N P br When all variables are single letter the space in applications may be omitted MNP instead of M N P br The body of an abstraction extends as far right as possible x M N means x M N and not x M N br A sequence of abstractions is contracted x y z N is abbreviated as xyz N br br br Free and bound variables br The abstraction operator is said to bind its variable wherever it occurs in the body of the abstraction Variables that fall within the scope of an abstraction are said to be bound In an expression x M the part x is often called binder as a hint that the variable x is getting bound by prepending x to M All other variables are called free For example in the expression y x x y y is a bound variable and x is a free variable Also a variable is bound by its nearest abstraction In the following example the single occurrence of x in the expression is bound by the second lambda x y x z x br The set of free variables of a lambda expression M is denoted as FV M and is defined by recursion on the structure of the terms as follows br br FV x x where x is a variable br FV x M FV M x br FV M N FV M FV N br An expression that contains no free variables is said to be closed Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic br br br Reduction br The meaning of lambda expressions is defined by how expressions can be reduced br There are three kinds of reduction br br conversion changing bound variables br reduction applying functions to their arguments br reduction which captures a notion of extensionality br We also speak of the resulting equivalences two expressions are equivalent if they can be converted into the same expression equivalence and equivalence are defined similarly br The term redex short for reducible expression refers to subterms that can be reduced by one of the reduction rules For example x M N is a redex in expressing the substitution of N for x in M The expression to which a redex reduces is called its reduct the reduct of x M N is M x N br If x is not free in M x M x is also an redex with a reduct of M br br br conversion br conversion alpha conversion sometimes known as renaming allows bound variable names to be changed For example conversion of x x might yield y y Terms that differ only by conversion are called equivalent Frequently in uses of lambda calculus equivalent terms are considered to be equivalent br The precise rules for conversion are not completely trivial First when converting an abstraction the only variable occurrences that are renamed are those that are bound to the same abstraction For example an conversion of x x x could result in y x x but it could not result in y x y The latter has a different meaning from the original This is analogous to the programming notion of variable shadowing br Second conversion is not possible if it would result in a variable getting captured by a different abstraction For example if we replace x with y in x y x we get y y y which is not at all the same br In programming languages with static scope conversion can be used to make name resolution simpler by ensuring that no variable name masks a name in a containing scope see renaming to make name resolution trivial br In the De Bruijn index notation any two equivalent terms are syntactically identical br br br Substitution br Substitution written M x N is the process of replacing all free occurrences of the variable x in the expression M with expression N Substitution on terms of the lambda calculus is defined by recursion on the structure of terms as follows note x and y are only variables while M and N are any lambda expression br br x x N N br y x N y if x y br M M x N M x N M x N br x M x N x M br y M x N y M x N if x y and y FV N See above for the FV br To substitute into an abstraction it is sometimes necessary to convert the expression For example it is not correct for x y y x to result in x x because the substituted x was supposed to be free but ended up being bound The correct substitution in this case is z x up to equivalence Substitution is defined uniquely up to equivalence See Capture avoiding substitutions above br br br reduction br reduction beta reduction captures the idea of function application br reduction is defined in terms of substitution the reduction of x M N is M x N br For example assuming some encoding of we have the following reduction n n br reduction can be seen to be the same as the concept of local reducibility in natural deduction via the Curry Howard isomorphism br br br reduction br reduction eta reduction expresses the idea of extensionality which in this context is that two functions are the same if and only if they give the same result for all arguments reduction converts between x f x and f whenever x does not appear free in f br reduction can be seen to be the same as the concept of local completeness in natural deduction via the Curry Howard isomorphism br br br Normal forms and confluence br br For the untyped lambda calculus reduction as a rewriting rule is neither strongly normalising nor weakly normalising br However it can be shown that reduction is confluent when working up to conversion i e we consider two normal forms to be equal if it is possible to convert one into the other br Therefore both strongly normalising terms and weakly normalising terms have a unique normal form For strongly normalising terms any reduction strategy is guaranteed to yield the normal form whereas for weakly normalising terms some reduction strategies may fail to find it br br br Encoding datatypes br br The basic lambda calculus may be used to model arithmetic booleans data structures and recursion as illustrated in the following sub sections i ii iii and iv br br br Arithmetic in lambda calculus br There are several possible ways to define the natural numbers in lambda calculus but by far the most common are the Church numerals which can be defined as follows br br f x x br f x f x br f x f f x br f x f f f x br and so on Or using the alternative syntax presented above in Notation br br fx x br fx f x br fx f f x br fx f f f x br A Church numeral is a higher order function it takes a single argument function f and returns another single argument function The Church numeral n is a function that takes a function f as argument and returns the n th composition of f i e the function f composed with itself n times This is denoted f n and is in fact the n th power of f considered as an operator f is defined to be the identity function Such repeated compositions of a single function f obey the laws of exponents which is why these numerals can be used for arithmetic In Church s original lambda calculus the formal parameter of a lambda expression was required to occur at least once in the function body which made the above definition of impossible br One way of thinking about the Church numeral n which is often useful when analysing programs is as an instruction repeat n times For example using the PAIR and NIL functions defined below one can define a function that constructs a linked list of n elements all equal to x by repeating prepend another x element n times starting from an empty list The lambda term is br br n x n PAIR x NIL br By varying what is being repeated and varying what argument that function being repeated is applied to a great many different effects can be achieved br We can define a successor function which takes a Church numeral n and returns n by adding another application of f where mf x means the function f is applied m times on x br br SUCC n f x f n f x br Because the m th composition of f composed with the n th composition of f gives the m n th composition of f addition can be defined as follows br br PLUS m n f x m f n f x br PLUS can be thought of as a function taking two natural numbers as arguments and returning a natural number it can be verified that br br PLUS br and br br br are equivalent lambda expressions Since adding m to a number n can be accomplished by adding m times an alternative definition is br br PLUS m n m SUCC n br Similarly multiplication can be defined as br br MULT m n f m n f br Alternatively br br MULT m n m PLUS n br since multiplying m and n is the same as repeating the add n function m times and then applying it to zero br Exponentiation has a rather simple rendering in Church numerals namely br br POW b e e b br The predecessor function defined by PRED n n for a positive integer n and PRED is considerably more difficult The formula br br PRED n f x n g h h g f u x u u br can be validated by showing inductively that if T denotes g h h g f then T n u x h h f n x for n Two other definitions of PRED are given below one using conditionals and the other using pairs With the predecessor function subtraction is straightforward Defining br br SUB m n n PRED m br SUB m n yields m n when m n and otherwise br br br Logic and predicates br By convention the following two definitions known as Church booleans are used for the boolean values TRUE and FALSE br br TRUE x y x br FALSE x y y br Then with these two lambda terms we can define some logic operators these are just possible formulations other expressions could be equally correct br br AND p q p q p br OR p q p p q br NOT p p FALSE TRUE br IFTHENELSE p a b p a b br We are now able to compute some logic functions for example br br AND TRUE FALSE br p q p q p TRUE FALSE TRUE FALSE TRUE br x y x FALSE TRUE FALSE br and we see that AND TRUE FALSE is equivalent to FALSE br A predicate is a function that returns a boolean value The most fundamental predicate is ISZERO which returns TRUE if its argument is the Church numeral but FALSE if its argument were any other Church numeral br br ISZERO n n x FALSE TRUE br The following predicate tests whether the first argument is less than or equal to the second br br LEQ m n ISZERO SUB m n br and since m n if LEQ m n and LEQ n m it is straightforward to build a predicate for numerical equality br The availability of predicates and the above definition of TRUE and FALSE make it convenient to write if then else expressions in lambda calculus For example the predecessor function can be defined as br br PRED n n g k ISZERO g k PLUS g k v br which can be verified by showing inductively that n g k ISZERO g k PLUS g k v is the add n function for n br br br Pairs br A pair tuple can be defined in terms of TRUE and FALSE by using the Church encoding for pairs For example PAIR encapsulates the pair x y FIRST returns the first element of the pair and SECOND returns the second br br PAIR x y f f x y br FIRST p p TRUE br SECOND p p FALSE br NIL x TRUE br NULL p p x y FALSE br A linked list can be defined as either NIL for the empty list or the PAIR of an element and a smaller list The predicate NULL tests for the value NIL Alternatively with NIL FALSE the construct l h t z deal with head h and tail t deal with nil obviates the need for an explicit NULL test br As an example of the use of pairs the shift and increment function that maps m n to n n can be defined as br br x PAIR SECOND x SUCC SECOND x br which allows us to give perhaps the most transparent version of the predecessor function br br PRED n FIRST n PAIR br br br Additional programming techniques br There is a considerable body of programming idioms for lambda calculus Many of these were originally developed in the context of using lambda calculus as a foundation for programming language semantics effectively using lambda calculus as a low level programming language Because several programming languages include the lambda calculus or something very similar as a fragment these techniques also see use in practical programming but may then be perceived as obscure or foreign br br br Named constants br In lambda calculus a library would take the form of a collection of previously defined functions which as lambda terms are merely particular constants The pure lambda calculus does not have a concept of named constants since all atomic lambda terms are variables but one can emulate having named constants by setting aside a variable as the name of the constant using abstraction to bind that variable in the main body and apply that abstraction to the intended definition Thus to use f to mean N some explicit lambda term in M another lambda term the main program one can say br br f M N br Authors often introduce syntactic sugar such as let to permit writing the above in the more intuitive order br br let f N in M br By chaining such definitions one can write a lambda calculus program as zero or more function definitions followed by one lambda term using those functions that constitutes the main body of the program br A notable restriction of this let is that the name f be not defined in N for N to be outside the scope of the abstraction binding f this means a recursive function definition cannot be used as the N with let The letrec construction would allow writing recursive function definitions br br br Recursion and fixed points br br Recursion is the definition of a function using the function itself A definition containing itself inside itself by value leads to the whole value being of infinite size Other notations which support recursion natively overcome this by referring to the function definition by name Lambda calculus cannot express this all functions are anonymous in lambda calculus so we can t refer by name to a value which is yet to be defined inside the lambda term defining that same value However a lambda expression can receive itself as its own argument for example in x x x E Here E should be an abstraction applying its parameter to a value to express recursion br Consider the factorial function F n recursively defined by br br F n if n else n F n br In the lambda expression which is to represent this function a parameter typically the first one will be assumed to receive the lambda expression itself as its value so that calling it applying it to an argument will amount to recursion Thus to achieve recursion the intended as self referencing argument called r here must always be passed to itself within the function body at a call point br br G r n if n else n r r n br with r r x F x G r x to hold so r G and br F G G x x x G br The self application achieves replication here passing the function s lambda expression on to the next invocation as an argument value making it available to be referenced and called there br This solves it but requires re writing each recursive call as self application We would like to have a generic solution without a need for any re writes br br G r n if n else n r n br with r x F x G r x to hold so r G r FIX G and br F FIX G where FIX g r where r g r g FIX g br so that FIX G G FIX G n if n else n FIX G n br Given a lambda term with first argument representing recursive call e g G here the fixed point combinator FIX will return a self replicating lambda expression representing the recursive function here F The function does not need to be explicitly passed to itself at any point for the self replication is arranged in advance when it is created to be done each time it is called Thus the original lambda expression FIX G is re created inside itself at call point achieving self reference br In fact there are many possible definitions for this FIX operator the simplest of them being br br Y g x g x x x g x x br In the lambda calculus Y g is a fixed point of g as it expands to br br Y g br h x h x x x h x x g br x g x x x g x x br g x g x x x g x x br g Y g br Now to perform our recursive call to the factorial function we would simply call Y G n where n is the number we are calculating the factorial of Given n for example this gives br br Y G br G Y G br r n if n else n r n Y G br n if n else n Y G n br if else Y G br G Y G br n if n else n Y G n br if else Y G br G Y G br n if n else n Y G n br if else Y G br G Y G br n if n else n Y G n br if else Y G br G Y G br n if n else n Y G n br if else Y G br br br Every recursively defined function can be seen as a fixed point of some suitably defined function closing over the recursive call with an extra argument and therefore using Y every recursively defined function can be expressed as a lambda expression In particular we can now cleanly define the subtraction multiplication and comparison predicate of natural numbers recursively br br br Standard terms br Certain terms have commonly accepted names br br I x x br S x y z x z y z br K x y x br B x y z x y z br C x y z x z y br W x y x y y br or or U x x x br br I is the identity function SK and BCKW form complete combinator calculus systems that can express any lambda term see br the next section is UU the smallest term that has no normal form YI is another such term br Y is standard and defined above and can also be defined as Y BU CBU so that Yg g Yg TRUE and FALSE defined above are commonly abbreviated as T and F br br br Abstraction elimination br br If N is a lambda term without abstraction but possibly containing named constants combinators then there exists a lambda term T x N which is equivalent to x N but lacks abstraction except as part of the named constants if these are considered non atomic This can also be viewed as anonymising variables as T x N removes all occurrences of x from N while still allowing argument values to be substituted into the positions where N contains an x The conversion function T can be defined by br br T x x I br T x N K N if x is not free in N br T x M N S T x M T x N br In either case a term of the form T x N P can reduce by having the initial combinator I K or S grab the argument P just like reduction of x N P would do I returns that argument K throws the argument away just like x N would do if x has no free occurrence in N S passes the argument on to both subterms of the application and then applies the result of the first to the result of the second br The combinators B and C are similar to S but pass the argument on to only one subterm of an application B to the argument subterm and C to the function subterm thus saving a subsequent K if there is no occurrence of x in one subterm In comparison to B and C the S combinator actually conflates two functionalities rearranging arguments and duplicating an argument so that it may be used in two places The W combinator does only the latter yielding the B C K W system as an alternative to SKI combinator calculus br br br Typed lambda calculus br br A typed lambda calculus is a typed formalism that uses the lambda symbol br br br br br br br displaystyle lambda br br to denote anonymous function abstraction In this context types are usually objects of a syntactic nature that are assigned to lambda terms the exact nature of a type depends on the calculus considered see Kinds of typed lambda calculi From a certain point of view typed lambda calculi can be seen as refinements of the untyped lambda calculus but from another point of view they can also be considered the more fundamental theory and untyped lambda calculus a special case with only one type br Typed lambda calculi are foundational programming languages and are the base of typed functional programming languages such as ML and Haskell and more indirectly typed imperative programming languages Typed lambda calculi play an important role in the design of type systems for programming languages here typability usually captures desirable properties of the program e g the program will not cause a memory access violation br Typed lambda calculi are closely related to mathematical logic and proof theory via the Curry Howard isomorphism and they can be considered as the internal language of classes of categories e g the simply typed lambda calculus is the language of Cartesian closed categories CCCs br br br Reduction strategies br br Whether a term is normalising or not and how much work needs to be done in normalising it if it is depends to a large extent on the reduction strategy used Common lambda calculus reduction strategies include br br Normal order br The leftmost outermost redex is reduced first That is whenever possible arguments are substituted into the body of an abstraction before the arguments are reduced If a term has a beta normal form normal order reduction will always reach that normal form br Applicative order br The leftmost innermost redex is reduced first As a consequence a function s arguments are always reduced before they are substituted into the function Unlike normal order reduction applicative order reduction may fail to find the beta normal form of an expression even if such a normal form exists For example the term br br br br br br br x br br y br br br br br z br br br z br z br br br br z br br br z br z br br br br br br br displaystyle lambda x y lambda z zz lambda z zz br br is reduced to itself by applicative order while normal order reduces it to its beta normal form br br br br y br br br displaystyle y br br br Full reductions br Any redex can be reduced at any time This means essentially the lack of any particular reduction strategy with regard to reducibility all bets are off br Weak reduction strategies do not reduce under lambda abstractions br br Call by value br Like applicative order but no reductions are performed inside abstractions This is similar to the evaluation order of strict languages like C the arguments to a function are evaluated before calling the function and function bodies are not even partially evaluated until the arguments are substituted in br Call by name br Like normal order but no reductions are performed inside abstractions For example x y y x is in normal form according to this strategy although it contains the redex y y x br Strategies with sharing reduce computations that are the same in parallel br br Optimal reduction br As normal order but computations that have the same label are reduced simultaneously br Call by need br As call by name hence weak but function applications that would duplicate terms instead name the argument The argument may be evaluated when needed at which point the name binding is updated with the reduced value This can save time compared to normal order evaluation br br br Computability br There is no algorithm that takes as input any two lambda expressions and outputs TRUE or FALSE depending on whether one expression reduces to the other More precisely no computable function can decide the question This was historically the first problem for which undecidability could be proven As usual for such a proof computable means computable by any model of computation that is Turing complete In fact computability can itself be defined via the lambda calculus a function F N N of natural numbers is a computable function if and only if there exists a lambda expression f such that for every pair of x y in N F x y if and only if f x y where x and y are the Church numerals corresponding to x and y respectively and meaning equivalence with reduction See the Church Turing thesis for other approaches to defining computability and their equivalence br Church s proof of uncomputability first reduces the problem to determining whether a given lambda expression has a normal form Then he assumes that this predicate is computable and can hence be expressed in lambda calculus Building on earlier work by Kleene and constructing a G del numbering for lambda expressions he constructs a lambda expression e that closely follows the proof of G del s first incompleteness theorem If e is applied to its own G del number a contradiction results br br br Complexity br The notion of computational complexity for the lambda calculus is a bit tricky because the cost of a reduction may vary depending on how it is implemented br To be precise one must somehow find the location of all of the occurrences of the bound variable V in the expression E implying a time cost or one must keep track of the locations of free variables in some way implying a space cost A na ve search for the locations of V in E is O n in the length n of E Director strings were an early approach that traded this time cost for a quadratic space usage More generally this has led to the study of systems that use explicit substitution br In it was shown that the number of reduction steps taken by normal order reduction to reduce a term is a reasonable time cost model that is the reduction can be simulated on a Turing machine in time polynomially proportional to the number of steps This was a long standing open problem due to size explosion the existence of lambda terms which grow exponentially in size for each reduction The result gets around this by working with a compact shared representation The result makes clear that the amount of space needed to evaluate a lambda term is not proportional to the size of the term during reduction It is not currently known what a good measure of space complexity would be br An unreasonable model does not necessarily mean inefficient Optimal reduction reduces all computations with the same label in one step avoiding duplicated work but the number of parallel reduction steps to reduce a given term to normal form is approximately linear in the size of the term This is far too small to be a reasonable cost measure as any Turing machine may be encoded in the lambda calculus in size linearly proportional to the size of the Turing machine The true cost of reducing lambda terms is not due to reduction per se but rather the handling of the duplication of redexes during reduction It is not known if optimal reduction implementations are reasonable when measured with respect to a reasonable cost model such as the number of leftmost outermost steps to normal form but it has been shown for fragments of the lambda calculus that the optimal reduction algorithm is efficient and has at most a quadratic overhead compared to leftmost outermost In addition the BOHM prototype implementation of optimal reduction outperformed both Caml Light and Haskell on pure lambda terms br br br Lambda calculus and programming languages br As pointed out by Peter Landin s paper A Correspondence between ALGOL and Church s Lambda notation sequential procedural programming languages can be understood in terms of the lambda calculus which provides the basic mechanisms for procedural abstraction and procedure subprogram application br br br Anonymous functions br br For example in Python the square function can be expressed as a lambda expression as follows br br The above example is an expression that evaluates to a first class function The symbol lambda creates an anonymous function given a list of parameter names x just a single argument in this case and an expression that is evaluated as the body of the function x Anonymous functions are sometimes called lambda expressions br For example Pascal and many other imperative languages have long supported passing subprograms as arguments to other subprograms through the mechanism of function pointers However function pointers are not a sufficient condition for functions to be first class datatypes because a function is a first class datatype if and only if new instances of the function can be created at run time And this run time creation of functions is supported in Smalltalk JavaScript and Wolfram Language and more recently in Scala Eiffel agents C delegates and C among others br br br Parallelism and concurrency br The Church Rosser property of the lambda calculus means that evaluation reduction can be carried out in any order even in parallel This means that various nondeterministic evaluation strategies are relevant However the lambda calculus does not offer any explicit constructs for parallelism One can add constructs such as Futures to the lambda calculus Other process calculi have been developed for describing communication and concurrency br br br Semantics br The fact that lambda calculus terms act as functions on other lambda calculus terms and even on themselves led to questions about the semantics of the lambda calculus Could a sensible meaning be assigned to lambda calculus terms The natural semantics was to find a set D isomorphic to the function space D D of functions on itself However no nontrivial such D can exist by cardinality constraints because the set of all functions from D to D has greater cardinality than D unless D is a singleton set br In the s Dana Scott showed that if only continuous functions were considered a set or domain D with the required property could be found thus providing a model for the lambda calculus br This work also formed the basis for the denotational semantics of programming languages br br br Variations and extensions br These extensions are in the lambda cube br br Typed lambda calculus Lambda calculus with typed variables and functions br System F A typed lambda calculus with type variables br Calculus of constructions A typed lambda calculus with types as first class values br These formal systems are extensions of lambda calculus that are not in the lambda cube br br Binary lambda calculus A version of lambda calculus with binary I O a binary encoding of terms and a designated universal machine br Lambda mu calculus An extension of the lambda calculus for treating classical logic br These formal systems are variations of lambda calculus br br Kappa calculus A first order analogue of lambda calculus br These formal systems are related to lambda calculus br br Combinatory logic A notation for mathematical logic without variables br SKI combinator calculus A computational system based on the S K and I combinators equivalent to lambda calculus but reducible without variable substitutions br br br See also br br br Further reading br Abelson Harold Gerald Jay Sussman Structure and Interpretation of Computer Programs The MIT Press ISBN br Barendregt Hendrik Pieter Introduction to Lambda Calculus br Barendregt Hendrik Pieter The Impact of the Lambda Calculus in Logic and Computer Science The Bulletin of Symbolic Logic Volume Number June br Barendregt Hendrik Pieter The Type Free Lambda Calculus pp of Handbook of Mathematical Logic North Holland ISBN X br Cardone Felice and Hindley J Roger History of Lambda calculus and Combinatory Logic Archived at the Wayback Machine In Gabbay and Woods eds Handbook of the History of Logic vol Elsevier br Church Alonzo An unsolvable problem of elementary number theory American Journal of Mathematics pp This paper contains the proof that the equivalence of lambda expressions is in general not decidable br Church Alonzo The Calculi of Lambda Conversion Princeton Princeton University Press Retrieved ISBN br Frink Jr Orrin Review The Calculi of Lambda Conversion by Alonzo Church PDF Bull Amer Math Soc doi s br Kleene Stephen A theory of positive integers in formal logic American Journal of Mathematics pp and Contains the lambda calculus definitions of several familiar functions br Landin Peter A Correspondence Between ALGOL and Church s Lambda Notation Communications of the ACM vol no pages Available from the ACM site A classic paper highlighting the importance of lambda calculus as a basis for programming languages br Larson Jim An Introduction to Lambda Calculus and Scheme A gentle introduction for programmers br Michaelson Greg April An Introduction to Functional Programming Through Lambda Calculus Courier Corporation ISBN br Schalk A and Simmons H An introduction to calculi and arithmetic with a decent selection of exercises Notes for a course in the Mathematical Logic MSc at Manchester University br de Queiroz Ruy J G B On Reduction Rules Meaning as Use and Proof Theoretic Semantics Studia Logica doi s S CID A paper giving a formal underpinning to the idea of meaning is use which even if based on proofs it is different from proof theoretic semantics as in the Dummett Prawitz tradition since it takes reduction as the rules giving meaning br Hankin Chris An Introduction to Lambda Calculi for Computer Scientists ISBN br Monographs textbooks for graduate students br br S rensen Morten Heine and Urzyczyn Pawe Lectures on the Curry Howard isomorphism Elsevier ISBN is a recent monograph that covers the main topics of lambda calculus from the type free variety to most typed lambda calculi including more recent developments like pure type systems and the lambda cube It does not cover subtyping extensions br Pierce Benjamin Types and Programming Languages MIT Press ISBN covers lambda calculi from a practical type system perspective some topics like dependent types are only mentioned but subtyping is an important topic br Documents br A Short Introduction to the Lambda Calculus PDF by Achim Jung br A timeline of lambda calculus PDF by Dana Scott br A Tutorial Introduction to the Lambda Calculus PDF by Ra l Rojas br Lecture Notes on the Lambda Calculus PDF by Peter Selinger br Graphic lambda calculus by Marius Buliga br Lambda Calculus as a Workflow Model by Peter Kelly Paul Coddington and Andrew Wendelborn mentions graph reduction as a common means of evaluating lambda expressions and discusses the applicability of lambda calculus for distributed computing due to the Church Rosser property which enables parallel graph reduction for lambda expressions br br br Notes br br br br Some parts of this article are based on material from FOLDOC used with permission br br br External links br br Graham Hutton Lambda Calculus a short minutes Computerphile video on the Lambda Calculus br Helmut Brandl Step by Step Introduction to Lambda Calculus br Lambda calculus Encyclopedia of Mathematics EMS Press br David C Keenan To Dissect a Mockingbird A Graphical Notation for the Lambda Calculus with Animated Reduction br L Allison Some executable calculus examples br Georg P Loczewski The Lambda Calculus and A br Bret Victor Alligator Eggs A Puzzle Game Based on Lambda Calculus br Lambda Calculus Archived at the Wayback Machine on Safalra s Website Archived at the Wayback Machine br LCI Lambda Interpreter a simple yet powerful pure calculus interpreter br Lambda Calculus links on Lambda the Ultimate br Mike Thyer Lambda Animator a graphical Java applet demonstrating alternative reduction strategies br Implementing the Lambda calculus using C Templates br Shane Steinert Threlkeld Lambda Calculi Internet Encyclopedia of Philosophy br Anton Salikhmetov Macro Lambda Calculus