title: Unification (computer science)
id: 54432
In logic and computer science specifically automated reasoning unification is an algorithmic process of solving equations between symbolic expressions each of the form Left hand side Right hand side For example using x y z as variables and taking f to be an uninterpreted function the singleton equation set f y f x is a syntactic first order unification problem that has the substitution x y as its only solution br Conventions differ on what values variables may assume and which expressions are considered equivalent In first order syntactic unification variables range over first order terms and equivalence is syntactic This version of unification has a unique best answer and is used in logic programming and programming language type system implementation especially in Hindley Milner based type inference algorithms In higher order unification possibly restricted to higher order pattern unification terms may include lambda expressions and equivalence is up to beta reduction This version is used in proof assistants and higher order logic programming for example Isabelle Twelf and lambdaProlog Finally in semantic unification or E unification equality is subject to background knowledge and variables range over a variety of domains This version is used in SMT solvers term rewriting algorithms and cryptographic protocol analysis br br br Formal definition br A unification problem is a finite set E l r ln rn of equations to solve where li ri are in the set br br br br T br br br displaystyle T br br of terms or expressions Depending on which expressions or terms are allowed to occur in an equation set or unification problem and which expressions are considered equal several frameworks of unification are distinguished If higher order variables that is variables representing functions are allowed in an expression the process is called higher order unification otherwise first order unification If a solution is required to make both sides of each equation literally equal the process is called syntactic or free unification otherwise semantic or equational unification or E unification or unification modulo theory br If the right side of each equation is closed no free variables the problem is called pattern matching The left side with variables of each equation is called the pattern br br br Prerequisites br Formally a unification approach presupposes br br An infinite set br br br br V br br br displaystyle V br br of variables For higher order unification it is convenient to choose br br br br V br br br displaystyle V br br disjoint from the set of lambda term bound variables br A set br br br br T br br br displaystyle T br br of terms such that br br br br V br br T br br br displaystyle V subseteq T br br For first order unification br br br br T br br br displaystyle T br br is usually the set of first order terms terms built from variable and function symbols For higher order unification br br br br T br br br displaystyle T br br consists of first order terms and lambda terms terms containing some higher order variables br A mapping br br br br br vars br br br T br br br br displaystyle text vars colon T rightarrow br br br br br br br P br br br br displaystyle mathbb P br br br br br br br V br br br br displaystyle V br br assigning to each term br br br br t br br br displaystyle t br br the set br br br br br vars br br br t br br br V br br br displaystyle text vars t subsetneq V br br of free variables occurring in br br br br t br br br displaystyle t br br br A theory or equivalence relation br br br br br br br displaystyle equiv br br on br br br br T br br br displaystyle T br br indicating which terms are considered equal For first order E unification br br br br br br br displaystyle equiv br br reflects the background knowledge about certain function symbols for example if br br br br br br br displaystyle oplus br br is considered commutative br br br br t br br u br br br displaystyle t equiv u br br if br br br br u br br br displaystyle u br br results from br br br br t br br br displaystyle t br br by swapping the arguments of br br br br br br br displaystyle oplus br br at some possibly all occurrences In the most typical case that there is no background knowledge at all then only literally or syntactically identical terms are considered equal In this case is called the free theory because it is a free object the empty theory because the set of equational sentences or the background knowledge is empty the theory of uninterpreted functions because unification is done on uninterpreted terms or the theory of constructors because all function symbols just build up data terms rather than operating on them For higher order unification usually br br br br t br br u br br br displaystyle t equiv u br br if br br br br t br br br displaystyle t br br and br br br br u br br br displaystyle u br br are alpha equivalent br As an example of how the set of terms and theory affects the set of solutions the syntactic first order unification problem y cons y has no solution over the set of finite terms However it has the single solution y cons cons cons over the set of infinite tree terms Similarly the semantic first order unification problem a x x a has each substitution of the form x a a as a solution in a semigroup i e if is considered associative But the same problem viewed in an abelian group where is considered also commutative has any substitution at all as a solution br As an example of higher order unification the singleton set a y x is a syntactic second order unification problem since y is a function variable One solution is x a y identity function another one is y constant function mapping each value to a x any value br br br Substitution br br A substitution is a mapping br br br br br br V br br T br br br displaystyle sigma V rightarrow T br br from variables to terms the notation br br br br br br x br br br br br br br t br br br br br br br br br br br x br br k br br br br br t br br k br br br br br br displaystyle x mapsto t x k mapsto t k br br refers to a substitution mapping each variable br br br br br x br br i br br br br br displaystyle x i br br to the term br br br br br t br br i br br br br br displaystyle t i br br for br br br br i br br br br br br br br k br br br displaystyle i k br br and every other variable to itself the br br br br br x br br i br br br br br displaystyle x i br br must be pairwise distinct Applying that substitution to a term br br br br t br br br displaystyle t br br is written in postfix notation as br br br br t br br br x br br br br br br br t br br br br br br br br br br br x br br k br br br br br t br br k br br br br br br displaystyle t x mapsto t x k mapsto t k br br it means to simultaneously replace every occurrence of each variable br br br br br x br br i br br br br br displaystyle x i br br in the term br br br br t br br br displaystyle t br br by br br br br br t br br i br br br br br displaystyle t i br br The result br br br br t br br br br displaystyle t tau br br of applying a substitution br br br br br br br displaystyle tau br br to a term br br br br t br br br displaystyle t br br is called an instance of that term br br br br t br br br displaystyle t br br br As a first order example applying the substitution x h a y z b to the term br br br Generalization specialization br If a term br br br br t br br br displaystyle t br br has an instance equivalent to a term br br br br u br br br displaystyle u br br that is if br br br br t br br br u br br br displaystyle t sigma equiv u br br for some substitution br br br br br br br displaystyle sigma br br then br br br br t br br br displaystyle t br br is called more general than br br br br u br br br displaystyle u br br and br br br br u br br br displaystyle u br br is called more special than or subsumed by br br br br t br br br displaystyle t br br For example br br br br x br br a br br br displaystyle x oplus a br br is more general than br br br br a br br b br br br displaystyle a oplus b br br if is commutative since then br br br br br x br br a br br br x br br b br br br b br br a br br a br br b br br br displaystyle x oplus a x mapsto b b oplus a equiv a oplus b br br br If is literal syntactic identity of terms a term may be both more general and more special than another one only if both terms differ just in their variable names not in their syntactic structure such terms are called variants or renamings of each other br For example br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br displaystyle f x a g z y br br br is a variant of br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br displaystyle f x a g z y br br br since br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br x br br br br br br br x br br br br br br br y br br br br br br br y br br br br br br br z br br br br br br br z br br br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br displaystyle f x a g z y x mapsto x y mapsto y z mapsto z f x a g z y br br br and br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br x br br br br br br br x br br br br br br br y br br br br br br br y br br br br br br br z br br br br br br br z br br br br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br br displaystyle f x a g z y x mapsto x y mapsto y z mapsto z f x a g z y br br br However br br br br f br br br x br br br br br br a br br g br br br z br br br br br br br br y br br br br br br br br displaystyle f x a g z y br br is not a variant of br br br br f br br br x br br br br br br a br br g br br br x br br br br br br br br x br br br br br br br br displaystyle f x a g x x br br since no substitution can transform the latter term into the former one br The latter term is therefore properly more special than the former one br For arbitrary br br br br br br br displaystyle equiv br br a term may be both more general and more special than a structurally different term br For example if is idempotent that is if always br br br br x br br x br br x br br br displaystyle x oplus x equiv x br br then the term br br br br x br br y br br br displaystyle x oplus y br br is more general than br br br br z br br br displaystyle z br br and vice versa although br br br br x br br y br br br displaystyle x oplus y br br and br br br br z br br br displaystyle z br br are of different structure br A substitution br br br br br br br displaystyle sigma br br is more special than or subsumed by a substitution br br br br br br br displaystyle tau br br if br br br br t br br br br displaystyle t sigma br br is subsumed by br br br br t br br br br displaystyle t tau br br for each term br br br br t br br br displaystyle t br br We also say that br br br br br br br displaystyle tau br br is more general than br br br br br br br displaystyle sigma br br More formally take a nonempty infinite set br br br br V br br br displaystyle V br br of auxiliary variables such that no equation br br br br br l br br i br br br br br r br br i br br br br br displaystyle l i doteq r i br br in the unification problem contains variables from br br br br V br br br displaystyle V br br Then a substitution br br br br br br br displaystyle sigma br br is subsumed by another substitution br br br br br br br displaystyle tau br br if there is a substitution br br br br br br br displaystyle theta br br such that for all terms br br br br X br br V br br br displaystyle X notin V br br br br br br X br br br X br br br br br displaystyle X sigma equiv X tau theta br br br For instance br br br br br x br br a br br y br br a br br br br displaystyle x mapsto a y mapsto a br br is subsumed by br br br br br br br x br br y br br br br displaystyle tau x mapsto y br br using br br br br br br br y br br a br br br br displaystyle theta y mapsto a br br but br br br br br br br br x br br a br br br br displaystyle sigma x mapsto a br br is not subsumed by br br br br br br br x br br y br br br br displaystyle tau x mapsto y br br as br br br br f br br x br br y br br br br f br br a br br y br br br br displaystyle f x y sigma f a y br br is not an instance of br br br br br f br br x br br y br br br br f br br y br br y br br br br displaystyle f x y tau f y y br br br br br Solution set br A substitution is a solution of the unification problem E if li ri for br br br br i br br br br br br br br n br br br displaystyle i n br br Such a substitution is also called a unifier of E br For example if is associative the unification problem x a a x has the solutions x a x a a x a a a etc while the problem x a a has no solution br For a given unification problem E a set S of unifiers is called complete if each solution substitution is subsumed by some substitution in S A complete substitution set always exists e g the set of all solutions but in some frameworks such as unrestricted higher order unification the problem of determining whether any solution exists i e whether the complete substitution set is nonempty is undecidable br The set S is called minimal if none of its members subsumes another one Depending on the framework a complete and minimal substitution set may have zero one finitely many or infinitely many members or may not exist at all due to an infinite chain of redundant members Thus in general unification algorithms compute a finite approximation of the complete set which may or may not be minimal although most algorithms avoid redundant unifiers when possible For first order syntactical unification Martelli and Montanari gave an algorithm that reports unsolvability or computes a single unifier that by itself forms a complete and minimal substitution set called the most general unifier br br br Syntactic unification of first order terms br br Syntactic unification of first order terms is the most widely used unification framework br It is based on T being the set of first order terms over some given set V of variables C of constants and Fn of n ary function symbols and on being syntactic equality br In this framework each solvable unification problem l r ln rn has a complete and obviously minimal singleton solution set br Its member is called the most general unifier mgu of the problem br The terms on the left and the right hand side of each potential equation become syntactically equal when the mgu is applied i e l r ln rn br Any unifier of the problem is subsumed by the mgu br The mgu is unique up to variants if S and S are both complete and minimal solution sets of the same syntactical unification problem then S and S for some substitutions and and x is a variant of x for each variable x occurring in the problem br For example the unification problem x z y f x has a unifier x z y f z because br br This is also the most general unifier br Other unifiers for the same problem are e g x f x y f f x z f x x f f x y f f f x z f f x and so on there are infinitely many similar unifiers br As another example the problem g x x f y has no solution with respect to being literal identity since any substitution applied to the left and right hand side will keep the outermost g and f respectively and terms with different outermost function symbols are syntactically different br br br Unification algorithms br br Jacques Herbrand discussed the basic concepts of unification and sketched an algorithm in But most authors attribute the first unification algorithm to John Alan Robinson cf box Robinson s algorithm had worst case exponential behavior in both time and space Numerous authors have proposed more efficient unification algorithms Algorithms with worst case linear time behavior were discovered independently by Martelli Montanari and Paterson Wegman Baader Snyder uses a similar technique as Paterson Wegman hence is linear but like most linear time unification algorithms is slower than the Robinson version on small sized inputs due to the overhead of preprocessing the inputs and postprocessing of the output such as construction of a DAG representation de Champeaux is also of linear complexity in the input size but is competitive with the Robinson algorithm on small size inputs The speedup is obtained by using an object oriented representation of the predicate calculus that avoids the need for pre and post processing instead making variable objects responsible for creating a substitution and for dealing with aliasing de Champeaux claims that the ability to add functionality to predicate calculus represented as programmatic objects provides opportunities for optimizing other logic operations as well br The following algorithm is commonly presented and originates from Martelli Montanari Given a finite set br br br br G br br br br s br br br br br br br t br br br br br br br br br br br s br br n br br br br br t br br n br br br br br br displaystyle G s doteq t s n doteq t n br br of potential equations br the algorithm applies rules to transform it to an equivalent set of equations of the form br x u xm um br where x xm are distinct variables and u um are terms containing none of the xi br A set of this form can be read as a substitution br If there is no solution the algorithm terminates with other authors use or fail in that case br The operation of substituting all occurrences of variable x in problem G with term t is denoted G x t br For simplicity constant symbols are regarded as function symbols having zero arguments br br br Occurs check br br An attempt to unify a variable x with a term containing x as a strict subterm x f x would lead to an infinite term as solution for x since x would occur as a subterm of itself br In the set of finite first order terms as defined above the equation x f x has no solution hence the eliminate rule may only be applied if x vars t br Since that additional check called occurs check slows down the algorithm it is omitted e g in most Prolog systems br From a theoretical point of view omitting the check amounts to solving equations over infinite trees see Unification of infinite terms below br br br Proof of termination br For the proof of termination of the algorithm consider a triple br br br br br br n br br v br a br r br br br br br n br br l br h br s br br br br br n br br e br q br n br br br br br br displaystyle langle n var n lhs n eqn rangle br br br where nvar is the number of variables that occur more than once in the equation set nlhs is the number of function symbols and constants br on the left hand sides of potential equations and neqn is the number of equations br When rule eliminate is applied nvar decreases since x is eliminated from G and kept only in x t br Applying any other rule can never increase nvar again br When rule decompose conflict or swap is applied nlhs decreases since at least the left hand side s outermost f disappears br Applying any of the remaining rules delete or check can t increase nlhs but decreases neqn br Hence any rule application decreases the triple br br br br br br n br br v br a br r br br br br br n br br l br h br s br br br br br n br br e br q br n br br br br br br displaystyle langle n var n lhs n eqn rangle br br with respect to the lexicographical order which is possible only a finite number of times br Conor McBride observes that by expressing the structure which unification exploits in a dependently typed language such as Epigram Robinson s unification algorithm can be made recursive on the number of variables in which case a separate termination proof becomes unnecessary br br br Examples of syntactic unification of first order terms br In the Prolog syntactical convention a symbol starting with an upper case letter is a variable name a symbol that starts with a lowercase letter is a function symbol the comma is used as the logical and operator br For mathematical notation x y z are used as variables f g as function symbols and a b as constants br br The most general unifier of a syntactic first order unification problem of size n may have a size of n For example the problem br br br br br br br a br br z br br br y br br br x br br br w br br w br br br x br br br y br br br z br br a br br br br br br displaystyle a z y x w doteq w x y z a br br has the most general unifier br br br br br z br br a br br y br br a br br a br br x br br br a br br a br br br br a br br a br br br w br br br br a br br a br br br br a br br a br br br br br br a br br a br br br br a br br a br br br br br br displaystyle z mapsto a y mapsto a a x mapsto a a a a w mapsto a a a a a a a a br br cf picture In order to avoid exponential time complexity caused by such blow up advanced unification algorithms work on directed acyclic graphs dags rather than trees br br br Application unification in logic programming br The concept of unification is one of the main ideas behind logic programming Specifically unification is a basic building block of resolution a rule of inference for determining formula satisfiability In Prolog the equality symbol implies first order syntactic unification It represents the mechanism of binding the contents of variables and can be viewed as a kind of one time assignment br In Prolog br br A variable can be unified with a constant a term or another variable thus effectively becoming its alias In many modern Prolog dialects and in first order logic a variable cannot be unified with a term that contains it this is the so called occurs check br Two constants can be unified only if they are identical br Similarly a term can be unified with another term if the top function symbols and arities of the terms are identical and if the parameters can be unified simultaneously Note that this is a recursive behavior br Most operations including are not evaluated by So for example is not satisfiable because they are syntactically different The use of integer arithmetic constraints introduces a form of E unification for which these operations are interpreted and evaluated br br br Application type inference br Type inference algorithms are typically based on unification particularly Hindley Milner type inference which is used by the functional languages Haskell and ML For example when attempting to infer the type of the Haskell expression True x the compiler will use the type a a a of the list construction function the type Bool of the first argument True and the type Char of the second argument x The polymorphic type variable a will be unified with Bool and the second argument a will be unified with Char a cannot be both Bool and Char at the same time therefore this expression is not correctly typed br Like for Prolog an algorithm for type inference can be given br br Any type variable unifies with any type expression and is instantiated to that expression A specific theory might restrict this rule with an occurs check br Two type constants unify only if they are the same type br Two type constructions unify only if they are applications of the same type constructor and all of their component types recursively unify br br br Application Feature Structure Unification br br Unification has been used in different research areas of computational linguistics br br br Order sorted unification br Order sorted logic allows one to assign a sort or type to each term and to declare a sort s a subsort of another sort s commonly written as s s For example when re soning about biological creatures it is useful to declare a sort dog to be a subsort of a sort animal Wherever a term of some sort s is required a term of any subsort of s may be supplied instead br For example assuming a function declaration mother animal animal and a constant declaration lassie dog the term mother lassie is perfectly valid and has the sort animal In order to supply the information that the mother of a dog is a dog in turn another declaration mother dog dog may be issued this is called function overloading similar to overloading in programming languages br Walther gave a unification algorithm for terms in order sorted logic requiring for any two declared sorts s s their intersection s s to be declared too if x and x is a variable of sort s and s respectively the equation x x has the solution x x x x where x s s br br After incorporating this algorithm into a clause based automated theorem prover he could solve a benchmark problem by translating it into order sorted logic thereby boiling it down an order of magnitude as many unary predicates turned into sorts br Smolka generalized order sorted logic to allow for parametric polymorphism br br In his framework subsort declarations are propagated to complex type expressions br As a programming example a parametric sort list X may be declared with X being a type parameter as in a C template and from a subsort declaration int float the relation list int list float is automatically inferred meaning that each list of integers is also a list of floats br Schmidt Schau generalized order sorted logic to allow for term declarations br br As an example assuming subsort declarations even int and odd int a term declaration like i int i i even allows to declare a property of integer addition that could not be expressed by ordinary overloading br br br Unification of infinite terms br br Background on infinite trees br br B Courcelle Fundamental Properties of Infinite Trees Theoret Comput Sci doi br Michael J Maher Jul Complete Axiomatizations of the Algebras of Finite Rational and Infinite Trees Proc IEEE rd Annual Symp on Logic in Computer Science Edinburgh pp br Joxan Jaffar Peter J Stuckey Semantics of Infinite Tree Logic Programming Theoretical Computer Science doi br Unification algorithm Prolog II br br A Colmerauer K L Clark S A Tarnlund eds Prolog and Infinite Trees Academic Press br Alain Colmerauer Equations and Inequations on Finite and Infinite Trees In ICOT ed Proc Int Conf on Fifth Generation Computer Systems pp br Applications br br Francis Giannesini Jacques Cohen Parser Generation and Grammar Manipulation using Prolog s Infinite Trees Journal of Logic Programming doi X br br br E unification br E unification is the problem of finding solutions to a given set of equations br taking into account some equational background knowledge E br The latter is given as a set of universal equalities br For some particular sets E equation solving algorithms a k a E unification algorithms have been devised br for others it has been proven that no such algorithms can exist br For example if a and b are distinct constants br the equation br br br br x br br a br br y br br b br br br displaystyle x a doteq y b br br has no solution br with respect to purely syntactic unification br where nothing is known about the operator br br br br br br br displaystyle br br br However if the br br br br br br br displaystyle br br is known to be commutative br then the substitution x b y a solves the above equation br since br br The background knowledge E could state the commutativity of br br br br br br br displaystyle br br by the universal equality br br br br br u br br v br br v br br u br br br displaystyle u v v u br br for all u v br br br Particular background knowledge sets E br br It is said that unification is decidable for a theory if a unification algorithm has been devised for it that terminates for any input problem br It is said that unification is semi decidable for a theory if a unification algorithm has been devised for it that terminates for any solvable input problem but may keep searching forever for solutions of an unsolvable input problem br Unification is decidable for the following theories br br A br A C br A C I br A C Nl br A I br A Nl Nr monoid br C br Boolean rings br Abelian groups even if the signature is expanded by arbitrary additional symbols but not axioms br K modal algebras br Unification is semi decidable for the following theories br br A Dl Dr br A C Dl br Commutative rings br br br One sided paramodulation br If there is a convergent term rewriting system R available for E br the one sided paramodulation algorithm br can be used to enumerate all solutions of given equations br br Starting with G being the unification problem to be solved and S being the identity substitution rules are applied nondeterministically until the empty set appears as the actual G in which case the actual S is a unifying substitution Depending on the order the paramodulation rules are applied on the choice of the actual equation from G and on the choice of R s rules in mutate different computations paths are possible Only some lead to a solution while others end at a G where no further rule is applicable e g G f g br br For an example a term rewrite system R is used defining the append operator of lists built from cons and nil where cons x y is written in infix notation as x y for brevity e g app a b nil c d nil a app b nil c d nil a b app nil c d nil a b c d nil demonstrates the concatenation of the lists a b nil and c d nil employing the rewrite rule and The equational theory E corresponding to R is the congruence closure of R both viewed as binary relations on terms br For example app a b nil c d nil a b c d nil app a b c d nil nil The paramodulation algorithm enumerates solutions to equations with respect to that E when fed with the example R br A successful example computation path for the unification problem app x app y x a a nil is shown below To avoid variable name clashes rewrite rules are consistently renamed each time before their use by rule mutate v v are computer generated variable names for this purpose In each line the chosen equation from G is highlighted in red Each time the mutate rule is applied the chosen rewrite rule or is indicated in parentheses From the last line the unifying substitution S y nil x a nil can be obtained In fact br app x app y x y nil x a nil app a nil app nil a nil app a nil a nil a app nil a nil a a nil solves the given problem br A second successful computation path obtainable by choosing mutate mutate mutate mutate leads to the substitution S y a a nil x nil it is not shown here No other path leads to a success br br br Narrowing br br If R is a convergent term rewriting system for E br an approach alternative to the previous section consists in successive application of narrowing steps br this will eventually enumerate all solutions of a given equation br A narrowing step cf picture consists in br br choosing a nonvariable subterm of the current term br syntactically unifying it with the left hand side of a rule from R and br replacing the instantiated rule s right hand side into the instantiated term br Formally if l r is a renamed copy of a rewrite rule from R having no variables in common with a term s and the subterm s p is not a variable and is unifiable with l via the mgu then s can be narrowed to the term t s r p i e to the term s with the subterm at p replaced by r The situation that s can be narrowed to t is commonly denoted as s t br Intuitively a sequence of narrowing steps t t tn can be thought of as a sequence of rewrite steps t t tn but with the initial term t being further and further instantiated as necessary to make each of the used rules applicable br The above example paramodulation computation corresponds to the following narrowing sequence indicating instantiation here br br The last term v v nil can be syntactically unified with the original right hand side term a a nil br The narrowing lemma ensures that whenever an instance of a term s can be rewritten to a term t by a convergent term rewriting system then s and t can be narrowed and rewritten to a term s and t respectively such that t is an instance of s br Formally whenever s t holds for some substitution then there exist terms s t such that s s and t t and s t for some substitution br br br Higher order unification br br Many applications require one to consider the unification of typed lambda terms instead of first order terms Such unification is often called higher order unification Higher order unification is undecidable and such unification problems do not have most general unifiers For example the unification problem f a b a d b a c where the only variable is f has the br solutions f x y z d y x c f x y z d y z c br f x y z d y a c f x y z d b x c br f x y z d b z c and f x y z d b a c A well studied branch of higher order unification is the problem of unifying simply typed lambda terms modulo the equality determined by conversions G rard Huet gave a semi decidable pre unification algorithm that allows a systematic search of the space of unifiers generalizing the unification algorithm of Martelli Montanari with rules for terms containing higher order variables that seems to work sufficiently well in practice Huet and Gilles Dowek have written articles surveying this topic br Several subsets of higher order unification are well behaved in that they are decidable and have a most general unifier for solvable problems One such subset is the previously described first order terms Higher order pattern unification due to Dale Miller is another such subset The higher order logic programming languages Prolog and Twelf have switched from full higher order unification to implementing only the pattern fragment surprisingly pattern unification is sufficient for almost all programs if each non pattern unification problem is suspended until a subsequent substitution puts the unification into the pattern fragment A superset of pattern unification called functions as constructors unification is also well behaved The Zipperposition theorem prover has an algorithm integrating these well behaved subsets into a full higher order unification algorithm br In computational linguistics one of the most influential theories of elliptical construction is that ellipses are represented by free variables whose values are then determined using Higher Order Unification For instance the semantic representation of Jon likes Mary and Peter does too is like j m R p and the value of R the semantic representation of the ellipsis is determined by the equation like j m R j The process of solving such equations is called Higher Order Unification br Wayne Snyder gave a generalization of both higher order unification and E unification i e an algorithm to unify lambda terms modulo an equational theory br br br See also br Rewriting br Admissible rule br Explicit substitution in lambda calculus br Mathematical equation solving br Dis unification solving inequations between symbolic expression br Anti unification computing a least general generalization lgg of two terms dual to computing a most general instance mgu br Subsumption lattice a lattice having unification as meet and anti unification as join br Ontology alignment use unification with semantic equivalence br br br Notes br br br br br br Further reading br Franz Baader and Wayne Snyder Unification Theory Archived at the Wayback Machine In John Alan Robinson and Andrei Voronkov editors Handbook of Automated Reasoning volume I pages Elsevier Science Publishers br Gilles Dowek Higher order Unification and Matching Archived at the Wayback Machine In Handbook of Automated Reasoning br Franz Baader and Tobias Nipkow Term Rewriting and All That Cambridge University Press br Franz Baader and J rg H Siekmann Unification Theory In Handbook of Logic in Artificial Intelligence and Logic Programming br Jean Pierre Jouannaud and Claude Kirchner Solving Equations in Abstract Algebras A Rule Based Survey of Unification In Computational Logic Essays in Honor of Alan Robinson br Nachum Dershowitz and Jean Pierre Jouannaud Rewrite Systems in Jan van Leeuwen ed Handbook of Theoretical Computer Science volume B Formal Models and Semantics Elsevier pp br J rg H Siekmann Unification Theory In Claude Kirchner editor Unification Academic Press br Kevin Knight Mar Unification A Multidisciplinary Survey PDF ACM Computing Surveys CiteSeerX doi S CID br G rard Huet and Derek C Oppen Equations and Rewrite Rules A Survey Technical report Stanford University br Raulefs Peter Siekmann J rg Szab P Unvericht E A short survey on the state of the art in matching and unification problems ACM SIGSAM Bulletin doi S CID br Claude Kirchner and H l ne Kirchner Rewriting Solving Proving In preparation 