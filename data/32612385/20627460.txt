title: Kind (type theory)
id: 20627460
In the area of mathematical logic and computer science known as type theory a kind is the type of a type constructor or less commonly the type of a higher order type operator A kind system is essentially a simply typed lambda calculus one level up endowed with a primitive type denoted br br br br br br br displaystyle br br and called type which is the kind of any data type which does not need any type parameters br A kind is sometimes confusingly described as the type of a data type but it is actually more of an arity specifier Syntactically it is natural to consider polymorphic types to be type constructors thus non polymorphic types to be nullary type constructors But all nullary constructors thus all monomorphic types have the same simplest kind namely br br br br br br br displaystyle br br br Since higher order type operators are uncommon in programming languages in most programming practice kinds are used to distinguish between data types and the types of constructors which are used to implement parametric polymorphism Kinds appear either explicitly or implicitly in languages whose type systems account for parametric polymorphism in a programmatically accessible way such as C Haskell and Scala br br br Examples br br br br br br br br displaystyle br br pronounced type is the kind of all data types seen as nullary type constructors and also called proper types in this context This normally includes function types in functional programming languages br br br br br br br br br br displaystyle rightarrow br br is the kind of a unary type constructor e g of a list type constructor br br br br br br br br br br br br displaystyle rightarrow rightarrow br br is the kind of a binary type constructor via currying e g of a pair type constructor and also that of a function type constructor not to be confused with the result of its application which itself is a function type thus of kind br br br br br br br displaystyle br br br br br br br br br br br br br br br br displaystyle rightarrow rightarrow br br is the kind of a higher order type operator from unary type constructors to proper types br br br Kinds in Haskell br Note Haskell documentation uses the same arrow for both function types and kinds br The kind system of Haskell includes exactly two kinds br br br br br br br br displaystyle br br pronounced type is the kind of all data types br br br br br br k br br br br br br br k br br br br br br br displaystyle k rightarrow k br br is the kind of a unary type constructor which takes a type of kind br br br br br k br br br br br br br displaystyle k br br and produces a type of kind br br br br br k br br br br br br br displaystyle k br br br An inhabited type as proper types are called in Haskell is a type which has values For instance ignoring type classes which complicate the picture is a value of type Int while is a value of type Int list of Ints Therefore Int and Int have kind br br br br br br br displaystyle br br but so does any function type for instance Int Bool or even Int Int Bool br A type constructor takes one or more type arguments and produces a data type when enough arguments are supplied i e it supports partial application thanks to currying This is how Haskell achieves parametric types For instance the type list is a type constructor it takes a single argument to specify the type of the elements of the list Hence Int list of Ints Float list of Floats and even Int list of lists of Ints are valid applications of the type constructor Therefore is a type of kind br br br br br br br br br displaystyle rightarrow br br Because Int has kind br br br br br br br displaystyle br br applying to it results in Int of kind br br br br br br br displaystyle br br The tuple constructor has kind br br br br br br br br br br br displaystyle rightarrow rightarrow br br the tuple constructor has kind br br br br br br br br br br br br br displaystyle rightarrow rightarrow rightarrow br br and so on br br br Kind inference br Standard Haskell does not allow polymorphic kinds This is in contrast to parametric polymorphism on types which is supported in Haskell For instance in the following example br br the kind of z could be anything including br br br br br br br displaystyle br br but also br br br br br br br br br displaystyle rightarrow br br etc Haskell by default will always infer kinds to be br br br br br br br displaystyle br br unless the type explicitly indicates otherwise see below Therefore the type checker will reject the following use of Tree br br because the kind of br br br br br br br br br displaystyle rightarrow br br does not match the expected kind for z which is always br br br br br br br displaystyle br br br Higher order type operators are allowed however For instance br br has kind br br br br br br br br br br br br br br br displaystyle rightarrow rightarrow rightarrow br br i e unt is expected to be a unary data constructor which gets applied to its argument which must be a type and returns another type br GHC has the extension PolyKinds which together with KindSignatures allows polymorphic kinds For example br br Since GHC types and kinds are merged br br br See also br System F omega br Pure type system br br br 