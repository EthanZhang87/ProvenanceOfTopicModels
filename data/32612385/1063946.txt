title: Occurs check
id: 1063946
In computer science the occurs check is a part of algorithms for syntactic unification It causes unification of a variable V and a structure S to fail if S contains V br br br Application in theorem proving br In theorem proving unification without the occurs check can lead to unsound inference For example the Prolog goal br br br br br X br br f br br X br br br br displaystyle X f X br br br will succeed binding X to a cyclic structure which has no counterpart in the Herbrand universe br As another example br br without occurs check a resolution proof can be found for the non theorem br br br br br br br x br br y br br p br br x br br y br br br br br br y br br x br br p br br x br br y br br br br br displaystyle forall x exists y p x y rightarrow exists y forall x p x y br br the negation of that formula has the conjunctive normal form br br br br p br br X br br f br br X br br br br br p br br g br br Y br br br Y br br br br displaystyle p X f X land lnot p g Y Y br br with br br br br f br br br displaystyle f br br and br br br br g br br br displaystyle g br br denoting the Skolem function for the first and second existential quantifier respectively the literals br br br br p br br X br br f br br X br br br br br displaystyle p X f X br br and br br br br p br br g br br Y br br br Y br br br br displaystyle p g Y Y br br are unifiable without occurs check producing the refuting empty clause br br br Rational tree unification br Prolog implementations usually omit the occurs check for reasons of efficiency which can lead to circular data structures and looping br By not performing the occurs check the worst case complexity of unifying a term br br br br br br t br br br br br br br displaystyle t br br with term br br br br br t br br br br br br br displaystyle t br br br is reduced in many cases from br br br br br O br br br size br br br br t br br br br br br br br size br br br br t br br br br br br br br br displaystyle O text size t text size t br br br to br br br br br O br br br min br br br br size br br br br t br br br br br br br br size br br br br t br br br br br br br br br br displaystyle O text min text size t text size t br br br in the particular frequent case of variable term unifications runtime shrinks to br br br br br O br br br br br br displaystyle O br br br br Modern implementations based on Colmerauer s Prolog II br br use rational tree unification to avoid looping However it is difficult to keep the complexity time linear in the presence of cyclic terms Examples where Colmerauers algorithm becomes quadratic can be readily constructed but refinement proposals exist br See image for an example run of the unification algorithm given in Unification computer science A unification algorithm trying to solve the goal br br br br c br o br n br s br br x br br y br br br br br br br br br br br br br br c br o br n br s br br br br c br o br n br s br br x br br c br o br n br s br br br br y br br br br br br displaystyle cons x y stackrel cons cons x cons y br br however without the occurs check rule named check there applying rule eliminate instead leads to a cyclic graph i e an infinite term in the last step br br br Sound unification br ISO Prolog implementations have the built in predicate unify with occurs check for sound unification but are free to use unsound or even looping algorithms when unification is invoked otherwise provided the algorithm works correctly for all cases that are not subject to occurs check NSTO The built in acyclic term serves to check the finiteness of terms br Implementations offering sound unification for all unifications are Qu Prolog and Strawberry Prolog and optionally via a runtime flag XSB SWI Prolog Tau Prolog Trealla Prolog and Scryer Prolog A variety br of optimizations can render sound unification feasible for common cases br br br See also br W P Weijland Semantics for Logic Programs without Occur Check Theoretical Computer Science doi m br br br Notes br br br 