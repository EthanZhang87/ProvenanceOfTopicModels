title: Simply typed lambda calculus
id: 1986011
The simply typed lambda calculus br br br br br br br br br br br br displaystyle lambda to br br a form br of type theory is a typed interpretation of the lambda calculus with only one type constructor br br br br br br br displaystyle to br br that builds function types It is the canonical and simplest example of a typed lambda calculus The simply typed lambda calculus was originally introduced by Alonzo Church in as an attempt to avoid paradoxical use of the untyped lambda calculus br The term simple type is also used to refer to extensions of the simply typed lambda calculus with constructs such as products coproducts or natural numbers System T or even full recursion like PCF In contrast systems that introduce polymorphic types like System F or dependent types like the Logical Framework are not considered simply typed The simple types except for full recursion are still considered simple because the Church encodings of such structures can be done using only br br br br br br br displaystyle to br br and suitable type variables while polymorphism and dependency cannot br br br Syntax br In the s Alonzo Church sought to use the logistic method his lambda calculus as a formal language based on symbolic expressions consisted of a denumerably infinite series of axioms and variables but also a finite set of primitive symbols denoting abstraction and scope as well as four constants negation disjunction universal quantification and selection respectively and also a finite set of rules I to VI This finite set of rules included rule V modus ponens as well as IV and VI for substitution and generalization respectively Rules I to III are known as alpha beta and eta conversion in the lambda calculus Church sought to use English only as a syntax language that is a metamathematical language for describing symbolic expressions with no interpretations br In Church settled on a subscript notation for denoting the type in a symbolic expression In his presentation Church used only two base types br br br br o br br br displaystyle o br br for the type of propositions and br br br br br br br displaystyle iota br br for the type of individuals The type br br br br o br br br displaystyle o br br has no term constants whereas br br br br br br br displaystyle iota br br has one term constant Frequently the calculus with only one base type usually br br br br o br br br displaystyle o br br is considered The Greek letter subscripts br br br br br br br br br displaystyle alpha beta br br etc denote type variables the parenthesized subscripted br br br br br br br br br br displaystyle alpha beta br br denotes the function type br br br br br br br br br displaystyle beta to alpha br br Church p used arrow or br br br br br br br displaystyle to br br to denote stands for or is an abbreviation for br By the s stand alone arrow notation was in use for example in this article non subscripted symbols br br br br br br br displaystyle sigma br br and br br br br br br br displaystyle tau br br can range over types The infinite number of axioms were then seen to be a consequence of applying rules I to VI to the types see Peano axioms Informally the function type br br br br br br br br br displaystyle sigma to tau br br refers to the type of functions that given an input of type br br br br br br br displaystyle sigma br br produce an output of type br br br br br br br displaystyle tau br br br By convention br br br br br br br displaystyle to br br associates to the right br br br br br br br br br br br displaystyle sigma to tau to rho br br is read as br br br br br br br br br br br br br displaystyle sigma to tau to rho br br br To define the types a set of base types br br br br B br br br displaystyle B br br must first be defined These are sometimes called atomic types or type constants With this fixed the syntax of types is br br br br br br br br br br br T br br br w br h br e br r br e br br br T br br B br br br displaystyle tau tau to tau mid T quad mathrm where quad T in B br br br For example br br br br B br br br a br br b br br br br displaystyle B a b br br generates an infinite set of types starting with br br br br a br br br displaystyle a br br br br br br b br br br displaystyle b br br br br br br a br br a br br br displaystyle a to a br br br br br br a br br b br br br displaystyle a to b br br br br br br b br br b br br br displaystyle b to b br br br br br br b br br a br br br displaystyle b to a br br br br br br a br br br a br br a br br br br displaystyle a to a to a br br br br br br br b br br a br br br br a br br b br br br br displaystyle b to a to a to b br br br A set of term constants is also fixed for the base types For example it might be assumed that one of the base types is nat and its term constants could be the natural numbers br The syntax of the simply typed lambda calculus is essentially that of the lambda calculus itself The term br br br br x br br br br br br br br br displaystyle x mathbin tau br br denotes that the variable br br br br x br br br displaystyle x br br is of type br br br br br br br displaystyle tau br br The term syntax in Backus Naur form is variable reference abstractions application or constant br br br br br e br br x br br br x br br br br br br br br e br br e br br e br br c br br br displaystyle e x mid lambda x mathbin tau e mid e e mid c br br br where br br br br c br br br displaystyle c br br is a term constant A variable reference br br br br x br br br displaystyle x br br is bound if it is inside of an abstraction binding br br br br x br br br displaystyle x br br A term is closed if there are no unbound variables br In comparison the syntax of untyped lambda calculus has no such typing or term constants br br br br br e br br x br br br x br br e br br e br br e br br br displaystyle e x mid lambda x e mid e e br br br Whereas in typed lambda calculus every abstraction i e function must specify the type of its argument br br br Typing rules br To define the set of well typed lambda terms of a given type one defines a typing relation between terms and types First one introduces typing contexts or typing environments br br br br br br br br br br br displaystyle Gamma Delta dots br br which are sets of typing assumptions A typing assumption has the form br br br br x br br br br br br br br br displaystyle x mathbin sigma br br meaning variable br br br br x br br br displaystyle x br br has type br br br br br br br displaystyle sigma br br br The typing relation br br br br br br e br br br br br br br br br displaystyle Gamma vdash e mathbin sigma br br indicates that br br br br e br br br displaystyle e br br is a term of type br br br br br br br displaystyle sigma br br in context br br br br br br br displaystyle Gamma br br In this case br br br br e br br br displaystyle e br br is said to be well typed having type br br br br br br br displaystyle sigma br br Instances of the typing relation are called typing judgements The validity of a typing judgement is shown by providing a typing derivation constructed using typing rules wherein the premises above the line allow us to derive the conclusion below the line Simply typed lambda calculus uses these rules br br In words br br If br br br br x br br br displaystyle x br br has type br br br br br br br displaystyle sigma br br in the context then br br br br x br br br displaystyle x br br has type br br br br br br br displaystyle sigma br br br Term constants have the appropriate base types br If in a certain context with br br br br x br br br displaystyle x br br having type br br br br br br br displaystyle sigma br br br br br br e br br br displaystyle e br br has type br br br br br br br displaystyle tau br br then in the same context without br br br br x br br br displaystyle x br br br br br br br x br br br br br br br br br e br br br displaystyle lambda x mathbin sigma e br br has type br br br br br br br br br displaystyle sigma to tau br br br If in a certain context br br br br br e br br br br br br br displaystyle e br br has type br br br br br br br br br displaystyle sigma to tau br br and br br br br br e br br br br br br br displaystyle e br br has type br br br br br br br displaystyle sigma br br then br br br br br e br br br br br br br e br br br br br br br displaystyle e e br br has type br br br br br br br displaystyle tau br br br Examples of closed terms i e terms typable in the empty context are br br For every type br br br br br br br displaystyle tau br br a term br br br br br x br br br br br br br br x br br br br br br br br br br br displaystyle lambda x mathbin tau x mathbin tau to tau br br identity function I combinator br For types br br br br br br br br br displaystyle sigma tau br br a term br br br br br x br br br br br br br br br y br br br br br br br br x br br br br br br br br br br br br br displaystyle lambda x mathbin sigma lambda y mathbin tau x mathbin sigma to tau to sigma br br the K combinator and br For types br br br br br br br br br br br br br br br br br displaystyle tau tau tau br br a term br br br br br x br br br br br br br br br br br br br br br br br br br y br br br br br br br br br br br br br br z br br br br br br br br x br z br br y br z br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br displaystyle lambda x mathbin tau to tau to tau lambda y mathbin tau to tau lambda z mathbin tau xz yz tau to tau to tau to tau to tau to tau to tau br br the S combinator br These are the typed lambda calculus representations of the basic combinators of combinatory logic br Each type br br br br br br br displaystyle tau br br is assigned an order a number br br br br o br br br br br br displaystyle o tau br br For base types br br br br o br br T br br br br br br displaystyle o T br br for function types br br br br o br br br br br br br br br max br br br br o br br br br br br br o br br br br br br br displaystyle o sigma to tau mbox max o sigma o tau br br That is the order of a type measures the depth of the most left nested arrow Hence br br br br br o br br br br br br br br br br br br displaystyle o iota to iota to iota br br br br br br o br br br br br br br br br br br br br br displaystyle o iota to iota to iota br br br br Semantics br br br Intrinsic vs extrinsic interpretations br Broadly speaking there are two different ways of assigning meaning to the simply typed lambda calculus as to typed languages more generally variously called intrinsic vs extrinsic ontological vs semantical or Church style vs Curry style br An intrinsic semantics only assigns meaning to well typed terms or more precisely assigns meaning directly to typing derivations This has the effect that terms differing only by type annotations can nonetheless be assigned different meanings For example the identity term br br br br br x br br br br br br br br i br n br t br br br br br x br br br displaystyle lambda x mathbin mathtt int x br br on integers and the identity term br br br br br x br br br br br br br br b br o br o br l br br br br br x br br br displaystyle lambda x mathbin mathtt bool x br br on booleans may mean different things The classic intended interpretations br are the identity function on integers and the identity function on boolean values br In contrast an extrinsic semantics assigns meaning to terms regardless of typing as they would be interpreted in an untyped language In this view br br br br br x br br br br br br br br i br n br t br br br br br x br br br displaystyle lambda x mathbin mathtt int x br br and br br br br br x br br br br br br br br b br o br o br l br br br br br x br br br displaystyle lambda x mathbin mathtt bool x br br mean the same thing i e the same thing as br br br br br x br br br x br br br displaystyle lambda x x br br br The distinction between intrinsic and extrinsic semantics is sometimes associated with the presence or absence of annotations on lambda abstractions but strictly speaking this usage is imprecise It is possible to define an extrinsic semantics on annotated terms simply by ignoring the types i e through type erasure as it is possible to give an intrinsic semantics on unannotated terms when the types can be deduced from context i e through type inference The essential difference between intrinsic and extrinsic approaches is just whether the typing rules are viewed as defining the language or as a formalism for verifying properties of a more primitive underlying language Most of the different semantic interpretations discussed below can be seen through either an intrinsic or extrinsic perspective br br br Equational theory br The simply typed lambda calculus STLC has the same equational theory of equivalence as untyped lambda calculus but subject to type restrictions The equation for beta reduction br br br br br br br x br br br br br br br br br t br br br u br br br br br br br t br br x br br u br br br br displaystyle lambda x mathbin sigma t u beta t x u br br br holds in context br br br br br br br displaystyle Gamma br br whenever br br br br br br x br br br br br br br br t br br br br br br br br br displaystyle Gamma x mathbin sigma vdash t mathbin tau br br and br br br br br br u br br br br br br br br br displaystyle Gamma vdash u mathbin sigma br br while the equation for eta reduction br br br br br br x br br br br br br br br br t br br x br br br br br br br t br br br displaystyle lambda x mathbin sigma t x eta t br br br holds whenever br br br br br br t br br br br br br br br displaystyle Gamma vdash t sigma to tau br br and br br br br x br br br displaystyle x br br does not appear free in br br br br t br br br displaystyle t br br br The advantage of typed lambda calculus is that STLC allows potentially nonterminating computations to be cut short that is reduced br br br Operational semantics br Likewise the operational semantics of simply typed lambda calculus can be fixed as for the untyped lambda calculus using call by name call by value or other evaluation strategies As for any typed language type safety is a fundamental property of all of these evaluation strategies Additionally the strong normalization property described below implies that any evaluation strategy will terminate on all simply typed terms br br br Categorical semantics br The simply typed lambda calculus enriched with product types pairing and projection operators with br br br br br br br br displaystyle beta eta br br equivalence is the internal language of Cartesian closed categories CCCs as was first observed by Joachim Lambek Given any CCC the basic types of the corresponding lambda calculus are the objects and the terms are the morphisms Conversely the simply typed lambda calculus with product types and pairing operators over a collection of base types and given terms forms a CCC whose objects are the types and morphisms are equivalence classes of terms br There are typing rules for pairing projection and a unit term Given two terms br br br br s br br br br br br br br br displaystyle s mathbin sigma br br and br br br br t br br br br br br br br br displaystyle t mathbin tau br br the term br br br br br s br br t br br br br displaystyle s t br br has type br br br br br br br br br displaystyle sigma times tau br br Likewise if one has a term br br br br u br br br br br br br br br br br br br br br br br br br br br displaystyle u mathbin tau times tau br br then there are terms br br br br br br br br br br br u br br br br br br br br br br br br br br br displaystyle pi u mathbin tau br br and br br br br br br br br br br br u br br br br br br br br br br br br br br br displaystyle pi u mathbin tau br br where the br br br br br br br i br br br br br displaystyle pi i br br correspond to the projections of the Cartesian product The unit term of type written as br br br br br br br br displaystyle br br and vocalized as nil is the final object The equational theory is extended likewise so that one has br br br br br br br br br br br br s br br br br br br br br t br br br br br br br br br s br br br br br br br br br displaystyle pi s mathbin sigma t mathbin tau s mathbin sigma br br br br br br br br br br br br br s br br br br br br br br t br br br br br br br br br t br br br br br br br br br displaystyle pi s mathbin sigma t mathbin tau t mathbin tau br br br br br br br br br br br br br br u br br br br br br br br br br br br br br br br br br u br br br br br br br br br br br br u br br br br br br br br br br br displaystyle pi u mathbin sigma times tau pi u mathbin sigma times tau u mathbin sigma times tau br br br br br br t br br br br br br br br br br br br displaystyle t mathbin br br br This last is read as if t has type then it reduces to nil br The above can then be turned into a category by taking the types as the objects The morphisms br br br br br br br br br displaystyle sigma to tau br br are equivalence classes of pairs br br br br br x br br br br br br br br t br br br br br br br br br br displaystyle x mathbin sigma t mathbin tau br br where x is a variable of type br br br br br br br displaystyle sigma br br and t is a term of type br br br br br br br displaystyle tau br br having no free variables in it except for optionally x br The set of terms in the language is the closure of this set of terms under the operations of abstraction and application br This correspondence can be extended to include language homomorphisms and functors between the category of Cartesian closed categories and the category of simply typed lambda theories br Part of this correspondence can be extended to closed symmetric monoidal categories by using a linear type system br br br Proof theoretic semantics br The simply typed lambda calculus is closely related to the implicational fragment of propositional intuitionistic logic i e the implicational propositional calculus via the Curry Howard isomorphism terms correspond precisely to proofs in natural deduction and inhabited types are exactly the tautologies of this logic br From his logistic method Church p laid out an axiom schema p which Henkin filled in to show that type domains e g the natural numbers the real numbers etc Henkin p described how Church s logistic method could seek to provide a foundation for mathematics Peano arithmetic and real analysis via model theory br br br Alternative syntaxes br The presentation given above is not the only way of defining the syntax of the simply typed lambda calculus One alternative is to remove type annotations entirely so that the syntax is identical to the untyped lambda calculus while ensuring that terms are well typed via Hindley Milner type inference The inference algorithm is terminating sound and complete whenever a term is typable the algorithm computes its type More precisely it computes the term s principal type since often an unannotated term such as br br br br br x br br br x br br br displaystyle lambda x x br br may have more than one type br br br br br br i br n br t br br br br br br i br n br t br br br br br displaystyle mathtt int to mathtt int br br br br br br br br b br o br o br l br br br br br br b br o br o br l br br br br br displaystyle mathtt bool to mathtt bool br br etc which are all instances of the principal type br br br br br br br br br displaystyle alpha to alpha br br br Another alternative presentation of simply typed lambda calculus is based on bidirectional type checking which requires more type annotations than Hindley Milner inference but is easier to describe The type system is divided into two judgments representing both checking and synthesis written br br br br br br e br br br br br displaystyle Gamma vdash e Leftarrow tau br br and br br br br br br e br br br br br displaystyle Gamma vdash e Rightarrow tau br br respectively Operationally the three components br br br br br br br displaystyle Gamma br br br br br br e br br br displaystyle e br br and br br br br br br br displaystyle tau br br are all inputs to the checking judgment br br br br br br e br br br br br displaystyle Gamma vdash e Leftarrow tau br br whereas the synthesis judgment br br br br br br e br br br br br displaystyle Gamma vdash e Rightarrow tau br br only takes br br br br br br br displaystyle Gamma br br and br br br br e br br br displaystyle e br br as inputs producing the type br br br br br br br displaystyle tau br br as output These judgments are derived via the following rules br br Observe that rules are nearly identical to rules above except for the careful choice of checking or synthesis judgments These choices can be explained like so br br If br br br br x br br br br br br br br br displaystyle x mathbin sigma br br is in the context we can synthesize type br br br br br br br displaystyle sigma br br for br br br br x br br br displaystyle x br br br The types of term constants are fixed and can be synthesized br To check that br br br br br x br br br e br br br displaystyle lambda x e br br has type br br br br br br br br br displaystyle sigma to tau br br in some context we extend the context with br br br br x br br br br br br br br br displaystyle x mathbin sigma br br and check that br br br br e br br br displaystyle e br br has type br br br br br br br displaystyle tau br br br If br br br br br e br br br br br br br displaystyle e br br synthesizes type br br br br br br br br br displaystyle sigma to tau br br in some context and br br br br br e br br br br br br br displaystyle e br br checks against type br br br br br br br displaystyle sigma br br in the same context then br br br br br e br br br br br br br e br br br br br br br displaystyle e e br br synthesizes type br br br br br br br displaystyle tau br br br Observe that the rules for synthesis are read top to bottom whereas the rules for checking are read bottom to top Note in particular that we do not need any annotation on the lambda abstraction in rule because the type of the bound variable can be deduced from the type at which we check the function Finally we explain rules and as follows br br To check that br br br br e br br br displaystyle e br br has type br br br br br br br displaystyle tau br br it suffices to synthesize type br br br br br br br displaystyle tau br br br If br br br br e br br br displaystyle e br br checks against type br br br br br br br displaystyle tau br br then the explicitly annotated term br br br br br e br br br br br br br br br br displaystyle e mathbin tau br br synthesizes br br br br br br br displaystyle tau br br br br Because of these last two rules coercing between synthesis and checking it is easy to see that any well typed but unannotated term can be checked in the bidirectional system so long as we insert enough type annotations And in fact annotations are needed only at redexes br br br General observations br Given the standard semantics the simply typed lambda calculus is strongly normalizing every sequence of reductions eventually terminates This is because recursion is not allowed by the typing rules it is impossible to find types for fixed point combinators and the looping term br br br br br br br br x br br br x br br x br br br br x br br br x br br x br br br br displaystyle Omega lambda x x x lambda x x x br br Recursion can be added to the language by either having a special operator br br br br br br br f br i br x br br br br br br br br br displaystyle mathtt fix alpha br br of type br br br br br br br br br br br br br displaystyle alpha to alpha to alpha br br or adding general recursive types though both eliminate strong normalization br Unlike the untyped lambda calculus the simply typed lambda calculus is not Turing complete All programs in the simply typed lambda calculus halt For the untyped lambda calculus there are programs that do not halt and moreover there is no general decision procedure that can determine whether a program halts br br br Important results br Tait showed in that br br br br br br br displaystyle beta br br reduction is strongly normalizing As a corollary br br br br br br br br displaystyle beta eta br br equivalence is decidable Statman showed in that the normalisation problem is not elementary recursive a proof that was later simplified by Mairson The problem is known to be in the set br br br br br br br E br br br br br br br br br displaystyle mathcal E br br of the Grzegorczyk hierarchy A purely semantic normalisation proof see normalisation by evaluation was given by Berger and Schwichtenberg in br The unification problem for br br br br br br br br displaystyle beta eta br br equivalence is undecidable Huet showed in that rd order unification is undecidable and this was improved upon by Baxter in then by Goldfarb in by showing that nd order unification is already undecidable A proof that higher order matching unification where only one term contains existential variables is decidable was announced by Colin Stirling in and a full proof was published in br We can encode natural numbers by terms of the type br br br br br o br br o br br br br o br br o br br br br displaystyle o to o to o to o br br Church numerals Schwichtenberg showed in that in br br br br br br br br br br br br displaystyle lambda to br br exactly the extended polynomials are representable as functions over Church numerals these are roughly the polynomials closed up under a conditional operator br A full model of br br br br br br br br br br br br displaystyle lambda to br br is given by interpreting base types as sets and function types by the set theoretic function space Friedman showed in that this interpretation is complete for br br br br br br br br displaystyle beta eta br br equivalence if the base types are interpreted by infinite sets Statman showed in that br br br br br br br br displaystyle beta eta br br equivalence is the maximal equivalence that is typically ambiguous i e closed under type substitutions Statman s Typical Ambiguity Theorem A corollary of this is that the finite model property holds i e finite sets are sufficient to distinguish terms that are not identified by br br br br br br br br displaystyle beta eta br br equivalence br Plotkin introduced logical relations in to characterize the elements of a model that are definable by lambda terms In Jung and Tiuryn showed that a general form of logical relation Kripke logical relations with varying arity exactly characterizes lambda definability Plotkin and Statman conjectured that it is decidable whether a given element of a model generated from finite sets is definable by a lambda term Plotkin Statman conjecture The conjecture was shown to be false by Loader in br br br Notes br br br br H Barendregt Lambda Calculi with Types Handbook of Logic in Computer Science Volume II Oxford University Press ISBN br br br External links br Loader Ralph February Notes on Simply Typed Lambda Calculus br Church s Type Theory entry in the Stanford Encyclopedia of Philosophy