title: Hindleyâ€“Milner type system
id: 32612385
A Hindley Milner HM type system is a classical type system for the lambda calculus with parametric polymorphism It is also known as Damas Milner or Damas Hindley Milner It was first described by J Roger Hindley and later rediscovered by Robin Milner Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis br Among HM s more notable properties are its completeness and its ability to infer the most general type of a given program without programmer supplied type annotations or other hints Algorithm W is an efficient type inference method in practice and has been successfully applied on large code bases although it has a high theoretical complexity HM is preferably used for functional languages It was first implemented as part of the type system of the programming language ML Since then HM has been extended in various ways most notably with type class constraints like those in Haskell br br br Introduction br br As a type inference method Hindley Milner is able to deduce the types of variables expressions and functions from programs written in an entirely untyped style Being scope sensitive it is not limited to deriving the types only from a small portion of source code but rather from complete programs or modules Being able to cope with parametric types too it is core to the type systems of many functional programming languages It was first applied in this manner in the ML programming language br The origin is the type inference algorithm for the simply typed lambda calculus that was devised by Haskell Curry and Robert Feys in br In J Roger Hindley extended this work and proved that their algorithm always inferred the most general type br In Robin Milner independently of Hindley s work provided an equivalent algorithm Algorithm W br In Luis Damas finally proved that Milner s algorithm is complete and extended it to support systems with polymorphic references br br br Monomorphism vs polymorphism br br In the simply typed lambda calculus types T are either atomic type constants or function types of form br br br br T br br T br br br displaystyle T rightarrow T br br Such types are monomorphic Typical examples are the types used in arithmetic values br br Number br add Number br add Number Number Number br br Contrary to this the untyped lambda calculus is neutral to typing at all and many of its functions can be meaningfully applied to all type of arguments The trivial example is the identity function br br id x x br which simply returns whatever value it is applied to Less trivial examples include parametric types like lists br While polymorphism in general means that operations accept values of more than one type the polymorphism used here is parametric One finds the notation of type schemes in the literature too emphasizing the parametric nature of the polymorphism Additionally constants may be typed with quantified type variables E g br br cons forall a a List a List a br nil forall a List a br id forall a a a br br Polymorphic types can become monomorphic by consistent substitution of their variables Examples of monomorphic instances are br br id String String br nil List Number br br More generally types are polymorphic when they contain type variables while types without them are monomorphic br Contrary to the type systems used for example in Pascal or C which only support monomorphic types HM is designed with emphasis on parametric polymorphism The successors of the languages mentioned like C focused on different types of polymorphism namely subtyping in connection with object oriented programming and overloading While subtyping is incompatible with HM a variant of systematic overloading is available in the HM based type system of Haskell br br br Let polymorphism br When extending the type inference for the simply typed lambda calculus towards polymorphism one has to define when deriving an instance of a value is admissible Ideally this would be allowed with any use of a bound variable as in br br id id id text x x br br Unfortunately type inference in polymorphic lambda calculus is not decidable Instead HM provides a let polymorphism of the form br br let id x x br in id id text br br restricting the binding mechanism in an extension of the expression syntax Only values bound in a let construct are subject to instantiation i e are polymorphic while the parameters in lambda abstractions are treated as being monomorphic br br br Overview br The remainder of this article proceeds as follows br br The HM type system is defined This is done by describing a deduction system that makes precise what expressions have what type if any br From there it works towards an implementation of the type inference method After introducing a syntax driven variant of the above deductive system it sketches an efficient implementation algorithm J appealing mostly to the reader s metalogical intuition br Because it remains open whether algorithm J indeed realises the initial deduction system a less efficient implementation algorithm W is introduced and its use in a proof is hinted br Finally further topics related to the algorithm are discussed br The same description of the deduction system is used throughout even for the two algorithms to make the various forms in which the HM method is presented directly comparable br br br The Hindley Milner type system br The type system can be formally described by syntax rules that fix a language for the expressions types etc The presentation here of such a syntax is not too formal in that it is written down not to study the surface grammar but rather the depth grammar and leaves some syntactical details open This form of presentation is usual Building on this typing rules are used to define how expressions and types are related As before the form used is a bit liberal br br br Syntax br br The expressions to be typed are exactly those of the lambda calculus extended with a let expression as shown in the adjacent table Parentheses can be used to disambiguate an expression The application is left binding and binds stronger than abstraction or the let in construct br Types are syntactically split into two groups monotypes and polytypes br br br Monotypes br Monotypes always designate a particular type Monotypes br br br br br br br displaystyle tau br br are syntactically represented as terms br Examples of monotypes include type constants like br br br br br br i br n br t br br br br br displaystyle mathtt int br br or br br br br br br s br t br r br i br n br g br br br br br displaystyle mathtt string br br and parametric types like br br br br br br M br a br p br br br S br e br t br br s br t br r br i br n br g br br br i br n br t br br br br br displaystyle mathtt Map Set string int br br The latter types are examples of applications of type functions for example from the set br br br br br br br br M br a br br p br br br br br br br S br e br br t br br br br br br br s br t br r br i br n br br g br br br br br br br i br n br br t br br br br br br br br br br br br br br br br br br displaystyle mathtt Map Set string int rightarrow br br br where the superscript indicates the number of type parameters The complete set of type functions br br br br C br br br displaystyle C br br is arbitrary in HM except that it must contain at least br br br br br br br br br br br br displaystyle rightarrow br br the type of functions It is often written in infix notation for convenience For example a function mapping integers to strings has type br br br br br br i br n br t br br br br br br s br t br r br i br n br g br br br br br displaystyle mathtt int rightarrow mathtt string br br Again parentheses can be used to disambiguate a type expression The application binds stronger than the infix arrow which is right binding br Type variables are admitted as monotypes Monotypes are not to be confused with monomorphic types which exclude variables and allow only ground terms br Two monotypes are equal if they have identical terms br br br Polytypes br Polytypes or type schemes are types containing variables bound by zero or more for all quantifiers e g br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha br br br A function with polytype br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha br br can map any value of the same type to itself br and the identity function is a value for this type br As another example br br br br br br br br br br S br e br t br br br br br br br br br i br n br t br br br br br displaystyle forall alpha mathtt Set alpha rightarrow mathtt int br br is the type of a function mapping all finite sets to integers A function which returns the cardinality of a set would be a value of this type br Quantifiers can only appear top level For instance a type br br br br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow forall alpha alpha br br is excluded by the syntax of types Also monotypes are included in the polytypes thus a type has the general form br br br br br br br br br br br br br br br br n br br br br br br n br br br br br displaystyle forall alpha dots forall alpha n tau n geq br br where br br br br br br br displaystyle tau br br is a monotype br Equality of polytypes is up to reordering the quantification and renaming the quantified variables br br br br br br br displaystyle alpha br br conversion Further quantified variables not occurring in the monotype can be dropped br br br Context and typing br To meaningfully bring together the still disjoint parts syntax expressions and types a third part is needed context Syntactically a context is a list of pairs br br br br x br br br br br displaystyle x sigma br br called assignments assumptions or bindings each pair stating that value variable br br br br br x br br i br br br br br displaystyle x i br br has type br br br br br br br i br br br br br br displaystyle sigma i br br All three parts combined give a typing judgment of the form br br br br br br br br e br br br br br displaystyle Gamma vdash e sigma br br stating that under assumptions br br br br br br br displaystyle Gamma br br the expression br br br br e br br br displaystyle e br br has type br br br br br br br displaystyle sigma br br br br br Free type variables br In a type br br br br br br br br br br br br br br br br n br br br br br br br displaystyle forall alpha dots forall alpha n tau br br the symbol br br br br br br br displaystyle forall br br is the quantifier binding the type variables br br br br br br br i br br br br br displaystyle alpha i br br in the monotype br br br br br br br displaystyle tau br br The variables br br br br br br br i br br br br br displaystyle alpha i br br are called quantified and any occurrence of a quantified type variable in br br br br br br br displaystyle tau br br is called bound and all unbound type variables in br br br br br br br displaystyle tau br br are called free Additionally to the quantification br br br br br br br displaystyle forall br br in polytypes type variables can also be bound by occurring in the context but with the inverse effect on the right hand side of the br br br br br br br displaystyle vdash br br Such variables then behave like type constants there Finally a type variable may legally occur unbound in a typing in which case they are implicitly all quantified br The presence of both bound and unbound type variables is a bit uncommon in programming languages Often all type variables are implicitly treated all quantified For instance one does not have clauses with free variables in Prolog Likewise in Haskell where all type variables implicitly occur quantified i e a Haskell type a a means br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha br br here Related and also very uncommon is the binding effect of the right hand side br br br br br br br displaystyle sigma br br of the assignments br Typically the mixture of both bound and unbound type variables originate from the use of free variables in an expression The constant function K br br br br br x br br br y br br x br br br displaystyle lambda x lambda y x br br provides an example It has the monotype br br br br br br br br br br br displaystyle alpha rightarrow beta rightarrow alpha br br One can force polymorphism by br br br br br l br e br t br br br k br br br x br br br br l br e br t br br br f br br br y br br x br br br i br n br br br f br br br br i br n br br br k br br br displaystyle mathbf let k lambda x mathbf let f lambda y x mathbf in f mathbf in k br br Herein br br br br f br br br displaystyle f br br has the type br br br br br br br br br br br br displaystyle forall gamma gamma rightarrow alpha br br The free monotype variable br br br br br br br displaystyle alpha br br originates from the type of the variable br br br br x br br br displaystyle x br br bound in the surrounding scope br br br br k br br br displaystyle k br br has the type br br br br br br br br br br br br br br br br displaystyle forall alpha forall beta alpha rightarrow beta rightarrow alpha br br One could imagine the free type variable br br br br br br br displaystyle alpha br br in the type of br br br br f br br br displaystyle f br br be bound by the br br br br br br br br displaystyle forall alpha br br in the type of br br br br k br br br displaystyle k br br But such a scoping cannot be expressed in HM Rather the binding is realized by the context br br br Type order br br Polymorphism means that one and the same expression can have perhaps infinitely many types But in this type system these types are not completely unrelated but rather orchestrated by the parametric polymorphism br As an example the identity br br br br br x br br x br br br displaystyle lambda x x br br can have br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha br br as its type as well as br br br br br br br string br br br br br br string br br br br br displaystyle texttt string rightarrow texttt string br br or br br br br br br int br br br br br br int br br br br br displaystyle texttt int rightarrow texttt int br br and many others but not br br br br br br int br br br br br br string br br br br br displaystyle texttt int rightarrow texttt string br br The most general type for this function is br br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha br br while the br others are more specific and can be derived from the general one by consistently br replacing another type for the type parameter i e the quantified br variable br br br br br br br displaystyle alpha br br The counter example fails because the br replacement is not consistent br The consistent replacement can be made formal by applying a substitution br br br br S br br br br br br br a br br i br br br br br br br i br br br br br br br br br br br br displaystyle S left a i mapsto tau i dots right br br to the term of a type br br br br br br br displaystyle tau br br written br br br br S br br br br displaystyle S tau br br As the example suggests substitution is not only strongly related to an order that expresses that a type is more or less special but also with the all quantification which allows the substitution to be applied br br Formally in HM a type br br br br br br br br br br displaystyle sigma br br is more general than br br br br br br br displaystyle sigma br br formally br br br br br br br br br br br br displaystyle sigma sqsubseteq sigma br br if some quantified variable in br br br br br br br br br br displaystyle sigma br br is consistently substituted such that one gains br br br br br br br displaystyle sigma br br as shown in the side bar This order is part of the type definition of the type system br In our previous example applying the substitution br br br br S br br br br br br br br br string br br br br br br br br displaystyle S left alpha mapsto texttt string right br br would result in br br br br br br br br br br br br br string br br br br br br string br br br br br displaystyle forall alpha alpha rightarrow alpha sqsubseteq texttt string rightarrow texttt string br br br While substituting a monomorphic ground type for a quantified variable is br straight forward substituting a polytype has some pitfalls caused by the br presence of free variables Most particularly unbound variables must not be br replaced They are treated as constants here Additionally quantifications can only occur top level Substituting a parametric type br one has to lift its quantifiers The table on the right makes the rule precise br Alternatively consider an equivalent notation for the polytypes without br quantifiers in which quantified variables are represented by a different set of br symbols In such a notation the specialization reduces to plain consistent br replacement of such variables br The relation br br br br br br br displaystyle sqsubseteq br br is a partial order br and br br br br br br br br br br displaystyle forall alpha alpha br br is its smallest element br br br Principal type br While specialization of a type scheme is one use of the order it plays a br crucial second role in the type system Type inference with polymorphism br faces the challenge of summarizing all possible types an expression may have br The order guarantees that such a summary exists as the most general type br of the expression br br br Substitution in typings br The type order defined above can be extended to typings because the implied all quantification of typings enables consistent replacement br br br br br br br e br br br br br br S br br br e br br S br br br br displaystyle Gamma vdash e sigma quad Longrightarrow quad S Gamma vdash e S sigma br br br Contrary to the specialisation rule this is not part of the definition but like the implicit all quantification rather a consequence of the type rules defined next br Free type variables in a typing serve as placeholders for possible refinement The binding effect of the environment to free type br variables on the right hand side of br br br br br br br displaystyle vdash br br that prohibits their substitution in the specialisation rule is again br that a replacement has to be consistent and would need to include the whole typing br This article will discuss four different rule sets br br br br br br br br D br br br br br displaystyle vdash D br br declarative system br br br br br br br br S br br br br br displaystyle vdash S br br syntactical system br br br br br br br br J br br br br br displaystyle vdash J br br algorithm J br br br br br br br br W br br br br br displaystyle vdash W br br algorithm W br br br Deductive system br br The syntax of HM is carried forward to the syntax of the inference rules that form the body of the formal system by using the typings as judgments Each of the rules define what conclusion could be drawn from what premises Additionally to the judgments some extra conditions introduced above might be used as premises too br A proof using the rules is a sequence of judgments such that all premises are listed before a conclusion The examples below show a possible format of proofs From left to right each line shows the conclusion the br br br br br br br N br a br m br e br br br br br br displaystyle mathtt Name br br of the rule applied and the premises either by referring to an earlier line number if the premise is a judgment or by making the predicate explicit br br br Typing rules br See also Typing rules br br The side box shows the deduction rules of the HM type system One can roughly divide the rules into two groups br The first four rules br br br br br br br V br a br r br br br br br br displaystyle mathtt Var br br variable or function access br br br br br br br A br p br p br br br br br br displaystyle mathtt App br br application i e function call with one parameter br br br br br br br A br b br s br br br br br br displaystyle mathtt Abs br br abstraction i e function declaration and br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br variable declaration are centered around the syntax presenting one rule for each of the expression forms Their meaning is obvious at the first glance as they decompose each expression prove their sub expressions and finally combine the individual types found in the premises to the type in the conclusion br The second group is formed by the remaining two rules br br br br br br br I br n br s br t br br br br br br displaystyle mathtt Inst br br and br br br br br br br G br e br n br br br br br br displaystyle mathtt Gen br br br They handle specialization and generalization of types While the rule br br br br br br br I br n br s br t br br br br br br displaystyle mathtt Inst br br should be clear from the section on specialization above br br br br br br br G br e br n br br br br br br displaystyle mathtt Gen br br complements the former working in the opposite direction It allows generalization i e to quantify monotype variables not bound in the context br The following two examples exercise the rule system in action Since both the expression and the type are given they are a type checking use of the rules br Example A proof for br br br br br br br br D br br br i br d br br n br br br i br n br t br br br displaystyle Gamma vdash D id n int br br where br br br br br br i br d br br br br br br br br br br n br br i br n br t br br br displaystyle Gamma id forall alpha alpha rightarrow alpha n int br br br could be written br br br br br br br br br br br br br br br br br D br br br i br d br br br br br br br br br br br br br V br a br r br br br br br br br i br d br br br br br br br br br br br br br br br br br br br br br br br D br br br i br d br br i br n br t br br i br n br t br br br br br br I br n br s br t br br br br br br br br br br br br br br br br br br br i br n br t br br i br n br t br br br br br br br br br br br br br br D br br br n br br i br n br t br br br br br br V br a br r br br br br br br br n br br i br n br t br br br br br br br br br br br br br br br br D br br br i br d br br n br br br i br n br t br br br br br br A br p br p br br br br br br br br br br br br br br br br br br br br displaystyle begin array llll Gamma vdash D id forall alpha alpha rightarrow alpha mathtt Var id forall alpha alpha rightarrow alpha in Gamma Gamma vdash D id int rightarrow int mathtt Inst forall alpha alpha rightarrow alpha sqsubseteq int rightarrow int Gamma vdash D n int mathtt Var n int in Gamma Gamma vdash D id n int mathtt App end array br br br Example To demonstrate generalization br br br br br br br br D br br br br br br let br br br br i br d br br br x br br x br br br br in br br br br i br d br br br br br br br br br br br br displaystyle vdash D textbf let id lambda x x textbf in id forall alpha alpha rightarrow alpha br br br is shown below br br br br br br br br br br br br br x br br br br br br D br br br x br br br br br br br br V br a br r br br br br br br br x br br br br br br br x br br br br br br br br br br br br br br br br br br D br br br br x br br x br br br br br br br br br br A br b br s br br br br br br br br br br br br br br br br br i br d br br br br br br br br D br br br i br d br br br br br br br br br br V br a br r br br br br br br br i br d br br br br br br br br br i br d br br br br br br br br br br br br br br br br br br br br D br br br br br let br br br br i br d br br br x br br x br br br br in br br br br i br d br br br br br br br br br br br br L br e br t br br br br br br br br br br br br br br br br br br br br br br br br br D br br br br br let br br br br i br d br br br x br br x br br br br in br br br br i br d br br br br br br br br br br br br br br br G br e br n br br br br br br br br br br br br br br f br r br e br e br br br br br br br br br br br displaystyle begin array llll x alpha vdash D x alpha mathtt Var x alpha in left x alpha right vdash D lambda x x alpha rightarrow alpha mathtt Abs id alpha rightarrow alpha vdash D id alpha rightarrow alpha mathtt Var id alpha rightarrow alpha in left id alpha rightarrow alpha right vdash D textbf let id lambda x x textbf in id alpha rightarrow alpha mathtt Let vdash D textbf let id lambda x x textbf in id forall alpha alpha rightarrow alpha mathtt Gen alpha not in free epsilon end array br br br br Let polymorphism br Not visible immediately the rule set encodes a regulation under which circumstances a type might be generalized or not by a slightly varying use of mono and polytypes in the rules br br br br br br br A br b br s br br br br br br displaystyle mathtt Abs br br and br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br Remember that br br br br br br br displaystyle sigma br br and br br br br br br br displaystyle tau br br denote poly and monotypes respectively br In rule br br br br br br br A br b br s br br br br br br displaystyle mathtt Abs br br the value variable of the parameter of the function br br br br br x br br e br br br displaystyle lambda x e br br is added to the context with a monomorphic type through the premise br br br br br br br x br br br br br br D br br br e br br br br br br br br displaystyle Gamma x tau vdash D e tau br br while in the rule br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br the variable enters the environment in polymorphic form br br br br br br br x br br br br br br D br br br br e br br br br br br br br br displaystyle Gamma x sigma vdash D e tau br br Though in both cases the presence of br br br br x br br br displaystyle x br br in the context prevents the use of the generalisation rule for any free variable in the assignment this regulation forces the type of parameter br br br br x br br br displaystyle x br br in a br br br br br br br displaystyle lambda br br expression to remain monomorphic while in a let expression the variable could be introduced polymorphic making specializations possible br As a consequence of this regulation br br br br br f br br br f br br br br true br br br br f br br br br br br br br br br displaystyle lambda f f textrm true f textrm br br cannot be typed br since the parameter br br br br f br br br displaystyle f br br is in a monomorphic position while br br br br br br let br br br br f br br br x br br x br br br br in br br br br br f br br br br true br br br br f br br br br br br br br br br displaystyle textbf let f lambda x x textbf in f textrm true f textrm br br has type br br br br br b br o br o br l br br i br n br t br br br br displaystyle bool int br br because br br br br f br br br displaystyle f br br has been introduced in a let expression and is treated polymorphic therefore br br br Generalization rule br The generalisation rule is also worth for closer look Here the all quantification implicit in the premise br br br br br br br br D br br br e br br br br br displaystyle Gamma vdash D e sigma br br is simply moved to the right hand side of br br br br br br br D br br br br br displaystyle vdash D br br in the conclusion bound by an explicit universal quantifier This is possible since br br br br br br br displaystyle alpha br br does not occur free in the context Again while this makes the generalization rule plausible it is not really a consequence On the contrary the generalization rule is part of the definition of HM s type system and the implicit all quantification a consequence br br br An inference algorithm br Now that the deduction system of HM is at hand one could present an algorithm and validate it with respect to the rules br Alternatively it might be possible to derive it by taking a closer look on how the rules interact and proof are br formed This is done in the remainder of this article focusing on the possible decisions one can make while proving a typing br br br Degrees of freedom choosing the rules br Isolating the points in a proof where no decision is possible at all br the first group of rules centered around the syntax leaves no choice since br to each syntactical rule corresponds a unique typing rule which determines br a part of the proof while between the conclusion and the premises of these br fixed parts chains of br br br br br br br I br n br s br t br br br br br br displaystyle mathtt Inst br br and br br br br br br br G br e br n br br br br br br displaystyle mathtt Gen br br br could occur Such a chain could also exist between the conclusion of the br proof and the rule for topmost expression All proofs must have br the so sketched shape br Because the only choice in a proof with respect of rule selection are the br br br br br br br br I br n br s br t br br br br br br displaystyle mathtt Inst br br and br br br br br br br G br e br n br br br br br br displaystyle mathtt Gen br br chains the br form of the proof suggests the question whether it can be made more precise br where these chains might not be needed This is in fact possible and leads to a br variant of the rules system with no such rules br br br Syntax directed rule system br br A contemporary treatment of HM uses a purely syntax directed rule system due to br Clement br as an intermediate step In this system the specialization is located directly after the original br br br br br br br V br a br r br br br br br br displaystyle mathtt Var br br rule br and merged into it while the generalization becomes part of the br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br rule There the generalization is br also determined to always produce the most general type by introducing the function br br br br br br br br br br br br br br br br br displaystyle bar Gamma tau br br which quantifies br all monotype variables not bound in br br br br br br br displaystyle Gamma br br br Formally to validate that this new rule system br br br br br br br S br br br br br displaystyle vdash S br br is equivalent to the original br br br br br br br D br br br br br displaystyle vdash D br br one has br to show that br br br br br br br br D br br br br e br br br br br br br br S br br br br e br br br br br displaystyle Gamma vdash D e sigma Leftrightarrow Gamma vdash S e sigma br br which decomposes into two sub proofs br br br br br br br br br D br br br br e br br br br br br br br S br br br br e br br br br br displaystyle Gamma vdash D e sigma Leftarrow Gamma vdash S e sigma br br Consistency br br br br br br br br br D br br br br e br br br br br br br br S br br br br e br br br br br displaystyle Gamma vdash D e sigma Rightarrow Gamma vdash S e sigma br br Completeness br While consistency can be seen by decomposing the rules br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br and br br br br br br br V br a br r br br br br br br displaystyle mathtt Var br br br of br br br br br br br S br br br br br displaystyle vdash S br br into proofs in br br br br br br br D br br br br br displaystyle vdash D br br it is likely visible that br br br br br br br S br br br br br displaystyle vdash S br br is incomplete as br one cannot show br br br br br br x br br x br br br br br br br br br br displaystyle lambda x x forall alpha alpha rightarrow alpha br br in br br br br br br br S br br br br br displaystyle vdash S br br for instance but only br br br br br br br x br br x br br br br br br br displaystyle lambda x x alpha rightarrow alpha br br An only slightly weaker version of completeness is provable br though namely br br br br br br br br br D br br br br e br br br br br br br br S br br br br e br br br br br br br br br br br br br br br br br br br displaystyle Gamma vdash D e sigma Rightarrow Gamma vdash S e tau wedge bar Gamma tau sqsubseteq sigma br br br implying one can derive the principal type for an expression in br br br br br br br S br br br br br displaystyle vdash S br br allowing us to generalize the proof in the end br Comparing br br br br br br br D br br br br br displaystyle vdash D br br and br br br br br br br S br br br br br displaystyle vdash S br br now only monotypes appear in the judgments of all rules Additionally the shape of any possible proof with the deduction system is now identical to the shape of the expression both seen as trees Thus the expression fully determines the shape of the proof In br br br br br br br D br br br br br displaystyle vdash D br br the shape would likely be determined with respect to all rules except br br br br br br br I br n br s br t br br br br br br displaystyle mathtt Inst br br and br br br br br br br G br e br n br br br br br br displaystyle mathtt Gen br br which allow building arbitrarily long branches chains between the other nodes br br br Degrees of freedom instantiating the rules br Now that the shape of the proof is known one is already close to formulating a type inference algorithm br Because any proof for a given expression must have the same shape one can assume the monotypes in the br proof s judgements to be undetermined and consider how to determine them br Here the substitution specialisation order comes into play Although at the first glance one cannot determine the types locally the hope is that it is possible to refine them with the help of the order while traversing the proof tree additionally assuming because the resulting algorithm is to become an inference method that the type in any premise will be determined as the best possible And in fact one can as looking at the rules of br br br br br br br S br br br br br displaystyle vdash S br br suggests br br Abs The critical choice is At this point nothing is known about so one can only assume the most general type which is br br br br br br br br br br displaystyle forall alpha alpha br br The plan is to specialize the type if it should become necessary Unfortunately a polytype is not permitted in this place so some has to do for the moment To avoid unwanted captures a type variable not yet in the proof is a safe choice Additionally one has to keep in mind that this monotype is not yet fixed but might be further refined br Var The choice is how to refine Because any choice of a type here depends on the usage of the variable which is not locally known the safest bet is the most general one Using the same method as above one can instantiate all quantified variables in with fresh monotype variables again keeping them open to further refinement br Let The rule does not leave any choice Done br App Only the application rule might force a refinement to the variables opened so far as required by both premises br The first premise forces the outcome of the inference to be of the form br br br br br br br br br br br br displaystyle tau rightarrow tau br br br If it is then fine One can later pick its for the result br If not it might be an open variable Then this can be refined to the required form with two new variables as before br Otherwise the type checking fails because the first premise inferred a type which is not and cannot be made into a function type br The second premise requires that the inferred type is equal to of the first premise Now there are two possibly different types perhaps with open type variables at hand to compare and to make equal if it is possible If it is a refinement is found and if not a type error is detected again An effective method is known to make two terms equal by substitution Robinson s Unification in combination with the so called Union Find algorithm br To briefly summarize the union find algorithm given the set of all types in a proof it allows one to group them together into equivalence classes by means of a union br procedure and to pick a representative for each such class using a find procedure Emphasizing the word procedure in the sense of side effect we re clearly leaving the realm of logic in order to prepare an effective algorithm The representative of a br br br br br br u br n br i br o br n br br br br a br br b br br br br displaystyle mathtt union a b br br is determined such that if both a and b are type variables then the representative is arbitrarily one of them but while uniting a variable and a term the term becomes the representative Assuming an implementation of union find at hand one can formulate the unification of two monotypes as follows br br unify ta tb br ta find ta br tb find tb br if both ta tb are terms of the form D p pn with identical D n then br unify ta i tb i for each corresponding ith parameter br else br if at least one of ta tb is a type variable then br union ta tb br else br error types do not match br br Now having a sketch of an inference algorithm at hand a more formal presentation is given in the next section It is described in Milner P ff as algorithm J br br br Algorithm J br br The presentation of Algorithm J is a misuse of the notation of logical rules since it includes side effects but allows a direct comparison with br br br br br br br S br br br br br displaystyle vdash S br br while expressing an efficient implementation at the same time The rules now specify a procedure with parameters br br br br br br e br br br displaystyle Gamma e br br yielding br br br br br br br displaystyle tau br br in the conclusion where the execution of the premises proceeds from left to right br The procedure br br br br i br n br s br t br br br br br br displaystyle inst sigma br br specializes the polytype br br br br br br br displaystyle sigma br br by copying the term and replacing the bound type variables consistently by new monotype variables br br br br n br e br w br v br a br r br br br displaystyle newvar br br produces a new monotype variable Likely br br br br br br br br br br br br br br br br br displaystyle bar Gamma tau br br has to copy the type introducing new variables for the quantification to avoid unwanted captures Overall the algorithm now proceeds by always making the most general choice leaving the specialization to the unification which by itself produces the most general result As noted above the final result br br br br br br br displaystyle tau br br has to be generalized to br br br br br br br br br br br br br br br br br displaystyle bar Gamma tau br br in the end to gain the most general type for a given expression br Because the procedures used in the algorithm have nearly O cost the overall cost of the algorithm is close to linear in the size of the expression for which a type is to be inferred This is in strong contrast to many other attempts to derive type inference algorithms which often came out to be NP hard if not undecidable with respect to termination Thus the HM performs as well as the best fully informed type checking algorithms can Type checking here means that an algorithm does not have to find a proof but only to validate a given one br Efficiency is slightly reduced because the binding of type variables in the context has to be maintained to allow computation of br br br br br br br br br br br br br br br br br displaystyle bar Gamma tau br br and enable an occurs check to prevent the building of recursive types during br br br br br br u br n br i br f br y br br br br br br br br br br displaystyle mathit unify alpha tau br br br An example of such a case is br br br br br br x br br br x br br x br br br br displaystyle lambda x x x br br for which no type can be derived using HM Practically types are only small terms and do not build up expanding structures Thus in complexity analysis one can treat comparing them as a constant retaining O costs br br br Proving the algorithm br In the previous section while sketching the algorithm its proof was hinted at with metalogical argumentation While this leads to an efficient algorithm J it is not clear whether the algorithm properly reflects the deduction systems D or S which serve as a semantic base line br The most critical point in the above argumentation is the refinement of monotype br variables bound by the context For instance the algorithm boldly changes the br context while inferring e g br br br br br f br br br f br br br br br br displaystyle lambda f f br br br because the monotype variable added to the context for the parameter br br br br f br br br displaystyle f br br later needs to be refined br to br br br br i br n br t br br br br br displaystyle int rightarrow beta br br when handling application br The problem is that the deduction rules do not allow such a refinement br Arguing that the refined type could have been added earlier instead of the br monotype variable is an expedient at best br The key to reaching a formally satisfying argument is to properly include br the context within the refinement Formally br typing is compatible with substitution of free type variables br br br br br br br br br S br br br e br br br br br br S br br br br br S br br br e br br S br br br br displaystyle Gamma vdash S e tau quad Longrightarrow quad S Gamma vdash S e S tau br br br To refine the free variables thus means to refine the whole typing br br br Algorithm W br br From there a proof of algorithm J leads to algorithm W which only makes the br side effects imposed by the procedure br br br br br br union br br br br br displaystyle textit union br br explicit by br expressing its serial composition by means of the substitutions br br br br br br S br br i br br br br br displaystyle S i br br The presentation of algorithm W in the sidebar still makes use of side effects br in the operations set in italic but these are now limited to generating br fresh symbols The form of judgement is br br br br br br e br br br br S br br br displaystyle Gamma vdash e tau S br br br denoting a function with a context and expression as parameter producing a monotype together with br a substitution br br br br br br mgu br br br br br displaystyle textsf mgu br br is a side effect free version br of br br br br br br union br br br br br displaystyle textit union br br producing a substitution which is the most general unifier br While algorithm W is normally considered to be the HM algorithm and is br often directly presented after the rule system in literature its purpose is br described by Milner on P as follows br br As it stands W is hardly an efficient algorithm substitutions are applied too often It was formulated to aid the proof of soundness We now present a simpler algorithm J which simulates W in a precise sense br While he considered W more complicated and less efficient he presented it br in his publication before J It has its merits when side effects are unavailable or unwanted br W is also needed to prove completeness which is factored by him into the soundness proof br br br Proof obligations br Before formulating the proof obligations a deviation between the rules systems D and S and the algorithms presented needs to be emphasized br While the development above sort of misused the monotypes as open proof variables the possibility that proper monotype variables might be harmed was sidestepped by introducing fresh variables and hoping for the best But there s a catch One of the promises made was that these fresh variables would be kept in mind as such This promise is not fulfilled by the algorithm br Having a context br br br br br br i br n br t br br br f br br br br br displaystyle int f alpha br br the expression br br br br f br br br br br displaystyle f br br br cannot be typed in either br br br br br br br D br br br br br displaystyle vdash D br br or br br br br br br br S br br br br br displaystyle vdash S br br but the algorithms come up with br the type br br br br br br br displaystyle beta br br where W additionally delivers the substitution br br br br br br br br br i br n br t br br br br br br br br displaystyle left alpha mapsto int rightarrow beta right br br br meaning that the algorithm fails to detect all type errors This omission can easily be fixed by more carefully distinguishing proof br variables and monotype variables br The authors were well aware of the problem but decided not to fix it One might assume a pragmatic reason behind this br While more properly implementing the type inference would have enabled the algorithm to deal with abstract monotypes br they were not needed for the intended application where none of the items in a preexisting context have free br variables In this light the unneeded complication was dropped in favor of a simpler algorithm br The remaining downside is that the proof of the algorithm with respect to the rule system is less general and can only be made br for contexts with br br br br f br r br e br e br br br br br br br br displaystyle free Gamma emptyset br br as a side condition br br br br br br br br br br Correctness br br br br br br br br W br br br e br br br br S br br br br br br br br br br S br br br e br br br br br br br br Completeness br br br br br br br br S br br br e br br br br br br br br br br br br W br br br e br br br br br br br S br br br br forall br br br br br br where br br br br br br br br br br br br br br br br br br br br br br br displaystyle begin array lll text Correctness Gamma vdash W e tau S quad Longrightarrow quad Gamma vdash S e tau text Completeness Gamma vdash S e tau quad Longrightarrow quad Gamma vdash W e tau S quad quad text forall tau text where overline emptyset tau sqsubseteq tau end array br br br The side condition in the completeness obligation addresses how the deduction may give many types while the algorithm always produces one At the same time the side condition demands that the type inferred is actually the most general br To properly prove the obligations one needs to strengthen them first to allow activating the substitution lemma threading the substitution br br br br S br br br displaystyle S br br through br br br br br br br S br br br br br displaystyle vdash S br br and br br br br br br br W br br br br br displaystyle vdash W br br From there the proofs are by induction over the expression br Another proof obligation is the substitution lemma itself i e the substitution of the typing which finally establishes the all quantification The later cannot formally be proven since no such syntax is at hand br br br Extensions br br br Recursive definitions br To make programming practical recursive functions are needed br A central property of the lambda calculus is that recursive definitions br are not directly available but can instead be expressed with a fixed point combinator br But unfortunately the fixpoint combinator cannot be formulated in a typed version br of the lambda calculus without having a disastrous effect on the system as outlined br below br br br Typing rule br The original paper shows recursion can be realized by a combinator br br br br br br br f br i br x br br br br br br br br br br br br br br br br displaystyle mathit fix forall alpha alpha rightarrow alpha rightarrow alpha br br A possible recursive definition could thus be formulated as br br br br br br br r br e br c br br br br v br br br e br br br br br br br br i br n br br br br br e br br br br br br br br br l br e br t br br br br v br br br br f br i br x br br br br br v br br br e br br br br br br br br br i br n br br br br br e br br br br br br br displaystyle mathtt rec v e mathtt in e mathtt let v mathit fix lambda v e mathtt in e br br br Alternatively an extension of the expression syntax and an extra typing rule is possible br br br br br br br br br br br br br br br br br e br br br br br br br br br br br br br br br br br br br br br br br e br br n br br br br br br br n br br br br br br br br br br br e br br br br br br br br br br br r br e br c br br br br br v br br br br br br br e br br br br br br br br a br n br d br br br br br br br br a br n br d br br br br br v br br n br br br br br e br br n br br br br br br i br n br br br br e br br br br br br br br br br R br e br c br br br br br br br displaystyle displaystyle frac Gamma Gamma vdash e tau quad dots quad Gamma Gamma vdash e n tau n quad Gamma Gamma vdash e tau Gamma vdash mathtt rec v e mathtt and dots mathtt and v n e n mathtt in e tau quad mathtt Rec br br br where br br br br br br br br br br br v br br br br br br br br br br br br br br br br br br v br br n br br br br br br br n br br br br br displaystyle Gamma v tau dots v n tau n br br br br br br br br br br br br v br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br v br br n br br br br br br br br br br br br br br br br br n br br br br br br br displaystyle Gamma v bar Gamma tau dots v n bar Gamma tau n br br br basically merging br br br br br br br A br b br s br br br br br br displaystyle mathtt Abs br br and br br br br br br br L br e br t br br br br br br displaystyle mathtt Let br br while including the recursively defined br variables in monotype positions where they occur to the left of the br br br br br br i br n br br br br br displaystyle mathtt in br br but as polytypes to the right of it br br br Consequences br While the above is straightforward it does come at a price br Type theory connects lambda calculus with computation and logic br The easy modification above has effects on both br br The strong normalisation property is invalidated because non terminating terms can be formulated br The logic collapses because the type br br br br br a br br a br br br displaystyle forall a a br br becomes inhabited br br br Overloading br br Overloading means that different functions can be defined and used with the same name Most programming languages at least provide overloading with the built in arithmetic operations etc to allow the programmer to write arithmetic expressions in the same form even for different numerical types like int or real Because a mixture of these different types within the same expression also demands for implicit conversion overloading especially for these operations is often built into the programming language itself In some languages this feature is generalized and made available to the user e g in C br While ad hoc overloading has been avoided in functional programming for the computation costs both in type checking and inference a means to systematise overloading has been introduced that resembles both in form and naming to object oriented programming but works one level upwards Instances in this systematic are not objects i e on value level but rather types br The quicksort example mentioned in the introduction uses the overloading in the orders having the following type annotation in Haskell br br Herein the type a is not only polymorphic but also restricted to be an instance of some type class Ord that provides the order predicates and used in the functions body The proper implementations of these predicates are then passed to quicksorts as additional parameters as soon as quicksort is used on more concrete types providing a single implementation of the overloaded function quickSort br Because the classes only allow a single type as their argument the resulting type system can still provide inference Additionally the type classes can then be equipped with some kind of overloading order allowing one to arrange the classes as a lattice br br br Higher order types br br Parametric polymorphism implies that types themselves are passed as parameters as if they were proper values Passed as arguments to a proper functions but also into type functions as in the parametric type constants leads to the question how to more properly type types themselves Higher order types are used to create an even more expressive type system br Unfortunately unification is no longer decidable in the presence of meta types rendering type inference impossible in this extend of generality Additionally assuming a type of all types that includes itself as type leads into a paradox as in the set of all sets so one must proceed in steps of levels of abstraction br Research in second order lambda calculus one step upwards showed that type inference is undecidable in this generality br Haskell introduces one higher level named kind In standard Haskell kinds are inferred and used for little more than to describe the arity of type constructors e g a list type constructor is thought of as mapping a type the type of its elements to another type the type of the list containing said elements notationally this is expressed as br br br br br br br br br displaystyle to br br Language extensions are available which extend kinds to emulate features of a dependent type system br br br Subtyping br br Attempts to combine subtyping and type inference have caused quite some frustration br It is straightforward to accumulate and propagate subtyping constraints as opposed to type equality constraints making the resulting constraints part of the inferred typing schemes br for example br br br br br br br br br br br T br br br br br br br br displaystyle forall alpha alpha leq T Rightarrow alpha rightarrow alpha br br where br br br br br br T br br br displaystyle alpha leq T br br is a constraint on the type variable br br br br br br br displaystyle alpha br br br However because type variables are no longer unified eagerly in this approach it tends to generate large and unwieldy typing schemes containing many useless type variables and constraints making them hard to read and understand br Therefore considerable effort was put into simplifying such typing schemes and their constraints br using techniques similar to those of nondeterministic finite automaton NFA simplification useful in the presence of inferred recursive types br More recently Dolan and Mycroft br formalized the relationship between typing scheme simplification and NFA simplification br and showed that an algebraic take on the formalization of subtyping allowed generating compact principal typing schemes for an ML like language called MLsub br Notably their proposed typing scheme used a restricted form of union and intersection types instead of explicit constraints br Parreaux later claimed br that this algebraic formulation was equivalent to a relatively simple algorithm resembling Algorithm W br and that the use of union and intersection types was not essential br On the other hand type inference has proven more difficult in the context of object oriented programming languages br because object methods tend to require first class polymorphism in the style of System F where type inference is undecidable br and because of features like F bounded polymorphism br Consequently type systems with subtyping enabling object oriented programming such as Cardelli s system br br br br br F br br br br br br br displaystyle F br br do not support HM style type inference br Row polymorphism can be used as an alternative to subtyping for supporting language features like structural records br While this style of polymorphism is less flexible than subtyping in some ways notably requiring more polymorphism than strictly necessary to cope with the lack of directionality in type constraints br it has the advantage that it can be integrated with the standard HM algorithms quite easily br br br Notes br br br br br br External links br A literate Haskell implementation of Algorithm W along with its source code on GitHub br A simple implementation of Hindley Milner algorithm in Python 