title: Fixed-point combinator
id: 150287
In combinatory logic for computer science a fixed point combinator or fixpoint combinator p is a higher order function i e a function which takes a function as argument that returns some fixed point a value that is mapped to itself of its argument function if one exists br Formally if br br br br br br fix br br br br br displaystyle textrm fix br br is a fixed point combinator and the function br br br br f br br br displaystyle f br br has one or more fixed points then br br br br br br fix br br br br f br br br displaystyle textrm fix f br br is one of these fixed points i e br br br br br f br br br br br fix br br br br f br br br br br fix br br br br f br br br br br displaystyle f textrm fix f textrm fix f br br br Fixed point combinators can be defined in the lambda calculus and in functional programming languages and provide a means to allow for recursive definitions br br br Y combinator in lambda calculus br In the classical untyped lambda calculus every function has a fixed point A particular implementation of br br br br br br fix br br br br br displaystyle textrm fix br br is Haskell Curry s paradoxical combinator Y given by br br br br br Y br br br f br br br br br x br br f br br br x br br x br br br br br br x br br f br br br x br br x br br br br br displaystyle Y lambda f lambda x f x x lambda x f x x br br br Here we use the standard notations and conventions of lambda calculus Y is a function that takes one argument f and returns the entire expression following the first period the expression br br br br br x br br f br br br x br br x br br br br displaystyle lambda x f x x br br denotes a function that takes one argument x thought of as a function and returns the expression br br br br f br br br x br br x br br br br displaystyle f x x br br where br br br br br x br br x br br br br displaystyle x x br br denotes x applied to itself Juxtaposition of expressions denotes function application is left associative and has higher precedence than the period br br br Verification br The following calculation verifies that br br br br Y br g br br br displaystyle Yg br br is indeed a fixed point of the function br br br br g br br br displaystyle g br br br br The lambda term br br br br g br br br Y br br g br br br br displaystyle g Y g br br may not in general reduce to the term br br br br Y br br g br br br displaystyle Y g br br However both terms reduce to the same term as shown br br br Uses br Applied to a function with one variable the Y combinator usually does not terminate More interesting results are obtained by applying the Y combinator to functions of two or more variables The additional variables may be used as a counter or index The resulting function behaves like a while or a for loop in an imperative language br Used in this way the Y combinator implements simple recursion The lambda calculus does not allow a function to appear as a term in its own definition as is possible in many programming languages but a function can be passed as an argument to a higher order function that applies it in a recursive manner br The Y combinator may also be used in implementing Curry s paradox The heart of Curry s paradox is that untyped lambda calculus is unsound as a deductive system and the Y combinator demonstrates this by allowing an anonymous expression to represent zero or even many values This is inconsistent in mathematical logic br br br Example implementations br An example implementation of the Y combinator in two languages is presented below br br Note that both of these programs while formally correct are useless in practice they both loop indefinitely until they terminate through stack overflow More generally as both Python and C use strict evaluation the Y combinator is generally useless in those languages see below for the Z combinator which can be used in strict programming languages br br br Fixed point combinator br The Y combinator is an implementation of a fixed point combinator in lambda calculus Fixed point combinators may also be easily defined in other functional and imperative languages The implementation in lambda calculus is more difficult due to limitations in lambda calculus br The fixed point combinator may be used in a number of different areas br br General mathematics br Untyped lambda calculus br Typed lambda calculus br Functional programming br Imperative programming br Fixed point combinators may be applied to a range of different functions but normally will not terminate unless there is an extra parameter When the function to be fixed refers to its parameter another call to the function is invoked so the calculation never gets started Instead the extra parameter is used to trigger the start of the calculation br The type of the fixed point is the return type of the function being fixed This may be a real or a function or any other type br In the untyped lambda calculus the function to apply the fixed point combinator to may be expressed using an encoding like Church encoding In this case particular lambda terms which define functions are considered as values Running beta reducing the fixed point combinator on the encoding gives a lambda term for the result which may then be interpreted as fixed point value br Alternately a function may be considered as a lambda term defined purely in lambda calculus br These different approaches affect how a mathematician and a programmer may regard a fixed point combinator A mathematician may see the Y combinator applied to a function as being an expression satisfying the fixed point equation and therefore a solution br In contrast a person only wanting to apply a fixed point combinator to some general programming task may see it only as a means of implementing recursion br br br Values and domains br Many functions do not have any fixed points for instance br br br br f br br br N br br br br N br br br br displaystyle f mathbb N to mathbb N br br with br br br br f br br n br br br n br br br br br displaystyle f n n br br Using Church encoding natural numbers can be represented in lambda calculus and this function f can be defined in lambda calculus However its domain will now contain all lambda expression not just those representing natural numbers The Y combinator applied to f will yield a fixed point for f but this fixed point won t represent a natural number If trying to compute Y f in an actual programming language an infinite loop will occur br br br Function versus implementation br The fixed point combinator may be defined in mathematics and then implemented in other languages General mathematics defines a function based on its extensional properties That is two functions are equal if they perform the same mapping Lambda calculus and programming languages regard function identity as an intensional property A function s identity is based on its implementation br A lambda calculus function or term is an implementation of a mathematical function In the lambda calculus there are a number of combinators implementations that satisfy the mathematical definition of a fixed point combinator br br br Definition of the term combinator br Combinatory logic is a higher order functions theory A combinator is a closed lambda expression meaning that it has no free variables The combinators may be combined to direct values to their correct places in the expression without ever naming them as variables br br br Recursive definitions and fixed point combinators br Fixed point combinators can be used to implement recursive definition of functions However they are rarely used in practical programming Strongly normalizing type systems such as the simply typed lambda calculus disallow non termination and hence fixed point combinators often cannot be assigned a type or require complex type system features Furthermore fixed point combinators are often inefficient compared to other strategies for implementing recursion as they require more function reductions and construct and take apart a tuple for each group of mutually recursive definitions page br br br The factorial function br The factorial function provides a good example of how a fixed point combinator may be used to define recursive functions The standard recursive definition of the factorial function in mathematics can be written as br br br br br fact br br br n br br br br br br br br br br br br if br br br n br br br br br br br n br br fact br br br n br br br br br br br otherwise br br br br br br br br br br displaystyle operatorname fact n begin cases text if n n times operatorname fact n text otherwise end cases br br br where n is a non negative integer br If we want to implement this in lambda calculus where integers are represented using Church encoding we run into the problem that the lambda calculus does not allow the name of a function fact to be used in the function s definition This can be circumvented using a fixed point combinator br br br br br br fix br br br br br displaystyle textsf fix br br as follows br Define a function F of two arguments f and n br br br br br F br br f br br n br br br IsZero br br br n br br br br br br multiply br br br n br br br f br br br pred br br br n br br br br br br displaystyle F f n operatorname IsZero n operatorname multiply n f operatorname pred n br br br Here br br br br br IsZero br br br n br br br br displaystyle operatorname IsZero n br br is a function that takes two arguments and returns its first argument if n and its second argument otherwise br br br br pred br br br n br br br displaystyle operatorname pred n br br evaluates to n br Now define br br br br fact br br br br fix br br br br F br br br displaystyle operatorname fact textsf fix F br br Then br br br br fact br br br displaystyle operatorname fact br br is a fixed point of F which gives br br br br br br br br br fact br br n br br br br br F br br fact br br br n br br br br br br br br br IsZero br br br n br br br br br br multiply br br br n br br br fact br br br br pred br br br n br br br br br br br br br br br displaystyle begin aligned operatorname fact n F operatorname fact n operatorname IsZero n operatorname multiply n operatorname fact operatorname pred n end aligned br br br as desired br br br Fixed point combinators in lambda calculus br The Y combinator discovered by Haskell B Curry is defined as br br br br br Y br br br f br br br br x br br f br br br x br br x br br br br br br x br br f br br br x br br x br br br br br displaystyle Y lambda f lambda x f x x lambda x f x x br br br br Other fixed point combinators br In untyped lambda calculus fixed point combinators are not especially rare In fact there are infinitely many of them In Mayer Goldberg showed that the set of fixed point combinators of untyped lambda calculus is recursively enumerable br The Y combinator can be expressed in the SKI calculus as br br br br br Y br br S br br K br br S br I br I br br br br S br br S br br K br S br br K br br br K br br S br I br I br br br br br br displaystyle Y S K SII S S KS K K SII br br br Additional combinators B C K W system allow for a much shorter definition With br br br br U br br S br I br I br br br displaystyle U SII br br the self application combinator since br br br br S br br K br x br br y br z br br x br br y br z br br br B br x br y br z br br br displaystyle S Kx yz x yz Bxyz br br and br br br br S br x br br K br y br br z br br x br z br y br br C br x br y br z br br br displaystyle Sx Ky z xzy Cxyz br br the above becomes br br br br br Y br br S br br K br U br br br S br B br br K br U br br br br B br U br br C br B br U br br br br displaystyle Y S KU SB KU BU CBU br br br The simplest fixed point combinator in the SK calculus found by John Tromp is br br br br br br Y br br br br S br S br K br br S br br K br br S br S br br S br br S br S br K br br br br br K br br br br displaystyle Y SSK S K SS S SSK K br br br although note that it is not in normal form which is longer This combinator corresponds to the lambda expression br br br br br br Y br br br br br br x br y br br x br y br x br br br br y br x br br y br br x br y br x br br br br br displaystyle Y lambda xy xyx lambda yx y xyx br br br The following fixed point combinator is simpler than the Y combinator and reduces into the Y combinator it is sometimes cited as the Y combinator itself br br br br br X br br br f br br br br x br br x br x br br br br x br br f br br x br x br br br br br displaystyle X lambda f lambda x xx lambda x f xx br br br Another common fixed point combinator is the Turing fixed point combinator named after its discoverer Alan Turing br br br br br br br br br x br y br br y br br x br x br y br br br br br br x br y br br y br br x br x br y br br br br br displaystyle Theta lambda xy y xxy lambda xy y xxy br br br Its advantage over br br br br Y br br br displaystyle Y br br is that br br br br br br f br br br displaystyle Theta f br br beta reduces to br br br br f br br br br f br br br br displaystyle f Theta f br br br whereas br br br br Y br br f br br br displaystyle Y f br br and br br br br f br br br Y br f br br br br displaystyle f Yf br br only beta reduce to a common term br br br br br br br br displaystyle Theta br br also has a simple call by value form br br br br br br br br v br br br br br br x br y br br y br br br z br br x br x br y br z br br br br br br x br y br br y br br br z br br x br x br y br z br br br br br displaystyle Theta v lambda xy y lambda z xxyz lambda xy y lambda z xxyz br br br The analog for mutual recursion is a polyvariadic fix point combinator which may be denoted Y br br br Strict fixed point combinator br In a strict programming language the Y combinator will expand until stack overflow or never halt in case of tail call optimization The Z combinator will work in strict languages also called eager languages where applicative evaluation order is applied The Z combinator has the next argument defined explicitly preventing the expansion of br br br br Z br g br br br displaystyle Zg br br in the right hand side of the definition br br br br br Z br g br v br br g br br Z br g br br v br br br br br displaystyle Zgv g Zg v br br br and in lambda calculus it is an eta expansion of the Y combinator br br br br br Z br br br f br br br br x br br f br br br v br br x br x br v br br br br br br x br br f br br br v br br x br x br v br br br br br br br displaystyle Z lambda f lambda x f lambda v xxv lambda x f lambda v xxv br br br br Non standard fixed point combinators br If F is a fixed point combinator in untyped lambda calculus then we have br br br br br F br br br x br br F br x br br br x br br x br br F br x br br br br x br br x br br x br br F br x br br br br br br br displaystyle F lambda x Fx lambda x x Fx lambda x x x Fx cdots br br br Terms that have the same B hm tree as a fixed point combinator i e have the same infinite extension br br br br br x br br x br br x br br x br br br br br br displaystyle lambda x x x x cdots br br are called non standard fixed point combinators Any fixed point combinator is also a non standard one but not all non standard fixed point combinators are fixed point combinators because some of them fail to satisfy the fixed point equation that defines the standard ones These combinators are called strictly non standard fixed point combinators an example is the following combinator br br br br br N br br B br M br br B br br B br M br br B br br br br displaystyle N BM B BM B br br br where br br br br br B br br br x br y br z br br x br br y br z br br br br displaystyle B lambda xyz x yz br br br br br br M br br br x br br x br x br br br br br displaystyle M lambda x xx br br br The set of non standard fixed point combinators is not recursively enumerable br br br Implementation in other languages br The Y combinator is a particular implementation of a fixed point combinator in lambda calculus Its structure is determined by the limitations of lambda calculus It is not necessary or helpful to use this structure in implementing the fixed point combinator in other languages br Simple examples of fixed point combinators implemented in some programming paradigms are given below br br br Lazy functional implementation br In a language that supports lazy evaluation like in Haskell it is possible to define a fixed point combinator using the defining equation of the fixed point combinator which is conventionally named fix Since Haskell has lazy datatypes this combinator can also be used to define fixed points of data constructors and not only to implement recursive functions The definition is given here followed by some usage examples In Hackage the original sample is br br br Strict functional implementation br In a strict functional language as illustrated below with OCaml the argument to f is expanded beforehand yielding an infinite call sequence br br br br br f br br br f br br br br br f br br br br br f br i br x br br br br f br br br br br br br br x br br br displaystyle f f f mathsf fix f x br br br This may be resolved by defining fix with an extra parameter br br In a multi paradigm functional language one decorated with imperative features such as Lisp Peter Landin suggested the use of a variable assignment to create a fixed point combinator as in the below example using Scheme br br Using a lambda calculus with axioms for assignment statements it can be shown that Y satisfies the same fixed point law as the call by value Y combinator br br br br br br br Y br br br br br br br x br br e br br br e br br br br br br x br br e br br br br br Y br br br br br br br x br br e br br br e br br br br br displaystyle Y lambda x e e lambda x e Y lambda x e e br br br In more idiomatic modern Lisp usage this would typically be handled via a lexically scoped label a let expression as lexical scope was not introduced to Lisp until the s br br Or without the internal label br br br Imperative language implementation br This example is a slightly interpretive implementation of a fixed point combinator A class is used to contain the fix function called fixer The function to be fixed is contained in a class that inherits from fixer The fix function accesses the function to be fixed as a virtual function As for the strict functional definition fix is explicitly given an extra parameter x which means that lazy evaluation is not needed br br br Typing br In System F polymorphic lambda calculus a polymorphic fixed point combinator has type br br a a a a br where a is a type variable That is fix takes a function which maps a a and uses it to return a value of type a br In the simply typed lambda calculus extended with recursive data types fixed point operators can be written but the type of a useful fixed point operator one whose application always returns may be restricted br In the simply typed lambda calculus the fixed point combinator Y cannot be assigned a type because at some point it would deal with the self application sub term br br br br x br br x br br br displaystyle x x br br by the application rule br br br br br br br br br x br br br br br t br br br br br br br t br br br br br br br br x br br br br br t br br br br br br br br br br x br br x br br br br br t br br br br br br br br displaystyle Gamma vdash x t to t quad Gamma vdash x t over Gamma vdash x x t br br br where br br br br x br br br displaystyle x br br has the infinite type br br br br br t br br br br br br br t br br br br br br br t br br br br br br br displaystyle t t to t br br No fixed point combinator can in fact be typed in those systems any support for recursion must be explicitly added to the language br br br Type for the Y combinator br In programming languages that support recursive data types it is possible to type the Y combinator by appropriately accounting for the recursion at the type level The need to self apply the variable x can be managed using a type Rec a which is defined so as to be isomorphic to Rec a a br For example in the following Haskell code we have In and out being the names of the two directions of the isomorphism with types br br which lets us write br br Or equivalently in OCaml br br Alternatively br br br General information br Because fixed point combinators can be used to implement recursion it is possible to use them to describe specific types of recursive computations such as those in fixed point iteration iterative methods recursive join in relational databases data flow analysis FIRST and FOLLOW sets of non terminals in a context free grammar transitive closure and other types of closure operations br A function for which every input is a fixed point is called an identity function Formally br br br br br br x br br f br br x br br x br br br br displaystyle forall x f x x br br br In contrast to universal quantification over all br br br br x br br br displaystyle x br br a fixed point combinator constructs one value that is a fixed point of br br br br f br br br displaystyle f br br The remarkable property of a fixed point combinator is that it constructs a fixed point for an arbitrary given function br br br br f br br br displaystyle f br br br Other functions have the special property that after being applied once further applications don t have any effect More formally br br br br br br x br br f br br br f br br x br br br f br br x br br br br displaystyle forall x f f x f x br br br Such functions are called idempotent see also Projection mathematics An example of such a function is the function that returns for all even integers and for all odd integers br In lambda calculus from a computational point of view applying a fixed point combinator to an identity function or an idempotent function typically results in non terminating computation For example we obtain br br br br br br Y br br br x br br x br br br br br x br br br x br x br br br br x br br br x br x br br br br br displaystyle Y lambda x x lambda x xx lambda x xx br br br where the resulting term can only reduce to itself and represents an infinite loop br Fixed point combinators do not necessarily exist in more restrictive models of computation For instance they do not exist in simply typed lambda calculus br The Y combinator allows recursion to be defined as a set of rewrite rules without requiring native recursion support in the language br In programming languages that support anonymous functions fixed point combinators allow the definition and use of anonymous recursive functions i e without having to bind such functions to identifiers In this setting the use of fixed point combinators is sometimes called anonymous recursion br br br See also br Anonymous function br Fixed point iteration br Lambda calculus Recursion and fixed points br Lambda lifting br Let expression br br br Notes br br br br br Werner Kluge Abstract computing machines a lambda calculus perspective Springer ISBN pp br Mayer Goldberg On the Recursive Enumerability of Fixed Point Combinators BRICS Report RS University of Aarhus br Matthias Felleisen A Lecture on the Why of Y br br br External links br br Recursion Theory and Joy Manfred von Thun or earlier br The Lambda Calculus notes by Don Blaheta October br Y Combinator Archived at the Wayback Machine br A Use of the Y Combinator in Ruby br Functional programming in Ada br Rosetta code Y combinator