title: System F
id: 767637
System F also polymorphic lambda calculus or second order lambda calculus is a typed lambda calculus that introduces to simply typed lambda calculus a mechanism of universal quantification over types System F formalizes parametric polymorphism in programming languages thus forming a theoretical basis for languages such as Haskell and ML It was discovered independently by logician Jean Yves Girard and computer scientist John C Reynolds br Whereas simply typed lambda calculus has variables ranging over terms and binders for them System F additionally has variables ranging over types and binders for them As an example the fact that the identity function can have any type of the form A A would be formalized in System F as the judgement br br br br br br br br br br br x br br br br br br x br br br br br br br br br br displaystyle vdash Lambda alpha lambda x alpha x forall alpha alpha to alpha br br br where br br br br br br br displaystyle alpha br br is a type variable The upper case br br br br br br br displaystyle Lambda br br is traditionally used to denote type level functions as opposed to the lower case br br br br br br br displaystyle lambda br br which is used for value level functions The superscripted br br br br br br br displaystyle alpha br br means that the bound x is of type br br br br br br br displaystyle alpha br br the expression after the colon is the type of the lambda expression preceding it br As a term rewriting system System F is strongly normalizing However type inference in System F without explicit type annotations is undecidable Under the Curry Howard isomorphism System F corresponds to the fragment of second order intuitionistic logic that uses only universal quantification System F can be seen as part of the lambda cube together with even more expressive typed lambda calculi including those with dependent types br According to Girard the F in System F was picked by chance br br br Typing rules br The typing rules of System F are those of simply typed lambda calculus with the addition of the following br br where br br br br br br br br br displaystyle sigma tau br br are types br br br br br br br displaystyle alpha br br is a type variable and br br br br br br br type br br br br displaystyle alpha text type br br in the context indicates that br br br br br br br displaystyle alpha br br is bound The first rule is that of application and the second is that of abstraction br br br Logic and predicates br The br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br type is defined as br br br br br br br br br br br br br br br displaystyle forall alpha alpha to alpha to alpha br br where br br br br br br br displaystyle alpha br br is a type variable This means br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br is the type of all functions which take as input a type and two expressions of type and produce as output an expression of type note that we consider br br br br br br br displaystyle to br br to be right associative br The following two definitions for the boolean values br br br br br T br br br br displaystyle mathbf T br br and br br br br br F br br br br displaystyle mathbf F br br are used extending the definition of Church booleans br br br br br br T br br br br br br br br br br x br br br br br br br y br br br br br br br br x br br br displaystyle mathbf T Lambda alpha lambda x alpha lambda y alpha x br br br br br br br F br br br br br br br br br br x br br br br br br br y br br br br br br br br y br br br displaystyle mathbf F Lambda alpha lambda x alpha lambda y alpha y br br br Note that the above two functions require three not two arguments The latter two should be lambda expressions but the first one should be a type This fact is reflected in the fact that the type of these expressions is br br br br br br br br br br br br br br displaystyle forall alpha alpha to alpha to alpha br br the universal quantifier binding the corresponds to the binding the alpha in the lambda expression itself Also note that br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br is a convenient shorthand for br br br br br br br br br br br br br br displaystyle forall alpha alpha to alpha to alpha br br but it is not a symbol of System F itself but rather a meta symbol Likewise br br br br br T br br br br displaystyle mathbf T br br and br br br br br F br br br br displaystyle mathbf F br br are also meta symbols convenient shorthands of System F assemblies in the Bourbaki sense otherwise if such functions could be named within System F then there would be no need for the lambda expressive apparatus capable of defining functions anonymously and for the fixed point combinator which works around that restriction br Then with these two br br br br br br br displaystyle lambda br br terms we can define some logic operators which are of type br br br br br br B br o br o br l br e br a br n br br br br br br B br o br o br l br e br a br n br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean rightarrow mathsf Boolean rightarrow mathsf Boolean br br br br br br br br br br br br A br N br D br br br br br br br br x br br br B br o br o br l br e br a br n br br br br br br y br br br B br o br o br l br e br a br n br br br br br br br x br br br br B br o br o br l br e br a br n br br br br y br br br F br br br br br br br O br R br br br br br br br br x br br br B br o br o br l br e br a br n br br br br br br y br br br B br o br o br l br e br a br n br br br br br br br x br br br br B br o br o br l br e br a br n br br br br br T br br br y br br br br br br N br O br T br br br br br br br br x br br br B br o br o br l br e br a br n br br br br br br br x br br br br B br o br o br l br e br a br n br br br br br F br br br br T br br br br br br br br displaystyle begin aligned mathrm AND lambda x mathsf Boolean lambda y mathsf Boolean x mathsf Boolean y mathbf F mathrm OR lambda x mathsf Boolean lambda y mathsf Boolean x mathsf Boolean mathbf T y mathrm NOT lambda x mathsf Boolean x mathsf Boolean mathbf F mathbf T end aligned br br br Note that in the definitions above br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br is a type argument to br br br br x br br br displaystyle x br br specifying that the other two parameters that are given to br br br br x br br br displaystyle x br br are of type br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br As in Church encodings there is no need for an IFTHENELSE function as one can just use raw br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br typed terms as decision functions However if one is requested br br br br br br I br F br T br H br E br N br E br L br S br E br br br br br br br br x br br br B br o br o br l br e br a br n br br br br br br y br br br br br br br z br br br br br br x br br y br z br br br displaystyle mathrm IFTHENELSE Lambda alpha lambda x mathsf Boolean lambda y alpha lambda z alpha x alpha yz br br br will do br A predicate is a function which returns a br br br br br br B br o br o br l br e br a br n br br br br br displaystyle mathsf Boolean br br typed value The most fundamental predicate is ISZERO which returns br br br br br T br br br br displaystyle mathbf T br br if and only if its argument is the Church numeral br br br br br br I br S br Z br E br R br O br br br br br n br br br br br br br br br br br br br br br br br br br n br br br br B br o br o br l br e br a br n br br br br br br br x br br br B br o br o br l br e br a br n br br br br br br br br F br br br br br T br br br br displaystyle mathrm ISZERO lambda n forall alpha alpha rightarrow alpha rightarrow alpha rightarrow alpha n mathsf Boolean lambda x mathsf Boolean mathbf F mathbf T br br br br System F structures br System F allows recursive constructions to be embedded in a natural manner related to that in Martin L f s type theory Abstract structures S are created using constructors These are functions typed as br br br br br br K br br br br br br br K br br br br br br br br S br br br displaystyle K rightarrow K rightarrow dots rightarrow S br br br Recursivity is manifested when S itself appears within one of the types br br br br br K br br i br br br br br displaystyle K i br br If you have m of these constructors you can define the type of S as br br br br br br br br br br K br br br br br br br br br br br br br S br br br br br br br br br br br K br br br br br m br br br br br br br br S br br br br br br br br br br br displaystyle forall alpha K alpha S rightarrow dots rightarrow alpha dots rightarrow K m alpha S rightarrow dots rightarrow alpha rightarrow alpha br br br For instance the natural numbers can be defined as an inductive datatype N with constructors br br br br br br br br br br br z br e br r br o br br br br br br br br N br br br br br br br br s br u br c br c br br br br br br br br N br br br br N br br br br br br br br displaystyle begin aligned mathit zero mathrm N mathit succ mathrm N rightarrow mathrm N end aligned br br br The System F type corresponding to this structure is br br br br br br br br br br br br br br br br br br br displaystyle forall alpha alpha to alpha to alpha to alpha br br The terms of this type comprise a typed version of the Church numerals the first few of which are br br br br br br br br br br br br br br br br br br br x br br br br br br br br f br br br br br br br br x br br br br br br br br br br br br br br br x br br br br br br br br f br br br br br br br br f br x br br br br br br br br br br br br br br br x br br br br br br br br f br br br br br br br br f br br f br x br br br br br br br br br br br br br br br br x br br br br br br br br f br br br br br br br br f br br f br br f br x br br br br br br br br br displaystyle begin aligned Lambda alpha lambda x alpha lambda f alpha to alpha x Lambda alpha lambda x alpha lambda f alpha to alpha fx Lambda alpha lambda x alpha lambda f alpha to alpha f fx Lambda alpha lambda x alpha lambda f alpha to alpha f f fx end aligned br br br If we reverse the order of the curried arguments i e br br br br br br br br br br br br br br br br br br displaystyle forall alpha alpha rightarrow alpha rightarrow alpha rightarrow alpha br br then the Church numeral for n is a function that takes a function f as argument and returns the nth power of f That is to say a Church numeral is a higher order function it takes a single argument function f and returns another single argument function br br br Use in programming languages br The version of System F used in this article is as an explicitly typed or Church style calculus The typing information contained in terms makes type checking straightforward Joe Wells settled an embarrassing open problem by proving that type checking is undecidable for a Curry style variant of System F that is one that lacks explicit typing annotations br Wells s result implies that type inference for System F is impossible br A restriction of System F known as Hindley Milner or simply HM does have an easy type inference algorithm and is used for many statically typed functional programming languages such as Haskell and the ML family Over time as the restrictions of HM style type systems have become apparent languages have steadily moved to more expressive logics for their type systems GHC a Haskell compiler goes beyond HM as of and uses System F extended with non syntactic type equality non HM features in OCaml s type system include GADT br br br The Girard Reynolds Isomorphism br In second order intuitionistic logic the second order polymorphic lambda calculus F was discovered by Girard and independently by Reynolds Girard proved the Representation Theorem that in second order intuitionistic predicate logic P functions from the natural numbers to the natural numbers that can be proved total form a projection from P into F Reynolds proved the Abstraction Theorem that every term in F satisfies a logical relation which can be embedded into the logical relations P Reynolds proved that a Girard projection followed by a Reynolds embedding form the identity i e the Girard Reynolds Isomorphism br br br System F br While System F corresponds to the first axis of Barendregt s lambda cube System F or the higher order polymorphic lambda calculus combines the first axis polymorphism with the second axis type operators it is a different more complex system br System F can be defined inductively on a family of systems where induction is based on the kinds permitted in each system br br br br br br F br br n br br br br br displaystyle F n br br permits kinds br br br br br br br br displaystyle star br br the kind of types and br br br br br J br br K br br br displaystyle J Rightarrow K br br where br br br br J br br br F br br n br br br br br br br displaystyle J in F n br br and br br br br K br br br F br br n br br br br br displaystyle K in F n br br the kind of functions from types to types where the argument type is of a lower order br In the limit we can define system br br br br br F br br br br br br br displaystyle F omega br br to be br br br br br br F br br br br br br br br br br br br i br br br br br F br br i br br br br br displaystyle F omega underset leq i bigcup F i br br br That is F is the system which allows functions from types to types where the argument and result may be of any order br Note that although F places no restrictions on the order of the arguments in these mappings it does restrict the universe of the arguments for these mappings they must be types rather than values System F does not permit mappings from values to types dependent types though it does permit mappings from values to values br br br br br br br displaystyle lambda br br abstraction mappings from types to values br br br br br br br displaystyle Lambda br br abstraction and mappings from types to types br br br br br br br displaystyle lambda br br abstraction at the level of types br br br System F br System F pronounced F sub is an extension of system F with subtyping System F has been of central importance to programming language theory since the s because the core of functional programming languages like those in the ML family support both parametric polymorphism and record subtyping which can be expressed in System F br br br See also br Existential types the existentially quantified counterparts of universal types br System U br br br Notes br br br br br br Further reading br Pierce Benjamin V Polymorphism Ch Universal Types Ch An ML Implementation of System F Types and Programming Languages MIT Press pp ISBN br br br External links br br Summary of System F by Franck Binard br System F the workhorse of modern compilers by Greg Morrisett