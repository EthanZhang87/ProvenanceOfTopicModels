title: Combinatory logic
id: 149848
Combinatory logic is a notation to eliminate the need for quantified variables in mathematical logic It was introduced by Moses Sch nfinkel and Haskell Curry and has more recently been used in computer science as a theoretical model of computation and also as a basis for the design of functional programming languages It is based on combinators which were introduced by Sch nfinkel in with the idea of providing an analogous way to build up functions and to remove any mention of variables particularly in predicate logic A combinator is a higher order function that uses only function application and earlier defined combinators to define a result from its arguments br br br In mathematics br Combinatory logic was originally intended as a pre logic that would clarify the role of quantified variables in logic essentially by eliminating them Another way of eliminating quantified variables is Quine s predicate functor logic While the expressive power of combinatory logic typically exceeds that of first order logic the expressive power of predicate functor logic is identical to that of first order logic Quine br The original inventor of combinatory logic Moses Sch nfinkel published nothing on combinatory logic after his original paper Haskell Curry rediscovered the combinators while working as an instructor at Princeton University in late In the late s Alonzo Church and his students at Princeton invented a rival formalism for functional abstraction the lambda calculus which proved more popular than combinatory logic The upshot of these historical contingencies was that until theoretical computer science began taking an interest in combinatory logic in the s and s nearly all work on the subject was by Haskell Curry and his students or by Robert Feys in Belgium Curry and Feys and Curry et al survey the early history of combinatory logic For a more modern treatment of combinatory logic and the lambda calculus together see the book by Barendregt which reviews the models Dana Scott devised for combinatory logic in the s and s br br br In computing br In computer science combinatory logic is used as a simplified model of computation used in computability theory and proof theory Despite its simplicity combinatory logic captures many essential features of computation br Combinatory logic can be viewed as a variant of the lambda calculus in which lambda expressions representing functional abstraction are replaced by a limited set of combinators primitive functions without free variables It is easy to transform lambda expressions into combinator expressions and combinator reduction is much simpler than lambda reduction Hence combinatory logic has been used to model some non strict functional programming languages and hardware The purest form of this view is the programming language Unlambda whose sole primitives are the S and K combinators augmented with character input output Although not a practical programming language Unlambda is of some theoretical interest br Combinatory logic can be given a variety of interpretations Many early papers by Curry showed how to translate axiom sets for conventional logic into combinatory logic equations Dana Scott in the s and s showed how to marry model theory and combinatory logic br br br Summary of lambda calculus br br Lambda calculus is concerned with objects called lambda terms which can be represented by the following three forms of strings br br br br br br v br br br displaystyle v br br br br br br br br v br br br E br br br br br br br displaystyle lambda v E br br br br br br br br br E br br br br br br E br br br br br br br br displaystyle E E br br br where br br br br v br br br displaystyle v br br is a variable name drawn from a predefined infinite set of variable names and br br br br br E br br br br br br br displaystyle E br br and br br br br br E br br br br br br br displaystyle E br br are lambda terms br Terms of the form br br br br br v br br br E br br br br br br br displaystyle lambda v E br br are called abstractions The variable v is called the formal parameter of the abstraction and br br br br br E br br br br br br br displaystyle E br br is the body of the abstraction The term br br br br br v br br br E br br br br br br br displaystyle lambda v E br br represents the function which applied to an argument binds the formal parameter v to the argument and then computes the resulting value of br br br br br E br br br br br br br displaystyle E br br that is it returns br br br br br E br br br br br br br displaystyle E br br with every occurrence of v replaced by the argument br Terms of the form br br br br br br E br br br br br br E br br br br br br br br displaystyle E E br br are called applications Applications model function invocation or execution the function represented by br br br br br E br br br br br br br displaystyle E br br is to be invoked with br br br br br E br br br br br br br displaystyle E br br as its argument and the result is computed If br br br br br E br br br br br br br displaystyle E br br sometimes called the applicand is an abstraction the term may be reduced br br br br br E br br br br br br br displaystyle E br br the argument may be substituted into the body of br br br br br E br br br br br br br displaystyle E br br in place of the formal parameter of br br br br br E br br br br br br br displaystyle E br br and the result is a new lambda term which is equivalent to the old one If a lambda term contains no subterms of the form br br br br br br br v br br br E br br br br br br br E br br br br br br br br displaystyle lambda v E E br br then it cannot be reduced and is said to be in normal form br The expression br br br br E br br v br br a br br br br displaystyle E v a br br represents the result of taking the term E and replacing all free occurrences of v in it with a Thus we write br br br br br br br br br v br br E br br a br br br E br br v br br a br br br br displaystyle lambda v E a Rightarrow E v a br br br By convention we take br br br br br a br b br c br br br br displaystyle abc br br as shorthand for br br br br br br a br b br br c br br br br displaystyle ab c br br i e application is left associative br The motivation for this definition of reduction is that it captures the essential behavior of all mathematical functions For example consider the function that computes the square of a number We might write br br The square of x is br br br br x br br x br br br displaystyle x x br br br Using br br br br br br br displaystyle br br to indicate multiplication x here is the formal parameter of the function To evaluate the square for a particular argument say we insert it into the definition in place of the formal parameter br br The square of is br br br br br br br br br displaystyle br br br To evaluate the resulting expression br br br br br br br br br displaystyle br br we would have to resort to our knowledge of multiplication and the number Since any computation is simply a composition of the evaluation of suitable functions on suitable primitive arguments this simple substitution principle suffices to capture the essential mechanism of computation br Moreover in lambda calculus notions such as and br br br br br br br displaystyle br br can be represented without any need for externally defined primitive operators or constants It is possible to identify terms in lambda calculus which when suitably interpreted behave like the number and like the multiplication operator q v Church encoding br Lambda calculus is known to be computationally equivalent in power to many other plausible models for computation including Turing machines that is any calculation that can be accomplished in any of these other models can be expressed in lambda calculus and vice versa According to the Church Turing thesis both models can express any possible computation br It is perhaps surprising that lambda calculus can represent any conceivable computation using only the simple notions of function abstraction and application based on simple textual substitution of terms for variables But even more remarkable is that abstraction is not even required Combinatory logic is a model of computation equivalent to lambda calculus but without abstraction The advantage of this is that evaluating expressions in lambda calculus is quite complicated because the semantics of substitution must be specified with great care to avoid variable capture problems In contrast evaluating expressions in combinatory logic is much simpler because there is no notion of substitution br br br Combinatory calculi br Since abstraction is the only way to manufacture functions in the lambda calculus something must replace it in the combinatory calculus Instead of abstraction combinatory calculus provides a limited set of primitive functions out of which other functions may be built br br br Combinatory terms br A combinatory term has one of the following forms br br The primitive functions are combinators or functions that when seen as lambda terms contain no free variables br To shorten the notations a general convention is that br br br br br br E br br br br br br E br br br br br br E br br br br br br br br br E br br n br br br br br br displaystyle E E E E n br br or even br br br br br E br br br br br br E br br br br br br E br br br br br br br br br E br br n br br br br br displaystyle E E E E n br br denotes the term br br br br br br br br br br br E br br br br br br E br br br br br br br E br br br br br br br br br br E br br n br br br br br br displaystyle E E E E n br br This is the same general convention left associativity as for multiple application in lambda calculus br br br Reduction in combinatory logic br In combinatory logic each primitive combinator comes with a reduction rule of the form br br P x xn E br where E is a term mentioning only variables from the set x xn It is in this way that primitive combinators behave as functions br br br Examples of combinators br The simplest example of a combinator is I the identity combinator defined by br br I x x br for all terms x Another simple combinator is K which manufactures constant functions K x is the function which for any argument returns x so we say br br K x y x br for all terms x and y Or following the convention for multiple application br br K x y x br A third combinator is S which is a generalized version of application br br S x y z x z y z br S applies x to y after first substituting z into br each of them Or put another way x is applied to y inside the environment z br Given S and K I itself is unnecessary since it can be built from the other two br br S K K x br S K K x br K x K x br x br for any term x Note that although S K K br x I x for any x S K K br itself is not equal to I We say the terms are extensionally equal Extensional equality captures the mathematical notion of the equality of functions that two functions are equal if they always produce the same results for the same arguments In contrast the terms themselves together with the reduction of primitive combinators capture the notion of intensional equality of functions that two functions are equal only if they have identical implementations up to the expansion of primitive combinators There are many ways to implement an identity function S K K and I are among these ways S K S is yet another We will use the word equivalent to indicate extensional equality reserving equal for identical combinatorial terms br A more interesting combinator is the fixed point combinator or Y combinator which can be used to implement recursion br br br Completeness of the S K basis br S and K can be composed to produce combinators that are extensionally equal to any lambda term and therefore by Church s thesis to any computable function whatsoever The proof is to present a transformation T which converts an arbitrary lambda term into an equivalent combinator br T may be defined as follows br br T x x br T E E T E T E br T x E K T E if x does not occur free in E br T x x I br T x y E T x T y E if x occurs free in E br T x E E S T x E T x E if x occurs free in E or E br Note that T as given is not a well typed mathematical function but rather a term rewriter Although it eventually yields a combinator the transformation may generate intermediary expressions that are neither lambda terms nor combinators via rule br This process is also known as abstraction elimination This definition is exhaustive any lambda expression will be subject to exactly one of these rules see Summary of lambda calculus above br It is related to the process of bracket abstraction which takes an expression E built from variables and application and produces a combinator expression x E in which the variable x is not free such that x E x E holds A very simple algorithm for bracket abstraction is defined by induction on the structure of expressions as follows br br x y K y br x x I br x E E S x E x E br Bracket abstraction induces a translation from lambda terms to combinator expressions by interpreting lambda abstractions using the bracket abstraction algorithm br br br Conversion of a lambda term to an equivalent combinatorial term br For example we will convert the lambda term x y y x to a combinatorial term br br T x y y x br T x T y y x by br T x S T y y T y x by br T x S I T y x by br T x S I K T x by br T x S I K x by br S T x S I T x K x by br S K S I T x K x by br S K S I S T x K T x x by br S K S I S K K T x x by br S K S I S K K I by br If we apply this combinatorial term to any two terms x and y by feeding them in a queue like fashion into the combinator from the right it reduces as follows br br S K S I S K K I x y br K S I x S K K I x y br S I S K K I x y br I y S K K I x y br y S K K I x y br y K K x I x y br y K I x y br y I x br y x br The combinatory representation S K S I S K K I is much longer than the representation as a lambda term x y y x This is typical In general the T construction may expand a lambda term of length n to a combinatorial term of length n br br br Explanation of the T transformation br The T transformation is motivated by a desire to eliminate abstraction Two special cases rules and are trivial x x is clearly equivalent to I and x E is clearly equivalent to K T E if x does not appear free in E br The first two rules are also simple Variables convert to themselves and applications which are allowed in combinatory terms are converted to combinators simply by converting the applicand and the argument to combinators br It is rules and that are of interest Rule simply says that to convert a complex abstraction to a combinator we must first convert its body to a combinator and then eliminate the abstraction Rule actually eliminates the abstraction br x E E is a function which takes an argument say a and substitutes it into the lambda term E E in place of x yielding E E x a But substituting a into E E in place of x is just the same as substituting it into both E and E so br br E E x a E x a E x a br x E E a x E a x E a br S x E x E a br S x E x E a br By extensional equality br br x E E S x E x E br Therefore to find a combinator equivalent to x E E it is sufficient to find a combinator equivalent to S x E x E and br br S T x E T x E br evidently fits the bill E and E each contain strictly fewer applications than E E so the recursion must terminate in a lambda term with no applications at all either a variable or a term of the br form x E br br br Simplifications of the transformation br br br reduction br The combinators generated by the T transformation can be made smaller if we take into account the reduction rule br br T x E x T E if x is not free in E br x E x is the function which takes an argument x and applies the function E to it this is extensionally equal to the function E itself It is therefore sufficient to convert E to combinatorial form br Taking this simplification into account the example above becomes br br T x y y x br br S K S I T x K x br S K S I K by reduction br This combinator is equivalent to the earlier longer one br br S K S I K x y br K S I x K x y br S I K x y br I y K x y br y K x y br y x br Similarly the original version of the T transformation transformed the identity function f x f x into S S K S S K K I K I With the reduction rule f x f x is br transformed into I br br br One point basis br There are one point bases from which every combinator can be composed extensionally equal to any lambda term The simplest example of such a basis is X where br br X x xS K br It is not difficult to verify that br br X X X X K and br X X X X X S br Since K S is a basis it follows that X is a basis too The Iota programming language uses X as its sole combinator br Another simple example of a one point basis is br br X x x K S K with br X X X K and br X X X S br In fact there exist infinitely many such bases br br br Combinators B C br In addition to S and K Sch nfinkel included two combinators which are now called B and C with the following reductions br br C f g x f x g br B f g x f g x br He also explains how they in turn can be expressed using only S and K br br B S K S K br C S S K S K S K S K K br These combinators are extremely useful when translating predicate logic or lambda calculus into combinator expressions They were also used by Curry and much later by David Turner whose name has been associated with their computational use Using them we can extend the rules for the transformation as follows br br T x x br T E E T E T E br T x E K T E if x is not free in E br T x x I br T x y E T x T y E if x is free in E br T x E E S T x E T x E if x is free in both E and E br T x E E C T x E T E if x is free in E but not E br T x E E B T E T x E if x is free in E but not E br Using B and C combinators the transformation of x y y x looks like this br br T x y y x br T x T y y x br T x C T y y x by rule br T x C I x br C I reduction br br br br br br br br C br br br br br br br br displaystyle mathbf C br br traditional canonical notation br br br br br br X br br br br br br br br X br I br br br br displaystyle mathbf X mathbf XI br br br br br br br br br br I br br br br br br displaystyle mathbf I br br traditional canonical notation br br br br br br X br br br br br br C br X br br br br displaystyle mathbf X mathbf CX br br br And indeed C I x y does reduce to y x br br C I x y br I y x br y x br The motivation here is that B and C are limited versions of S Whereas S takes a value and substitutes it into both the applicand and its argument before performing the application C performs the br substitution only in the applicand and B only in the argument br The modern names for the combinators come from Haskell Curry s doctoral thesis of see B C K W System In Sch nfinkel s original paper what we now call S K I B and C were called S C I Z and T respectively br The reduction in combinator size that results from the new transformation rules can also be achieved without introducing B and C as demonstrated in Section of Tromp br br br CLK versus CLI calculus br A distinction must be made between the CLK as described in this article and the CLI calculus The distinction corresponds to that between the K and the I calculus Unlike the K calculus the I calculus restricts abstractions to br br x E where x has at least one free occurrence in E br As a consequence combinator K is not present in the I calculus nor in the CLI calculus The constants of CLI are I B C and S which form a basis from which all CLI terms can be composed modulo equality Every I term can be converted into an equal CLI combinator according to rules similar to those presented above for the conversion of K terms into CLK combinators See chapter in Barendregt br br br Reverse conversion br The conversion L from combinatorial terms to lambda terms is trivial br br L I x x br L K x y x br L C x y z x z y br L B x y z x y z br L S x y z x z y z br L E E L E L E br Note however that this transformation is not the inverse br transformation of any of the versions of T that we have seen br br br Undecidability of combinatorial calculus br A normal form is any combinatory term in which the primitive combinators that occur if any are not applied to enough arguments to be simplified It is undecidable whether a general combinatory term has a normal form whether two combinatory terms are equivalent etc This can be shown in a similar way as for the corresponding problems for lambda terms br br br Undefinability by predicates br The undecidable problems above equivalence existence of normal form etc take as input syntactic representations of terms under a suitable encoding e g Church encoding One may also consider a toy trivial computation model where we compute properties of terms by means of combinators applied directly to the terms themselves as arguments rather than to their syntactic representations More precisely let a predicate be a combinator that when applied returns either T or F where T and F represent the conventional Church encodings of true and false x y x and x y y transformed into combinatory logic the combinatory versions have T K and F K I A predicate N is nontrivial if there are two arguments A and B such that N A T and N B F A combinator N is complete if NM has a normal form for every argument M An analogue of Rice s theorem for this toy model then says that every complete predicate is trivial The proof of this theorem is rather simple br br From this undefinability theorem it immediately follows that there is no complete predicate that can discriminate between terms that have a normal form and terms that do not have a normal form It also follows that there is no complete predicate say EQUAL such that br br EQUAL A B T if A B and br EQUAL A B F if A B br If EQUAL would exist then for all A x EQUAL x A would have to be a complete non trivial predicate br However note that it also immediately follows from this undefinability theorem that many properties of terms that are obviously decidable are not definable by complete predicates either e g there is no predicate that could tell whether the first primitive function letter occurring in a term is a K This shows that definability by predicates is a not a reasonable model of decidability br br br Applications br br br Compilation of functional languages br David Turner used his combinators to implement the SASL programming language br Kenneth E Iverson used primitives based on Curry s combinators in his J programming language a successor to APL This enabled what Iverson called tacit programming that is programming in functional expressions containing no variables along with powerful tools for working with such programs It turns out that tacit programming is possible in any APL like language with user defined operators br br br Logic br The Curry Howard isomorphism implies a connection between logic and programming every proof of a theorem of intuitionistic logic corresponds to a reduction of a typed lambda term and conversely Moreover theorems can be identified with function type signatures Specifically a typed combinatory logic corresponds to a Hilbert system in proof theory br The K and S combinators correspond to the axioms br br AK A B A br AS A B C A B A C br and function application corresponds to the detachment modus ponens rule br br MP from A and A B infer B br The calculus consisting of AK AS and MP is complete for the implicational fragment of the intuitionistic logic which can be seen as follows Consider the set W of all deductively closed sets of formulas ordered by inclusion Then br br br br br W br br br br br br displaystyle langle W subseteq rangle br br is an intuitionistic Kripke frame and we define a model br br br br br br br displaystyle Vdash br br in this frame by br br br br br X br br A br br br br A br br X br br br br displaystyle X Vdash A iff A in X br br br This definition obeys the conditions on satisfaction of on one hand if br br br br X br br A br br B br br br displaystyle X Vdash A to B br br and br br br br Y br br W br br br displaystyle Y in W br br is such that br br br br Y br br X br br br displaystyle Y supseteq X br br and br br br br Y br br A br br br displaystyle Y Vdash A br br then br br br br Y br br B br br br displaystyle Y Vdash B br br by modus ponens On the other hand if br br br br X br br A br br B br br br displaystyle X not Vdash A to B br br then br br br br X br br A br br B br br br displaystyle X A not vdash B br br by the deduction theorem thus the deductive closure of br br br br X br br br A br br br br displaystyle X cup A br br is an element br br br br Y br br W br br br displaystyle Y in W br br such that br br br br Y br br X br br br displaystyle Y supseteq X br br br br br br Y br br A br br br displaystyle Y Vdash A br br and br br br br Y br br B br br br displaystyle Y not Vdash B br br br Let A be any formula which is not provable in the calculus Then A does not belong to the deductive closure X of the empty set thus br br br br X br br A br br br displaystyle X not Vdash A br br and A is not intuitionistically valid br br br See also br Applicative computing systems br B C K W system br Categorical abstract machine br Combinatory categorial grammar br Explicit substitution br Fixed point combinator br Graph reduction machine br Lambda calculus and Cylindric algebra other approaches to modelling quantification and eliminating variables br SKI combinator calculus br Supercombinator br To Mock a Mockingbird br br br br br br Literature br Barendregt Hendrik Pieter The Lambda Calculus Its Syntax and Semantics Studies in Logic and the Foundations of Mathematics Vol North Holland ISBN br Cherlin Edward Pure functions in APL and J Proceedings of the international conference on APL APL pp doi ISBN S CID br Curry Haskell Brooks Grundlagen der Kombinatorischen Logik Foundations of combinatorial logic American Journal of Mathematics in German The Johns Hopkins University Press doi JSTOR br Curry Haskell Brooks Feys Robert Combinatory Logic Vol I Amsterdam North Holland ISBN br Curry Haskell Brooks Hindley J Roger Seldin Jonathan P Combinatory Logic Vol II Amsterdam North Holland ISBN br Engeler E The Combinatory Programme PDF Birkh user pp br Field Anthony J Harrison Peter G Functional Programming Addison Wesley ISBN br Goldberg Mayer A construction of one point bases in extended lambda calculi Information Processing Letters doi j ipl br Hindley J Roger Meredith David Principal type schemes and condensed detachment Journal of Symbolic Logic doi JSTOR MR S CID br Hindley J Roger Seldin Jonathan P Lambda Calculus and Combinators An Introduction nd ed Cambridge University Press ISBN br Lachowski ukasz On the Complexity of the Standard Translation of Lambda Calculus into Combinatory Logic Reports on Mathematical Logic doi RM Retrieved September br Paulson Lawrence C Foundations of Functional Programming University of Cambridge br Quine Willard Van Orman Variables explained away Proceedings of the American Philosophical Society JSTOR Reprinted as Chapter of Quine br Quine Willard Van Orman Variables explained away Selected Logic Papers Enl ed print ed Cambridge Mass Harvard University Press pp ISBN br Sch nfinkel Moses ber die Bausteine der mathematischen Logik PDF Mathematische Annalen in German doi bf S CID The article that founded combinatory logic English translation Sch nfinkel br Sch nfinkel Moses Van Heijenoort Jean ed ber die Bausteine der mathematischen Logik On the building blocks of mathematical logic From Frege to G del A Source Book in Mathematical Logic Translated by Bauer Mengelberg Stefan Cambridge MA USA Harvard University Press pp ISBN OCLC br Seldin Jonathan P March The Logic of Curry and Church PDF Retrieved September br Smullyan Raymond To Mock a Mockingbird And Other Logic Puzzles Including an Amazing Adventure in Combinatory Logic Knopf ISBN A gentle introduction to combinatory logic presented as a series of recreational puzzles using bird watching metaphors br Smullyan Raymond Diagonalization and Self Reference Oxford logic guides Vol Oxford and New York Oxford University Press ISBN Chapters are a more formal introduction to combinatory logic with a special emphasis on fixed point results br S rensen Morten Heine B Urzyczyn Pawe Lectures on the Curry Howard Isomorphism PDF Studies in Logic and the Foundations of Mathematics Vol st ed Elsevier p ISBN Archived from the original PDF on Retrieved br Tromp John Binary Lambda Calculus and Combinatory Logic PDF In Calude Cristian S ed Randomness And Complexity from Leibniz To Chaitin World Scientific Publishing Company Archived from the original PDF on br Turner David A Another Algorithm for Bracket Abstraction The Journal of Symbolic Logic doi JSTOR S CID br Wolfengagen V E Combinatory logic in programming Computations with objects through examples and exercises nd ed Moscow Center JurInfoR Ltd ISBN br Wolfram Stephen Combinators A Centennial View Wolfram Media ISBN A celebration of the development of combinators a hundred years after they were introduced by Sch nfinkel eBook ISBN br br br External links br Stanford Encyclopedia of Philosophy Combinatory Logic by Katalin Bimb br Curry s block notes br Keenan David C To Dissect a Mockingbird A Graphical Notation for the Lambda Calculus with Animated Reduction br Rathman Chris Combinator Birds A table distilling much of the essence of Smullyan br Drag n Drop Combinators Java Applet br Binary Lambda Calculus and Combinatory Logic br Combinatory logic reduction web server br Wolfram Stephen April Combinators Year Celebration Wolfram Physics Project on YouTube Retrieved September 