title: Type class
id: 3647181
In computer science a type class is a type system construct that supports ad hoc polymorphism This is achieved by adding constraints to type variables in parametrically polymorphic types Such a constraint typically involves a type class T and a type variable a and means that a can only be instantiated to a type whose members support the overloaded operations associated with T br Type classes were first implemented in the Haskell programming language after first being proposed by Philip Wadler and Stephen Blott as an extension to eqtypes in Standard ML and were originally conceived as a way of implementing overloaded arithmetic and equality operators in a principled fashion br In contrast with the eqtypes of Standard ML overloading the equality operator through the use of type classes in Haskell does not require extensive modification of the compiler frontend or the underlying type system br br br Overview br Type classes are defined by specifying a set of function or constant names together with their respective types that must exist for every type that belongs to the class In Haskell types can be parameterized a type class Eq intended to contain types that admit equality would be declared in the following way br br where a is one instance of the type class Eq and a defines the function signatures for functions the equality and inequality functions which each take arguments of type a and return a boolean br The type variable a has kind br br br br br br br displaystyle br br br br br br br br br displaystyle br br is also known as Type in the latest GHC release meaning that the kind of Eq is br br The declaration may be read as stating a type a belongs to type class Eq if there are functions named and of the appropriate types defined on it A programmer could then define a function elem which determines if an element is in a list in the following way br br The function elem has the type a a Bool with the context Eq a which constrains the types which a can range over to those a which belong to the Eq type class Note Haskell can be called a class constraint br A programmer can make any type t a member of a given type class C by using an instance declaration that defines implementations of all of C s methods for the particular type t For instance if a programmer defines a new data type t they may then make this new type an instance of Eq by providing an equality function over values of type t in whatever way they see fit Once they have done this they may use the function elem on t that is lists of elements of type t br Note that type classes are different from classes in object oriented programming languages In particular Eq is not a type there is no such thing as a value of type Eq br Type classes are closely related to parametric polymorphism For example note that the type of elem as specified above would be the parametrically polymorphic type a a Bool were it not for the type class constraint Eq a br br br Higher kinded polymorphism br A type class need not take a type variable of kind Type but can take one of any kind These type classes with higher kinds are sometimes called constructor classes the constructors referred to are type constructors such as Maybe rather than data constructors such as Just An example is the Monad class br br The fact that m is applied to a type variable indicates that it has kind Type Type i e it takes a type and returns a type the kind of Monad is thus br br br Multi parameter type classes br Type classes permit multiple type parameters and so type classes can be seen as relations on types For example in the GHC standard library the class IArray expresses a general immutable array interface In this class the type class constraint IArray a e means that a is an array type that contains elements of type e This restriction on polymorphism is used to implement unboxed array types for example br Like multimethods multi parameter type classes support calling different implementations of a method depending on the types of multiple arguments and indeed return types Multi parameter type classes do not require searching for the method to call on every call at runtime minute rather the method to call is first compiled and stored in the dictionary of the type class instance just as with single parameter type classes br Haskell code that uses multi parameter type classes is not portable as this feature is not part of the Haskell standard The popular Haskell implementations GHC and Hugs support multi parameter type classes br br br Functional dependencies br In Haskell type classes have been refined to allow the programmer to declare functional dependencies between type parameters a concept inspired from relational database theory That is the programmer can assert that a given assignment of some subset of the type parameters uniquely determines the remaining type parameters For example a general monad m which carries a state parameter of type s satisfies the type class constraint Monad State s m In this constraint there is a functional dependency m s This means that for a given monad m of type class Monad State the state type accessible from m is uniquely determined This aids the compiler in type inference as well as aiding the programmer in type directed programming br Simon Peyton Jones has objected to the introduction of functional dependencies in Haskell on grounds of complexity br br br Type classes and implicit parameters br Type classes and implicit parameters are very similar in nature although not quite the same A polymorphic function with a type class constraint such as br br can be intuitively treated as a function that implicitly accepts an instance of Num br br The instance Num a is essentially a record that contains the instance definition of Num a This is in fact how type classes are implemented under the hood by the Glasgow Haskell Compiler br However there is a crucial difference implicit parameters are more flexible you can pass different instances of Num Int In contrast type classes enforce the so called coherence property which requires that there should only be one unique choice of instance for any given type The coherence property makes type classes somewhat antimodular which is why orphan instances instances that are defined in a module that neither contains the class nor the type of interest are strongly discouraged On the other hand coherence adds an additional level of safety to the language providing the programmer a guarantee that two disjoint parts of the same code will share the same instance br As an example an ordered set of type Set a requires a total ordering on the elements of type a in order to function This can be evidenced by a constraint Ord a which defines a comparison operator on the elements However there can be numerous ways to impose a total order Since set algorithms are generally intolerant of changes in the ordering once a set has been constructed passing an incompatible instance of Ord a to functions that operate on the set may lead to incorrect results or crashes Thus enforcing coherence of Ord a in this particular scenario is crucial br Instances or dictionaries in Scala type classes are just ordinary values in the language rather than a completely separate kind of entity While these instances are by default supplied by finding appropriate instances in scope to be used as the implicit actual parameters for explicitly declared implicit formal parameters the fact that they are ordinary values means that they can be supplied explicitly to resolve ambiguity As a result Scala type classes do not satisfy the coherence property and are effectively a syntactic sugar for implicit parameters br This is an example taken from the Cats documentation br br Coq version onwards also supports type classes by inferring the appropriate instances Recent versions of Agda also provide a similar feature called instance arguments br br br Other approaches to operator overloading br In Standard ML the mechanism of equality types corresponds roughly to Haskell s built in type class Eq but all equality operators are derived automatically by the compiler The programmer s control of the process is limited to designating which type components in a structure are equality types and which type variables in a polymorphic type range over equality types br SML s and OCaml s modules and functors can play a role similar to that of Haskell s type classes the principal difference being the role of type inference which makes type classes suitable for ad hoc polymorphism br The object oriented subset of OCaml is yet another approach which is somewhat comparable to the one of type classes br br br Related notions br An analogous notion for overloaded data implemented in GHC is that of type family br In C notably C has support for type classes using the Concepts C As an illustration the above mentioned Haskell example of typeclass Eq would be written as br br In Clean typeclasses are similar to Haskell but have a slightly different syntax br Rust supports traits which are a limited form of type classes with coherence br Mercury has typeclasses although they are not exactly the same as in Haskell br In Scala type classes are a programming idiom which can be implemented with existing language features such as implicit parameters not a separate language feature per se Because of the way they are implemented in Scala it is possible to explicitly specify which type class instance to use for a type at a particular place in the code in case of ambiguity However this is not necessarily a benefit as ambiguous type class instances can be error prone br The proof assistant Coq has also supported type classes in recent versions Unlike in ordinary programming languages in Coq any laws of a type class such as the monad laws that are stated within the type class definition must be mathematically proved of each type class instance before using them br br br See also br Polymorphism computer science other kinds of polymorphism br Haskell programming language the language in which type classes were first designed br Operator overloading one application of type classes br Monad functional programming Monad is an example of a type class br Concepts C since C br Rust programming language br br br br br br External links br Type Classes and Overloading A Gentle Introduction to Haskell June Version br Advanced Functional Programming course at Utrecht University lecture slides on Advanced Type Classes br Implementing and Understanding Type Classes 