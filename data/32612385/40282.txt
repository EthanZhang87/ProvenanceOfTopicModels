title: Type theory
id: 40282
In mathematics and theoretical computer science a type theory is the formal presentation of a specific type system Type theory is the academic study of type systems br Some type theories serve as alternatives to set theory as a foundation of mathematics Two influential type theories that have been proposed as foundations are br br Typed calculus of Alonzo Church br Intuitionistic type theory of Per Martin L f br Most computerized proof writing systems use a type theory for their foundation A common one is Thierry Coquand s Calculus of Inductive Constructions br br br History br br Type theory was created to avoid a paradox in a mathematical equation based on naive set theory and formal logic Russell s paradox first described in Gottlob Frege s The Foundations of Arithmetic is that without proper axioms it is possible to define the set of all sets that are not members of themselves this set both contains itself and does not contain itself Between and Bertrand Russell proposed various solutions to this problem br By Russell arrived at a ramified theory of types together with an axiom of reducibility both of which appeared in Whitehead and Russell s Principia Mathematica published in and This system avoided contradictions suggested in Russell s paradox by creating a hierarchy of types and then assigning each concrete mathematical entity to a specific type Entities of a given type were built exclusively of subtypes of that type thus preventing an entity from being defined using itself This resolution of Russell s paradox is similar to approaches taken in other formal systems such as Zermelo Fraenkel set theory br Type theory is particularly popular in conjunction with Alonzo Church s lambda calculus One notable early example of type theory is Church s simply typed lambda calculus Church s theory of types helped the formal system avoid the Kleene Rosser paradox that afflicted the original untyped lambda calculus Church demonstrated that it could serve as a foundation of mathematics and it was referred to as a higher order logic br In the modern literature type theory refers to a typed system based around lambda calculus One influential system is Per Martin L f s intuitionistic type theory which was proposed as a foundation for constructive mathematics Another is Thierry Coquand s calculus of constructions which is used as the foundation by Coq Lean and other computer proof assistants Type theory is an active area of research one direction being the development of homotopy type theory br br br Applications br br br Mathematical foundations br The first computer proof assistant called Automath used type theory to encode mathematics on a computer Martin L f specifically developed intuitionistic type theory to encode all mathematics to serve as a new foundation for mathematics There is ongoing research into mathematical foundations using homotopy type theory br Mathematicians working in category theory already had difficulty working with the widely accepted foundation of Zermelo Fraenkel set theory This led to proposals such as Lawvere s Elementary Theory of the Category of Sets ETCS Homotopy type theory continues in this line using type theory Researchers are exploring connections between dependent types especially the identity type and algebraic topology specifically homotopy br br br Proof assistants br br Much of the current research into type theory is driven by proof checkers interactive proof assistants and automated theorem provers Most of these systems use a type theory as the mathematical foundation for encoding proofs which is not surprising given the close connection between type theory and programming languages br br LF is used by Twelf often to define other type theories br many type theories which fall under higher order logic are used by the HOL family of provers and PVS br computational type theory is used by NuPRL br calculus of constructions and its derivatives are used by Coq Matita and Lean br UTT Luo s Unified Theory of dependent Types is used by Agda which is both a programming language and proof assistant br Many type theories are supported by LEGO and Isabelle Isabelle also supports foundations besides type theories such as ZFC Mizar is an example of a proof system that only supports set theory br br br Programming languages br Any static program analysis such as the type checking algorithms in the semantic analysis phase of compiler has a connection to type theory A prime example is Agda a programming language which uses UTT Luo s Unified Theory of dependent Types for its type system br The programming language ML was developed for manipulating type theories see LCF and its own type system was heavily influenced by them br br br Linguistics br Type theory is also widely used in formal theories of semantics of natural languages especially Montague grammar and its descendants In particular categorial grammars and pregroup grammars extensively use type constructors to define the types noun verb etc of words br The most common construction takes the basic types br br br br e br br br displaystyle e br br and br br br br t br br br displaystyle t br br for individuals and truth values respectively and defines the set of types recursively as follows br br if br br br br a br br br displaystyle a br br and br br br br b br br br displaystyle b br br are types then so is br br br br br a br br b br br br br displaystyle langle a b rangle br br br nothing except the basic types and what can be constructed from them by means of the previous clause are types br A complex type br br br br br a br br b br br br br displaystyle langle a b rangle br br is the type of functions from entities of type br br br br a br br br displaystyle a br br to entities of type br br br br b br br br displaystyle b br br Thus one has types like br br br br br e br br t br br br br displaystyle langle e t rangle br br which are interpreted as elements of the set of functions from entities to truth values i e indicator functions of sets of entities An expression of type br br br br br br e br br t br br br t br br br br displaystyle langle langle e t rangle t rangle br br is a function from sets of entities to truth values i e a indicator function of a set of sets This latter type is standardly taken to be the type of natural language quantifiers like everybody or nobody Montague Barwise and Cooper br Type theory with records is a formal semantics representation framework using records to express type theory types It has been used in natural language processing principally computational semantics and dialogue systems br br br Social sciences br Gregory Bateson introduced a theory of logical types into the social sciences his notions of double bind and logical levels are based on Russell s theory of types br br br Type theory as a logic br A type theory is a mathematical logic which is to say it is a collection of rules of inference that result in judgments Most logics have judgments asserting The proposition br br br br br br br displaystyle varphi br br is true or The formula br br br br br br br displaystyle varphi br br is a well formed formula A type theory has judgments that define types and assign them to a collection of formal objects known as terms A term and its type are often written together as br br br br br t br e br r br m br br br br br t br y br p br e br br br br br displaystyle mathrm term mathsf type br br br br br Terms br A term in logic is recursively defined as a constant symbol variable or a function application where a term is applied to another term Constant symbols could include the natural number br br br br br br br displaystyle br br the Boolean value br br br br br t br r br u br e br br br br displaystyle mathrm true br br and functions such as the successor function br br br br br S br br br br displaystyle mathrm S br br and conditional operator br br br br br i br f br br br br displaystyle mathrm if br br Thus some terms could be br br br br br br br displaystyle br br br br br br br br S br br br br br br br displaystyle mathrm S br br br br br br br br S br br br br br S br br br br br br br br displaystyle mathrm S mathrm S br br and br br br br br br i br f br br br br t br r br u br e br br br br br br br S br br br br br br br br displaystyle mathrm if mathrm true mathrm S br br br br br Judgments br Most type theories have judgments br br br br br br T br br br displaystyle T br br is a type br br br br br t br br br displaystyle t br br is a term of type br br br br T br br br displaystyle T br br br Type br br br br br T br br br br br br br displaystyle T br br is equal to type br br br br br T br br br br br br br displaystyle T br br br Terms br br br br br t br br br br br br br displaystyle t br br and br br br br br t br br br br br br br displaystyle t br br both of type br br br br T br br br displaystyle T br br are equal br Judgments may follow from assumptions For example one might say assuming br br br br x br br br displaystyle x br br is a term of type br br br br br br b br o br o br l br br br br br displaystyle mathsf bool br br and br br br br y br br br displaystyle y br br is a term of type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br it follows that br br br br br br i br f br br br x br br y br br y br br br br displaystyle mathrm if x y y br br is a term of type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br Such judgments are formally written with the turnstile symbol br br br br br br br displaystyle vdash br br br br br br br x br br br br b br o br o br l br br br br y br br br br n br a br t br br br br br br br if br br br br x br br y br br y br br br br br n br a br t br br br br br displaystyle x mathsf bool y mathsf nat vdash textrm if x y y mathsf nat br br br If there are no assumptions there will be nothing to the left of the turnstile br br br br br br br S br br br br br n br a br t br br br br br br n br a br t br br br br br displaystyle vdash mathrm S mathsf nat to mathsf nat br br br The list of assumptions on the left is the context of the judgment Capital greek letters such as br br br br br br br displaystyle Gamma br br and br br br br br br br displaystyle Delta br br are common choices to represent some or all of the assumptions The different judgments are thus usually written as follows br br Some textbooks use a triple equal sign br br br br br br br displaystyle equiv br br to stress that this is judgmental equality and thus an extrinsic notion of equality The judgments enforce that every term has a type The type will restrict which rules can be applied to a term br br br Rules of Inference br A type theory s inference rules say what judgments can be made based on the existence of other judgments Rules are expressed as a Gentzen style deduction using a horizontal line with the required input judgments above the line and the resulting judgment below the line For example the following inference rule states a substitution rule for judgmental equality br br br br br br br br br br t br br br T br br br br br br br br br T br br br br br br br T br br br br br br br br br br br br br t br br br T br br br br br br br br br br br displaystyle begin array c Gamma vdash t T qquad Delta vdash T T hline Gamma Delta vdash t T end array br br The rules are syntactic and work by rewriting The metavariables br br br br br br br displaystyle Gamma br br br br br br br br br displaystyle Delta br br br br br br t br br br displaystyle t br br br br br br br T br br br br br br br displaystyle T br br and br br br br br T br br br br br br br displaystyle T br br may actually consist of complex terms and types that contain many function applications not just single symbols br To generate a particular judgment in type theory there must be a rule to generate it as well as rules to generate all of that rule s required inputs and so on The applied rules form a proof tree where the top most rules need no assumptions One example of a rule that does not require any inputs is one that states the type of a constant term For example to assert that there is a term br br br br br br br displaystyle br br of type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br one would write the following br br br br br br br br br br br br n br a br t br br br br br br br br displaystyle begin array c hline vdash nat end array br br br br Type inhabitation br br Generally the desired conclusion of a proof in type theory is one of type inhabitation The decision problem of type inhabitation abbreviated by br br br br br t br br br br t br br br br br br displaystyle exists t Gamma vdash t tau br br is br br Given a context br br br br br br br displaystyle Gamma br br and a type br br br br br br br displaystyle tau br br decide whether there exists a term br br br br t br br br displaystyle t br br that can be assigned the type br br br br br br br displaystyle tau br br in the type environment br br br br br br br displaystyle Gamma br br br Girard s paradox shows that type inhabitation is strongly related to the consistency of a type system with Curry Howard correspondence To be sound such a system must have uninhabited types br A type theory usually has several rules including ones to br br create a judgment known as a context in this case br add an assumption to the context context weakening br rearrange the assumptions br use an assumption to create a variable br define reflexivity symmetry and transitivity for judgmental equality br define substitution for application of lambda terms br list all the interactions of equality such as substitution br define a hierarchy of type universes br assert the existence of new types br Also for each by rule type there are different kinds of rules br br type formation rules say how to create the type br term introduction rules define the canonical terms and constructor functions like pair and S br term elimination rules define the other functions like first second and R br computation rules specify how computation is performed with the type specific functions br For examples of rules an interested reader may follow Appendix A of the Homotopy Type Theory book or read Martin L f s Intuitionistic Type Theory br br br Connections to foundations br The logical framework of a type theory bears a resemblance to intuitionistic or constructive logic Formally type theory is often cited as an implementation of the Brouwer Heyting Kolmogorov interpretation of intuitionistic logic Additionally connections can be made to category theory and computer programs br br br Intuitionistic logic br When used as a foundation certain types are interpreted to be propositions statements that can be proven and terms inhabiting the type are interpreted to be proofs of that proposition When some types are interpreted as propositions there is a set of common types that can be used to connect them to make a Boolean algebra out of types However the logic is not classical logic but intuitionistic logic which is to say it does not have the law of excluded middle nor double negation br Under this intuitionistic interpretation there are common types that act as the logical operators br br Because the law of excluded middle does not hold there is no term of type br br br br br a br br A br br br A br br br br br br displaystyle Pi a A A to bot br br Likewise double negation does not hold so there is no term of type br br br br br A br br br br A br br br br br br br br A br br br displaystyle Pi A A to bot to bot to A br br br It is possible to include the law of excluded middle and double negation into a type theory by rule or assumption However terms may not compute down to canonical terms and it will interfere with the ability to determine if two terms are judgementally equal to each other br br br Constructive mathematics br Per Martin L f proposed his intuitionistic type theory as a foundation for constructive mathematics Constructive mathematics requires when proving there exists an br br br br x br br br displaystyle x br br with property br br br br P br br x br br br br displaystyle P x br br one must construct a particular br br br br x br br br displaystyle x br br and a proof that it has property br br br br P br br br displaystyle P br br In type theory existence is accomplished using the dependent product type and its proof requires a term of that type br An example of a non constructive proof is proof by contradiction The first step is assuming that br br br br x br br br displaystyle x br br does not exist and refuting it by contradiction The conclusion from that step is it is not the case that br br br br x br br br displaystyle x br br does not exist The last step is by double negation concluding that br br br br x br br br displaystyle x br br exists Constructive mathematics does not allow the last step of removing the double negation to conclude that br br br br x br br br displaystyle x br br exists br Most of the type theories proposed as foundations are constructive and this includes most of the ones used by proof assistants It is possible to add non constructive features to a type theory by rule or assumption These include operators on continuations such as call with current continuation However these operators tend to break desirable properties such as canonicity and parametricity br br br Curry Howard correspondence br The Curry Howard correspondence is the observed similarity between logics and programming languages The implication in logic A br br br br br br br displaystyle to br br B resembles a function from type A to type B For a variety of logics the rules are similar to expressions in a programming language s types The similarity goes farther as applications of the rules resemble programs in the programming languages Thus the correspondence is often summarized as proofs as programs br The opposition of terms and types can also be viewed as one of implementation and specification By program synthesis the computational counterpart of type inhabitation can be used to construct all or parts of programs from the specification given in the form of type information br br br Type inference br br Many programs that work with type theory e g interactive theorem provers also do type inferencing It lets them select the rules that the user intends with fewer actions by the user br br br Research areas br br br Category theory br Main article Category theory br Although the initial motivation for category theory was far removed from foundationalism the two fields turned out to have deep connections As John Lane Bell writes In fact categories can themselves be viewed as type theories of a certain kind this fact alone indicates that type theory is much more closely related to category theory than it is to set theory In brief a category can be viewed as a type theory by regarding its objects as types or sorts i e Roughly speaking a category may be thought of as a type theory shorn of its syntax A number of significant results follow in this way br br cartesian closed categories correspond to the typed calculus Lambek br C monoids categories with products and exponentials and one non terminal object correspond to the untyped calculus observed independently by Lambek and Dana Scott around br locally cartesian closed categories correspond to Martin L f type theories Seely br The interplay known as categorical logic has been a subject of active research since then see the monograph of Jacobs for instance br br br Homotopy type theory br Homotopy type theory attempts to combine type theory and category theory It focuses on equalities especially equalities between types Homotopy type theory differs from intuitionistic type theory mostly by its handling of the equality type In cubical type theory was proposed which is a homotopy type theory with normalization br br br Definitions br br br Terms and types br br br Atomic terms br The most basic types are called atoms and a term whose type is an atom is known as an atomic term Common atomic terms included in type theories are natural numbers often notated with the type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br Boolean logic values br br br br br t br r br u br e br br br br displaystyle mathrm true br br br br br br br f br a br l br s br e br br br br displaystyle mathrm false br br notated with the type br br br br br br b br o br o br l br br br br br displaystyle mathsf bool br br and formal variables whose type may vary For example the following may be atomic terms br br br br br br br br br n br a br t br br br br br displaystyle mathsf nat br br br br br br br t br r br u br e br br br br br b br o br o br l br br br br br displaystyle mathrm true mathsf bool br br br br br br x br br br br n br a br t br br br br br displaystyle x mathsf nat br br br br br br y br br br br b br o br o br l br br br br br displaystyle y mathsf bool br br br br Function terms br In addition to atomic terms most modern type theories also allow for functions Function types introduce an arrow symbol and are defined inductively If br br br br br br br displaystyle sigma br br and br br br br br br br displaystyle tau br br are types then the notation br br br br br br br br br displaystyle sigma to tau br br is the type of a function which takes a parameter of type br br br br br br br displaystyle sigma br br and returns a term of type br br br br br br br displaystyle tau br br Types of this form are known as simple types br Some terms may be declared directly as having a simple type such as the following term br br br br br a br d br d br br br br displaystyle mathrm add br br which takes in two natural numbers in sequence and returns one natural number br br br br br br a br d br d br br br br br n br a br t br br br br br br br n br a br t br br br br br br n br a br t br br br br br br displaystyle mathrm add mathsf nat to mathsf nat to mathsf nat br br br Strictly speaking a simple type only allows for one input and one output so a more faithful reading of the above type is that br br br br br a br d br d br br br br displaystyle mathrm add br br is a function which takes in a natural number and returns a function of the form br br br br br br n br a br t br br br br br br n br a br t br br br br br displaystyle mathsf nat to mathsf nat br br The parentheses clarify that br br br br br a br d br d br br br br displaystyle mathrm add br br does not have the type br br br br br br br n br a br t br br br br br br n br a br t br br br br br br br n br a br t br br br br br displaystyle mathsf nat to mathsf nat to mathsf nat br br which would be a function which takes in a function of natural numbers and returns a natural number The convention is that the arrow is right associative so the parentheses may be dropped from br br br br br a br d br d br br br br displaystyle mathrm add br br s type br br br Lambda terms br New function terms may be constructed using lambda expressions and are called lambda terms These terms are also defined inductively a lambda term has the form br br br br br br v br br t br br br br displaystyle lambda v t br br where br br br br v br br br displaystyle v br br is a formal variable and br br br br t br br br displaystyle t br br is a term and its type is notated br br br br br br br br br displaystyle sigma to tau br br where br br br br br br br displaystyle sigma br br is the type of br br br br v br br br displaystyle v br br and br br br br br br br displaystyle tau br br is the type of br br br br t br br br displaystyle t br br The following lambda term represents a function which doubles an input natural number br br br br br br br x br br br a br d br d br br br x br br x br br br br br n br a br t br br br br br br n br a br t br br br br br displaystyle lambda x mathrm add x x mathsf nat to mathsf nat br br br The variable is br br br br x br br br displaystyle x br br and implicit from the lambda term s type must have type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br The term br br br br br a br d br d br br br x br br x br br br displaystyle mathrm add x x br br has type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br which is seen by applying the function application inference rule twice Thus the lambda term has type br br br br br br n br a br t br br br br br br n br a br t br br br br br displaystyle mathsf nat to mathsf nat br br which means it is a function taking a natural number as an argument and returning a natural number br A lambda term is often referred to as an anonymous function because it lacks a name The concept of anonymous functions appears in many programming languages br br br Inference Rules br br br Function application br The power of type theories is in specifying how terms may be combined by way of inference rules Type theories which have functions also have the inference rule of function application if br br br br t br br br displaystyle t br br is a term of type br br br br br br br br br displaystyle sigma to tau br br and br br br br s br br br displaystyle s br br is a term of type br br br br br br br displaystyle sigma br br then the application of br br br br t br br br displaystyle t br br to br br br br s br br br displaystyle s br br often written br br br br br t br br s br br br br displaystyle t s br br has type br br br br br br br displaystyle tau br br For example if one knows the type notations br br br br br br br br nat br br br br br displaystyle textsf nat br br br br br br br br br br nat br br br br br displaystyle textsf nat br br and br br br br br br br br nat br br br br br displaystyle textsf nat br br then the following type notations can be deduced from function application br br br br br br br a br d br d br br br br br br br br nat br br br br br br nat br br br br br displaystyle mathrm add textsf nat to textsf nat br br br br br br br br br a br d br d br br br br br br br br br br br nat br br br br br displaystyle mathrm add textsf nat br br br br br br br br br a br d br d br br br br br br br br a br d br d br br br br br br br br br br br br nat br br br br br displaystyle mathrm add mathrm add textsf nat br br br Parentheses indicate the order of operations however by convention function application is left associative so parentheses can be dropped where appropriate In the case of the three examples above all parentheses could be omitted from the first two and the third may simplified to br br br br br a br d br d br br br br br br br a br d br d br br br br br br br br br br nat br br br br br displaystyle mathrm add mathrm add textsf nat br br br br br Reductions br Type theories that allow for lambda terms also include inference rules known as br br br br br br br displaystyle beta br br reduction and br br br br br br br displaystyle eta br br reduction They generalize the notion of function application to lambda terms Symbolically they are written br br br br br br br v br br t br br br s br br t br br v br br br s br br br br displaystyle lambda v t s rightarrow t v colon s br br br br br br br br br displaystyle beta br br reduction br br br br br br br v br br t br br v br br br t br br br displaystyle lambda v t v rightarrow t br br if br br br br v br br br displaystyle v br br is not a free variable in br br br br t br br br displaystyle t br br br br br br br br br displaystyle eta br br reduction br The first reduction describes how to evaluate a lambda term if a lambda expression br br br br br br v br br t br br br br displaystyle lambda v t br br is applied to a term br br br br s br br br displaystyle s br br one replaces every occurrence of br br br br v br br br displaystyle v br br in br br br br t br br br displaystyle t br br with br br br br s br br br displaystyle s br br The second reduction makes explicit the relationship between lambda expressions and function types if br br br br br br v br br t br br v br br br br displaystyle lambda v t v br br is a lambda term then it must be that br br br br t br br br displaystyle t br br is a function term because it is being applied to br br br br v br br br displaystyle v br br Therefore the lambda expression is equivalent to just br br br br t br br br displaystyle t br br as both take in one argument and apply br br br br t br br br displaystyle t br br to it br For example the following term may be br br br br br br br displaystyle beta br br reduced br br br br br br br x br br br a br d br d br br br x br br x br br br br br br a br d br d br br br br br br br br displaystyle lambda x mathrm add x x rightarrow mathrm add br br br In type theories that also establish notions of equality for types and terms there are corresponding inference rules of br br br br br br br displaystyle beta br br equality and br br br br br br br displaystyle eta br br equality br br br Common terms and types br br br Empty type br The empty type has no terms The type is usually written br br br br br br br displaystyle bot br br or br br br br br br br br br displaystyle mathbb br br One use for the empty type is proofs of type inhabitation If for a type br br br br a br br br displaystyle a br br it is consistent to derive a function of type br br br br a br br br br br displaystyle a to bot br br then br br br br a br br br displaystyle a br br is uninhabited which is to say it has no terms br br br Unit type br The unit type has exactly canonical term The type is written br br br br br br br displaystyle top br br or br br br br br br br br br displaystyle mathbb br br and the single canonical term is written br br br br br br br displaystyle ast br br The unit type is also used in proofs of type inhabitation If for a type br br br br a br br br displaystyle a br br it is consistent to derive a function of type br br br br br br a br br br displaystyle top to a br br then br br br br a br br br displaystyle a br br is inhabited which is to say it must have one or more terms br br br Boolean type br The Boolean type has exactly canonical terms The type is usually written br br br br br br bool br br br br br displaystyle textsf bool br br or br br br br br B br br br br displaystyle mathbb B br br or br br br br br br br br br displaystyle mathbb br br The canonical terms are usually br br br br br t br r br u br e br br br br displaystyle mathrm true br br and br br br br br f br a br l br s br e br br br br displaystyle mathrm false br br br br br Natural numbers br Natural numbers are usually implemented in the style of Peano Arithmetic There is a canonical term br br br br br br br br n br a br t br br br br br displaystyle mathsf nat br br for zero Canonical values larger than zero use iterated applications of a successor function br br br br br S br br br br br n br a br t br br br br br br n br a br t br br br br br displaystyle mathrm S mathsf nat to mathsf nat br br br br br Dependent typing br Some type theories allow for types of complex terms such as functions or lists to depend on the types of its arguments For example a type theory could have the dependent type br br br br br br l br i br s br t br br br br a br br br displaystyle mathsf list a br br which should correspond to lists of terms where each term must have type br br br br a br br br displaystyle a br br In this case br br br br br br l br i br s br t br br br br br displaystyle mathsf list br br has the type br br br br U br br U br br br displaystyle U to U br br where br br br br U br br br displaystyle U br br denotes the universe of all types in the theory br Some theories also permit types to be dependent on terms instead of types For example a theory could have the type br br br br br br v br e br c br t br o br r br br br br n br br br displaystyle mathsf vector n br br where br br br br n br br br displaystyle n br br is a term of type br br br br br br n br a br t br br br br br displaystyle mathsf nat br br encoding the length of the vector This allows for greater specificity and type safety functions with vector length restrictions or length matching requirements such as the dot product can encode this requirement as part of the type br There are foundational issues that can arise from dependent types if a theory is not careful about what dependencies are allowed such as Girard s Paradox The logician Henk Barendegt introduced the lambda cube as a framework for studying various restrictions and levels of dependent typing br br br Product type br The product type depends on two types and its terms are commonly written as ordered pairs br br br br br s br br t br br br br displaystyle s t br br or with the symbol br br br br br br br displaystyle times br br The pair br br br br br s br br t br br br br displaystyle s t br br has the product type br br br br br br br br br displaystyle sigma times tau br br where br br br br br br br displaystyle sigma br br is the type of br br br br s br br br displaystyle s br br and br br br br br br br displaystyle tau br br is the type of br br br br t br br br displaystyle t br br The product type is usually defined with eliminator functions br br br br br f br i br r br s br t br br br br br br br br br br br br br br br br br br displaystyle mathrm first Pi sigma tau sigma times tau to sigma br br and br br br br br s br e br c br o br n br d br br br br br br br br br br br br br br br br br br displaystyle mathrm second Pi sigma tau sigma times tau to tau br br br br br br br br f br i br r br s br t br br br br s br br t br br br br displaystyle mathrm first s t br br returns br br br br s br br br displaystyle s br br and br br br br br br s br e br c br o br n br d br br br br s br br t br br br br displaystyle mathrm second s t br br returns br br br br t br br br displaystyle t br br br Besides ordered pairs this type is used for the concepts of logical conjunction and intersection br br br Sum type br The sum type depends on two types and it is commonly written with the symbol br br br br br br br displaystyle br br or br br br br br br br displaystyle sqcup br br In programming languages sum types may be referred to as tagged unions The type br br br br br br br br br displaystyle sigma sqcup tau br br is usually defined with constructors br br br br br l br e br f br t br br br br br br br br br br br br displaystyle mathrm left sigma to sigma sqcup tau br br and br br br br br r br i br g br h br t br br br br br br br br br br br br displaystyle mathrm right tau to sigma sqcup tau br br which are injective and an eliminator function br br br br br m br a br t br c br h br br br br br br br br br br br br br br br br br br br br br br br br br br br br br br displaystyle mathrm match Pi rho sigma to rho to tau to rho to sigma sqcup tau to rho br br such that br br br br br br m br a br t br c br h br br br f br br g br br br br l br e br f br t br br br x br br br br displaystyle mathrm match f g mathrm left x br br returns br br br br f br br x br br br displaystyle f x br br and br br br br br br m br a br t br c br h br br br f br br g br br br br r br i br g br h br t br br br y br br br br displaystyle mathrm match f g mathrm right y br br returns br br br br g br br y br br br displaystyle g y br br br The sum type is used for the concepts of logical disjunction and union br br br Dependent products and sums br Two common type dependencies dependent product and dependent sum types allow for the theory to encode BHK intuitionistic logic by acting as equivalents to universal and existential quantification this is formalized by Curry Howard Correspondence As they also connect to products and sums in set theory they are often written with the symbols br br br br br br br displaystyle Pi br br and br br br br br br br displaystyle Sigma br br respectively Dependent product and sum types commonly appear in function types and are frequently incorporated in programming languages br For example consider a function br br br br br a br p br p br e br n br d br br br br displaystyle mathrm append br br which takes in a br br br br br br l br i br s br t br br br br a br br br displaystyle mathsf list a br br and a term of type br br br br a br br br displaystyle a br br and returns the list with the element at the end The type annotation of such a function would be br br br br br a br p br p br e br n br d br br br br br br a br br br br l br i br s br t br br br br a br br a br br br br l br i br s br t br br br br a br br br br displaystyle mathrm append Pi a mathsf list a to a to mathsf list a br br which can be read as for any type br br br br a br br br displaystyle a br br pass in a br br br br br br l br i br s br t br br br br a br br br displaystyle mathsf list a br br and an br br br br a br br br displaystyle a br br and return a br br br br br br l br i br s br t br br br br a br br br displaystyle mathsf list a br br br Sum types are seen in dependent pairs where the second type depends on the value of the first term This arises naturally in computer science where functions may return different types of outputs based on the input For example the Boolean type is usually defined with an eliminator function br br br br br i br f br br br br displaystyle mathrm if br br which takes three arguments and behaves as follows br br br br br br i br f br br br br t br r br u br e br br br x br br y br br br displaystyle mathrm if mathrm true x y br br returns br br br br x br br br displaystyle x br br and br br br br br br i br f br br br br f br a br l br s br e br br br x br br y br br br displaystyle mathrm if mathrm false x y br br returns br br br br y br br br displaystyle y br br br The return type of this function depends on its br br br br br br b br o br o br l br br br br br displaystyle mathsf bool br br input If the type theory allows for dependent types then it is possible to define a function br br br br br T br F br br br br br b br o br o br l br br br br U br br U br br U br br br displaystyle mathrm TF colon mathsf bool to U to U to U br br such that br br br br br br T br F br br br br t br r br u br e br br br br br br br br displaystyle mathrm TF mathrm true sigma tau br br returns br br br br br br br displaystyle sigma br br and br br br br br br T br F br br br br f br a br l br s br e br br br br br br br br displaystyle mathrm TF mathrm false sigma tau br br returns br br br br br br br displaystyle tau br br br The type of br br br br br i br f br br br br displaystyle mathrm if br br may then be written as br br br br br br br br br br br br br b br o br o br l br br br br br br br br br br br x br br br br bool br br br br br T br F br br br x br br br br br br br br br displaystyle Pi sigma tau mathsf bool to sigma to tau to Sigma x textsf bool mathrm TF x sigma tau br br br br br Identity type br Following the notion of Curry Howard Correspondence the identity type is a type introduced to mirror propositional equivalence as opposed to the judgmental syntactic equivalence that type theory already provides br An identity type requires two terms of the same type and is written with the symbol br br br br br br br displaystyle br br For example if br br br br x br br br br br displaystyle x br br and br br br br br br x br br br displaystyle x br br are terms then br br br br x br br br br br br x br br br displaystyle x x br br is a possible type Canonical terms are created with a reflexivity function br br br br br r br e br f br l br br br br displaystyle mathrm refl br br For a term br br br br t br br br displaystyle t br br the call br br br br br r br e br f br l br br br t br br br displaystyle mathrm refl t br br returns the canonical term inhabiting the type br br br br t br br t br br br displaystyle t t br br br The complexities of equality in type theory make it an active research topic homotopy type theory is a notable area of research that mainly deals with equality in type theory br br br Inductive types br Inductive types are a general template for creating a large variety of types In fact all the types described above and more can be defined using the rules of inductive types Two methods of generating inductive types are induction recursion and induction induction A method that only uses lambda terms is Scott encoding br Some proof assistants such as Coq and Lean are based on the calculus for inductive constructions which is a calculus of constructions with inductive types br br br Differences from set theory br The most commonly accepted foundation for mathematics is first order logic with the language and axioms of Zermelo Fraenkel set theory with the axiom of choice abbreviated ZFC Type theories having sufficient expressibility may also act as a foundation of mathematics There are a number of differences between these two approaches br br Set theory has both rules and axioms while type theories only have rules Type theories in general do not have axioms and are defined by their rules of inference br Classical set theory and logic have the law of excluded middle When a type theory encodes the concepts of and and or as types it leads to intuitionistic logic and does not necessarily have the law of excluded middle br In set theory an element is not restricted to one set The element can appear in subsets and unions with other sets In type theory terms generally belong to only one type Where a subset would be used type theory can use a predicate function or use a dependently typed product type where each element br br br br x br br br displaystyle x br br is paired with a proof that the subset s property holds for br br br br x br br br displaystyle x br br Where a union would be used type theory uses the sum type which contains new canonical terms br Type theory has a built in notion of computation Thus and are different terms in type theory but they compute to the same value Moreover functions are defined computationally as lambda terms In set theory means that is just another way to refer the value Type theory s computation does require a complicated concept of equality br Set theory encodes numbers as sets Type theory can encode numbers as functions using Church encoding or more naturally as inductive types and the construction closely resembles Peano s axioms br In type theory proofs are types whereas in set theory proofs are part of the underlying first order logic br Proponents of type theory will also point out its connection to constructive mathematics through the BHK interpretation its connection to logic by the Curry Howard isomorphism and its connections to Category theory br br br Properties of type theories br Terms usually belong to a single type However there are set theories that define subtyping br Computation takes place by repeated application of rules Many types of theories are strongly normalizing which means that any order of applying the rules will always end in the same result However some are not In a normalizing type theory the one directional computation rules are called reduction rules and applying the rules reduces the term If a rule is not one directional it is called a conversion rule br Some combinations of types are equivalent to other combinations of types When functions are considered exponentiation the combinations of types can be written similarly to algebraic identities Thus br br br br br br br br br br A br br A br br br displaystyle mathbb A cong A br br br br br br br br br br br br A br br A br br br displaystyle mathbb times A cong A br br br br br br br br br br br br br br br br br br br br br br br br br displaystyle mathbb mathbb cong mathbb br br br br br br br A br br B br br C br br br br br A br br B br br br br br A br br C br br br br br displaystyle A B C cong A B times A C br br br br br br br A br br B br br C br br br br br br A br br B br br br br br br C br br br br br displaystyle A B times C cong A B C br br br br br Axioms br Most type theories do not have axioms This is because a type theory is defined by its rules of inference This is a source of confusion for people familiar with Set Theory where a theory is defined by both the rules of inference for a logic such as first order logic and axioms about sets br Sometimes a type theory will add a few axioms An axiom is a judgment that is accepted without a derivation using the rules of inference They are often added to ensure properties that cannot be added cleanly through the rules br Axioms can cause problems if they introduce terms without a way to compute on those terms That is axioms can interfere with the normalizing property of the type theory br Some commonly encountered axioms are br br Axiom K ensures uniqueness of identity proofs That is that every term of an identity type is equal to reflexivity br Univalence Axiom holds that equivalence of types is equality of types The research into this property led to cubical type theory where the property holds without needing an axiom br Law of Excluded Middle is often added to satisfy users who want classical logic instead of intuitionistic logic br The Axiom of Choice does not need to be added to type theory because in most type theories it can be derived from the rules of inference This is because of the constructive nature of type theory where proving that a value exists requires a method to compute the value The Axiom of Choice is less powerful in type theory than most set theories because type theory s functions must be computable and being syntax driven the number of terms in a type must be countable See Axiom of choice In constructive mathematics br br br List of type theories br br br Major br Simply typed lambda calculus which is a higher order logic br intuitionistic type theory br system F br LF is often used to define other type theories br calculus of constructions and its derivatives br br br Minor br Automath br ST type theory br UTT Luo s Unified Theory of dependent Types br some forms of combinatory logic br others defined in the lambda cube also known as pure type systems br others under the name typed lambda calculus br br br Active research br Homotopy type theory explores equality of types br Cubical Type Theory is an implementation of homotopy type theory br br br See also br Foundations of mathematics br Logic br br br Further reading br br br Notes br br br br br br External links br br br Introductory material br Type Theory at nLab which has articles on many topics br Intuitionistic Type Theory article at the Stanford Encyclopedia of Philosophy br Lambda Calculi with Types book by Henk Barendregt br Calculus of Constructions Typed Lambda Calculus textbook style paper by Helmut Brandl br Intuitionistic Type Theory notes by Per Martin L f br Programming in Martin L f s Type Theory book br Homotopy Type Theory book which proposed homotopy type theory as a mathematical foundation br br br Advanced material br Robert L Constable ed Computational type theory Scholarpedia br The TYPES Forum moderated e mail forum focusing on type theory in computer science operating since br The Nuprl Book Introduction to Type Theory br Types Project lecture notes of summer schools br The summer school has introductory lectures br Oregon Programming Languages Summer School many lectures and some notes br Summer lectures including Robert Harper s talks on YouTube br Summer Types Logic Semantics and Verification br Andrej Bauer s blog