title: Prolog
id: 23485
Prolog is a logic programming language that has its origins in artificial intelligence automated theorem proving and computational linguistics br Prolog has its roots in first order logic a formal logic and unlike many other programming languages Prolog is intended primarily as a declarative programming language the program is a set of facts and rules which define relations A computation is initiated by running a query over the program br Prolog was one of the first logic programming languages and remains the most popular such language today with several free and commercial implementations available The language has been used for theorem proving expert systems term rewriting type systems and automated planning as well as its original intended field of use natural language processing br Prolog is a Turing complete general purpose programming language which is well suited for intelligent knowledge processing applications br br br Syntax and semantics br br In Prolog program logic is expressed in terms of relations and a computation is initiated by running a query over these relations Relations and queries are constructed using Prolog s single data type the term Relations are defined by clauses Given a query the Prolog engine attempts to find a resolution refutation of the negated query If the negated query can be refuted i e an instantiation for all free variables is found that makes the union of clauses and the singleton set consisting of the negated query false it follows that the original query with the found instantiation applied is a logical consequence of the program This makes Prolog and other logic programming languages particularly useful for database symbolic mathematics and language parsing applications Because Prolog allows impure predicates checking the truth value of certain special predicates may have some deliberate side effect such as printing a value to the screen Because of this the programmer is permitted to use some amount of conventional imperative programming when the logical paradigm is inconvenient It has a purely logical subset called pure Prolog as well as a number of extralogical features br br br Data types br Prolog s single data type is the term Terms are either atoms numbers variables or compound terms br br An atom is a symbol name starting with a lower case letter or guarded by quotes Examples of atoms include x red Taco some atom and p a br Numbers can be floats or integers Most of the major Prolog systems support arbitrary length integer numbers br Variables are denoted by a string consisting of letters numbers and underscore characters and beginning with an upper case letter or underscore Variables closely resemble variables in logic in that they are placeholders for arbitrary terms br A compound term is composed of an atom called a functor and a number of arguments which are again terms Compound terms are ordinarily written as a functor followed by a comma separated list of argument terms which is contained in parentheses The number of arguments is called the term s arity An atom can be regarded as a compound term with arity zero An example of a compound term is person friends zelda tom jim br Special cases of compound terms br br A List is an ordered collection of terms It is denoted by square brackets with the terms separated by commas or in the case of the empty list by For example or red green blue br Strings A sequence of characters surrounded by quotes is equivalent to either a list of numeric character codes a list of characters atoms of length or an atom depending on the value of the Prolog flag double quotes For example to be or not to be br br br Rules and facts br Prolog programs describe relations defined by means of clauses Pure Prolog is restricted to Horn clauses Two types of Horn clauses are used to define Prolog programs rules and facts A rule is of the form br br and is read as Head is true if Body is true A rule s body consists of calls to predicates which are called the rule s goals The built in logical operator meaning an arity operator with name denotes conjunction of goals and denotes disjunction Conjunctions and disjunctions can only appear in the body not in the head of a rule br Clauses with empty bodies are called facts An example of a fact is br br which is equivalent to the rule br br The built in predicate true is always true br Given the above fact one can ask br is socrates a human br br what things are humans br br Clauses with bodies are called rules An example of a rule is br br If we add that rule and ask what things are mortals br br br Predicates and programs br A predicate or procedure definition is a collection of clauses whose heads have the same name and arity We use the notation name arity to refer to predicates A logic program is a set of predicates For example the following Prolog program which defines some family relations has four predicates br Predicate father child has three clauses all of which are facts and predicate parent child has two clauses both are rules br Due to the relational nature of many built in predicates they can typically be used in several directions For example length can be used to determine the length of a list length List L given a list List and to generate a list skeleton of a given length length X and to generate both list skeletons and their lengths together length X L Similarly append can be used both to append two lists append ListA ListB X given lists ListA and ListB and to split a given list into parts append X Y List given a list List For this reason a comparatively small set of library predicates suffices for many Prolog programs br As a general purpose language Prolog also provides various built in predicates to perform routine activities like input output using graphics and otherwise communicating with the operating system These predicates are not given a relational meaning and are only useful for the side effects they exhibit on the system For example the predicate write displays a term on the screen br br br Loops and recursion br Iterative algorithms can be implemented by means of recursive predicates br br Consider the parent child predicate defined in the family relation program above The following Prolog program defines the ancestor relation It expresses that X is an ancestor of Y if X is parent of Y or X is parent of an ancestor of Y It is recursive because it is defined in terms of itself there is a call to predicate ancestor in the body of the second clause br br br Execution br Execution of a Prolog program is initiated by the user s posting of a single goal called the query Logically the Prolog engine tries to find a resolution refutation of the negated query The resolution method used by Prolog is called SLD resolution If the negated query can be refuted it follows that the query with the appropriate variable bindings in place is a logical consequence of the program In that case all generated variable bindings are reported to the user and the query is said to have succeeded Operationally Prolog s execution strategy can be thought of as a generalization of function calls in other languages one difference being that multiple clause heads can match a given call In that case the system creates a choice point unifies the goal with the clause head of the first alternative and continues with the goals of that first alternative If any goal fails in the course of executing the program all variable bindings that were made since the most recent choice point was created are undone and execution continues with the next alternative of that choice point This execution strategy is called chronological backtracking For example given the family relation program defined above the following query will be evaluated to true br This is obtained as follows Initially the only matching clause head for the query sibling sally erica is the first one so proving the query is equivalent to proving the body of that clause with the appropriate variable bindings in place i e the conjunction parent child Z sally parent child Z erica The next goal to be proved is the leftmost one of this conjunction i e parent child Z sally Two clause heads match this goal The system creates a choice point and tries the first alternative whose body is father child Z sally This goal can be proved using the fact father child tom sally so the binding Z tom is generated and the next goal to be proved is the second part of the above conjunction parent child tom erica Again this can be proved by the corresponding fact Since all goals could be proved the query succeeds Since the query contained no variables no bindings are reported to the user A query with variables like br br enumerates all valid answers on backtracking br Notice that with the code as stated above the query sibling sally sally also succeeds One would insert additional goals to describe the relevant restrictions if desired br br br Negation br The built in Prolog predicate provides negation as failure which allows for non monotonic reasoning The goal illegal X in the rule br br is evaluated as follows Prolog attempts to prove illegal X If a proof for that goal can be found the original goal i e illegal X fails If no proof can be found the original goal succeeds Therefore the prefix operator is called the not provable operator since the query Goal succeeds if Goal is not provable This kind of negation is sound if its argument is ground i e contains no variables Soundness is lost if the argument contains variables and the proof procedure is complete In particular the query legal X now cannot be used to enumerate all things that are legal br br br Programming in Prolog br In Prolog loading code is referred to as consulting Prolog can be used interactively by entering queries at the Prolog prompt If there is no solution Prolog writes no If a solution exists then it is printed If there are multiple solutions to the query then these can be requested by entering a semi colon There are guidelines on good programming practice to improve code efficiency readability and maintainability br Here follow some example programs written in Prolog br br br Hello World br Example of a basic query in a couple of popular Prolog dialects br br This comparison shows the prompt vs and resolution status true vs yes false vs no can differ from one Prolog implementation to another br br br Compiler optimization br Any computation can be expressed declaratively as a sequence of state transitions As an example an optimizing compiler with three optimization passes could be implemented as a relation between an initial program and its optimized form br br or equivalently using DCG notation br br br Quicksort br The quicksort sorting algorithm relating a list to its sorted version br br br Design patterns of Prolog br A design pattern is a general reusable solution to a commonly occurring problem in software design Some design patterns in Prolog are skeletons techniques cliches program schemata logic description schemata and higher order programming br br br Higher order programming br br A higher order predicate is a predicate that takes one or more other predicates as arguments Although support for higher order programming takes Prolog outside the domain of first order logic which does not allow quantification over predicates ISO Prolog now has some built in higher order predicates such as call call call findall setof and bagof Furthermore since arbitrary Prolog goals can be constructed and evaluated at run time it is easy to write higher order predicates like maplist which applies an arbitrary predicate to each member of a given list and sublist which filters elements that satisfy a given predicate also allowing for currying br To convert solutions from temporal representation answer substitutions on backtracking to spatial representation terms Prolog has various all solutions predicates that collect all answer substitutions of a given query in a list This can be used for list comprehension For example perfect numbers equal the sum of their proper divisors br br This can be used to enumerate perfect numbers and to check if a number is perfect br As another example the predicate maplist applies a predicate P to all corresponding positions in a pair of lists br br When P is a predicate that for all X P X Y unifies Y with a single unique value maplist P Xs Ys is equivalent to applying the map function in functional programming as Ys map Function Xs br Higher order programming style in Prolog was pioneered in HiLog and Prolog br br br Modules br For programming in the large Prolog provides a module system which is in the ISO Standard br However while most Prolog systems support structuring the code into modules virtually no implementation adheres to the modules part of the ISO standard Instead most Prolog systems have decided to support as de facto module standard the Quintus SICStus module system However further convenience predicates concerning modules are provided by some implementations only and often have subtle differences in their semantics br Some systems chose to implement module concepts as source to source compilation into base ISO Prolog as is the case of Logtalk GNU Prolog initially diverted from ISO modules opting instead for Contextual Logic Programming in which unit module loading and unloading can be made dynamically Ciao designed a strict module system that while being basically compatible with the de facto standard used by other Prolog systems is amenable to precise static analysis supports term hiding and facilitates programming in the large XSB takes a different approach and offers an atom based module system The latter two Prolog systems allow controlling the visibility of terms in addition to that of predicates br br br Parsing br br There is a special notation called definite clause grammars DCGs A rule defined via instead of is expanded by the preprocessor expand term a facility analogous to macros in other languages according to a few straightforward rewriting rules resulting in ordinary Prolog clauses Most notably the rewriting equips the predicate with two additional arguments which can be used to implicitly thread state around analogous to monads in other languages DCGs are often used to write parsers or list generators as they also provide a convenient interface to difference lists br br br Meta interpreters and reflection br Prolog is a homoiconic language and provides many facilities for reflective programming reflection Its implicit execution strategy makes it possible to write a concise meta circular evaluator also called meta interpreter for pure Prolog code br br where true represents an empty conjunction and clause Head Body unifies with clauses in the database of the form Head Body br Since Prolog programs are themselves sequences of Prolog terms is an infix operator that are easily read and inspected using built in mechanisms like read it is possible to write customized interpreters that augment Prolog with domain specific features For example Sterling and Shapiro present a meta interpreter that performs reasoning with uncertainty reproduced here with slight modifications br br This interpreter uses a table of built in Prolog predicates of the form br br and clauses represented as clause cf Head Body Certainty Given those it can be called as solve Goal Certainty to execute Goal and obtain a measure of certainty about the result br br br Turing completeness br Pure Prolog is based on a subset of first order predicate logic Horn clauses which is Turing complete Turing completeness of Prolog can be shown by using it to simulate a Turing machine br br A simple example Turing machine is specified by the facts br br This machine performs incrementation by one of a number in unary encoding It loops over any number of cells and appends an additional at the end Example query and result br br This illustrates how any computation can be expressed declaratively as a sequence of state transitions implemented in Prolog as a relation between successive states of interest br br br Implementation br br br ISO Prolog br The International Organization for Standardization ISO Prolog technical standard consists of two parts ISO IEC published in aims to standardize the existing practices of the many implementations of the core elements of Prolog It has clarified aspects of the language that were previously ambiguous and leads to portable programs There are three corrigenda Cor Cor and Cor ISO IEC published in adds support for modules to the standard The standard is maintained by the ISO IEC JTC SC WG working group ANSI X J is the US Technical Advisory Group for the standard br br br Compilation br For efficiency Prolog code is typically compiled to abstract machine code often influenced by the register based Warren Abstract Machine WAM instruction set Some implementations employ abstract interpretation to derive type and mode information of predicates at compile time or compile to real machine code for high performance Devising efficient implementation methods for Prolog code is a field of active research in the logic programming community and various other execution methods are employed in some implementations These include clause binarization and stack based virtual machines br br br Tail recursion br Prolog systems typically implement a well known optimization method called tail call optimization TCO for deterministic predicates exhibiting tail recursion or more generally tail calls A clause s stack frame is discarded before performing a call in a tail position Therefore deterministic tail recursive predicates are executed with constant stack space like loops in other languages br br br Term indexing br br Finding clauses that are unifiable with a term in a query is linear in the number of clauses Term indexing uses a data structure that enables sub linear time lookups Indexing only affects program performance it does not affect semantics Most Prologs only use indexing on the first term as indexing on all terms is expensive but techniques based on field encoded words or superimposed codewords provide fast indexing across the full query and head br br br Hashing br Some Prolog systems such as WIN PROLOG and SWI Prolog now implement hashing to help handle large datasets more efficiently This tends to yield very large performance gains when working with large corpora such as WordNet br br br Tabling br br Some Prolog systems B Prolog XSB SWI Prolog YAP and Ciao implement a memoization method called tabling which frees the user from manually storing intermediate results Tabling is a space time tradeoff execution time can be reduced by using more memory to store intermediate results br br Subgoals encountered in a query evaluation are maintained in a table along with answers to these subgoals If a subgoal is re encountered the evaluation reuses information from the table rather than re performing resolution against program clauses br Tabling can be extended in various directions It can support recursive predicates through SLG resolution or linear tabling In a multi threaded Prolog system tabling results could be kept private to a thread or shared among all threads And in incremental tabling tabling might react to changes br br br Implementation in hardware br During the Fifth Generation Computer Systems project there were attempts to implement Prolog in hardware with the aim of achieving faster execution with dedicated architectures Furthermore Prolog has a number of properties that may allow speed up through parallel execution A more recent approach has been to compile restricted Prolog programs to a field programmable gate array However rapid progress in general purpose hardware has consistently overtaken more specialised architectures br Sega implemented Prolog for use with the Sega AI Computer released for the Japanese market in Prolog was used for reading natural language inputs in the Japanese language via a touch pad br br br Limits br Although Prolog is widely used in research and education Prolog and other logic programming languages have not had a significant impact on the computer industry in general Most applications are small by industrial standards with few exceeding lines of code Programming in the large is considered to be complex because not all Prolog compilers support modules and there are compatibility problems between the module systems of the major Prolog compilers Portability of Prolog code across implementations has also been a problem but developments since have meant the portability within the family of Edinburgh Quintus derived Prolog implementations is good enough to allow for maintaining portable real world applications br Software developed in Prolog has been criticised for having a high performance penalty compared to conventional programming languages In particular Prolog s non deterministic evaluation strategy can be problematic when programming deterministic computations or when even using don t care non determinism where a single choice is made instead of backtracking over all possibilities Cuts and other language constructs may have to be used to achieve desirable performance destroying one of Prolog s main attractions the ability to run programs backwards and forwards br Prolog is not purely declarative because of constructs like the cut operator a procedural reading of a Prolog program is needed to understand it The order of clauses in a Prolog program is significant as the execution strategy of the language depends on it Other logic programming languages such as Datalog are truly declarative but restrict the language As a result many practical Prolog programs are written to conform to Prolog s depth first search order rather than as purely declarative logic programs br br br Extensions br Various implementations have been developed from Prolog to extend logic programming abilities in many directions These include types modes constraint logic programming CLP object oriented logic programming OOLP concurrency linear logic LLP functional and higher order logic programming abilities plus interoperability with knowledge bases br br br Types br Prolog is an untyped language Attempts to introduce and extend Prolog with types began in the s and continue as of Type information is useful not only for type safety but also for reasoning about Prolog programs br br br Modes br br The syntax of Prolog does not specify which arguments of a predicate are inputs and which are outputs However this information is significant and it is recommended that it be included in the comments Modes provide valuable information when reasoning about Prolog programs and can also be used to accelerate execution br br br Constraints br Constraint logic programming extends Prolog to include concepts from constraint satisfaction A constraint logic program allows constraints in the body of clauses such as A X Y X Y It is suited to large scale combinatorial optimisation problems and is thus useful for applications in industrial settings such as automated time tabling and production scheduling Most Prolog systems ship with at least one constraint solver for finite domains and often also with solvers for other domains like rational numbers br br br Object orientation br Flora is an object oriented knowledge representation and reasoning system based on F logic and incorporates HiLog Transaction logic and defeasible reasoning br Logtalk is an object oriented logic programming language that can use most Prolog implementations as a back end compiler As a multi paradigm language it includes support for both prototypes and classes br Oblog is a small portable object oriented extension to Prolog by Margaret McDougall of EdCAAD University of Edinburgh br Objlog was a frame based language combining objects and Prolog II from CNRS Marseille France br Prolog was developed by Logic Programming Associates and first released in for MS DOS PCs Support for other platforms was added and a second version was released in A book about Prolog by Chris Moss was published by Addison Wesley in br Visual Prolog is a multi paradigm language with interfaces classes implementations and object expressions br br br Graphics br Prolog systems that provide a graphics library are SWI Prolog Visual Prolog WIN PROLOG and B Prolog br br br Concurrency br Prolog MPI is an open source SWI Prolog extension for distributed computing over the Message Passing Interface Also there are various concurrent Prolog programming languages br br br Web programming br Some Prolog implementations notably Visual Prolog SWI Prolog and Ciao support server side web programming with support for web protocols HTML and XML There are also extensions to support semantic web formats such as Resource Description Framework RDF and Web Ontology Language OWL Prolog has also been suggested as a client side language In addition Visual Prolog supports JSON RPC and Websockets br br br Adobe Flash br Cedar Archived at the Wayback Machine is a free and basic Prolog interpreter From version and above Cedar has a FCA Flash Cedar App support This provides a new platform to programming in Prolog through ActionScript br br br Other br F logic extends Prolog with frames objects for knowledge representation br Transaction logic extends Prolog with a logical theory of state changing update operators It has both a model theoretic and procedural semantics br OW Prolog has been created in order to answer Prolog s lack of graphics and interface br br br Interfaces to other languages br Frameworks exist which can bridge between Prolog and other languages br br The LPA Intelligence Server allows embedding LPA Prolog for Windows in other programming languages including C C C Java Visual Basic VB Delphi NET Lua Python and others It exploits the dedicated string data type which LPA Prolog provides br The Logic Server Application Programming Interface API allows both the extension and embedding of Prolog in C C Java Visual Basic VB Delphi NET and any language or environment which can call a dll or so It is implemented for Amzi Prolog Logic Server but the API specification can be made available for any implementation br JPL is a bi directional Java Prolog bridge which ships with SWI Prolog by default allowing Java and Prolog to call each other recursively It is known to have good concurrency support and is under active development br InterProlog a programming library bridge between Java and Prolog implementing bi directional predicate method calling between both languages Java objects can be mapped into Prolog terms and vice versa Allows the development of graphical user interfaces GUIs and other functions in Java while leaving logic processing in the Prolog layer Supports XSB and SWI Prolog br Prova provides native syntax integration with Java agent messaging and reaction rules Prova positions itself as a rule based scripting RBS system for middleware The language breaks new ground in combining imperative and declarative programming br PROL An embeddable Prolog engine for Java It includes a small IDE and a few libraries br GNU Prolog for Java is an implementation of ISO Prolog as a Java library gnu prolog br Ciao provides interfaces to C C Java and relational databases br C Prolog is a Prolog interpreter written in managed C Can easily be integrated in C programs Characteristics reliable and fairly fast interpreter command line interface Windows interface builtin DCG XML predicates SQL predicates extendible The complete source code is available including a parser generator that can be used for adding special purpose extensions br A Warren Abstract Machine for PHP A Prolog compiler and interpreter in PHP A library that can be used standalone or within Symfony framework which was translated from Stephan Buettcher s work in Java which can be found here stefan buettcher org cs wam br tuProlog is a lightweight Prolog system for distributed applications and infrastructures intentionally designed around a minimal core to be either statically or dynamically configured by loading unloading libraries of predicates tuProlog natively supports multi paradigm programming providing a clean seamless integration model between Prolog and mainstream object oriented languages namely Java for tuProlog Java version and any NET based language C F for tuProlog NET version br Janus is a bi directional interface between Prolog and Python using portable low level primitives It was initially developed for XSB by Anderson and Swift but has been adopted as a joint initiative by the XSB Ciao and SWI Prolog teams br br br History br br The name Prolog was chosen by Philippe Roussel at the suggestion of his wife as an abbreviation for programmation en logique French for programming in logic It was created around by Alain Colmerauer with Philippe Roussel based on Robert Kowalski s procedural interpretation of Horn clauses It was motivated in part by the desire to reconcile the use of logic as a declarative knowledge representation language with the procedural representation of knowledge that was popular in North America in the late s and early s According to Robert Kowalski the first Prolog system was developed in by Colmerauer and Phillipe Roussel The first implementation of Prolog was an interpreter written in Fortran by Gerard Battani and Henri Meloni David H D Warren took this interpreter to the University of Edinburgh and there implemented an alternative front end which came to define the Edinburgh Prolog syntax used by most modern implementations Warren also implemented the first compiler for Prolog creating the influential DEC Prolog in collaboration with Fernando Pereira Warren later generalised the ideas behind DEC Prolog to create the Warren Abstract Machine br European AI researchers favored Prolog while Americans favored Lisp reportedly causing many nationalistic debates on the merits of the languages Much of the modern development of Prolog came from the impetus of the Fifth Generation Computer Systems project FGCS which developed a variant of Prolog named Kernel Language for its first operating system br Pure Prolog was originally restricted to the use of a resolution theorem prover with Horn clauses of the form br br H B Bn br br The application of the theorem prover treats such clauses as procedures br br to show solve H show solve B and and Bn br br Pure Prolog was soon extended however to include negation as failure in which negative conditions of the form not Bi are shown by trying and failing to solve the corresponding positive conditions Bi br Subsequent extensions of Prolog by the original team introduced constraint logic programming abilities into the implementations br br br Use in industry br Prolog has been used in Watson Watson uses IBM s DeepQA software and the Apache UIMA Unstructured Information Management Architecture framework The system was written in various languages including Java C and Prolog and runs on the SUSE Linux Enterprise Server operating system using Apache Hadoop framework to provide distributed computing Prolog is used for pattern matching over natural language parse trees The developers have stated We required a language in which we could conveniently express pattern matching rules over the parse trees and other annotations such as named entity recognition results and a technology that could execute these rules very efficiently We found that Prolog was the ideal choice for the language due to its simplicity and expressiveness Prolog is being used in the Low Code Development Platform GeneXus which is focused around AI Open source graph database TerminusDB is implemented in Prolog TerminusDB is designed for collaboratively building and curating knowledge graphs br br br See also br Comparison of Prolog implementations br Logico linguistic modeling A method for building knowledge based system that uses Prolog br Answer set programming A fully declarative approach to logic programming br Association for Logic Programming br br br Related languages br The G del language is a strongly typed implementation of concurrent constraint logic programming It is built on SICStus Prolog br Visual Prolog formerly named PDC Prolog and Turbo Prolog is a strongly typed object oriented dialect of Prolog which is very different from standard Prolog As Turbo Prolog it was marketed by Borland but is now developed and marketed by the Danish firm Prolog Development Center PDC that originally produced it br Datalog is a subset of Prolog It is limited to relationships that may be stratified and does not allow compound terms In contrast to Prolog Datalog is not Turing complete br Mercury is an offshoot of Prolog geared toward software engineering in the large with a static polymorphic type system as well as a mode and determinism system br GraphTalk is a proprietary implementation of Warren s Abstract Machine with additional object oriented properties br In some ways Prolog is a subset of Planner The ideas in Planner were later further developed in the Scientific Community Metaphor br AgentSpeak is a variant of Prolog for programming agent behavior in multi agent systems br Erlang began life with a Prolog based implementation and maintains much of Prolog s unification based syntax br Pilog is a declarative language built on top of PicoLisp that has the semantics of Prolog but uses the syntax of Lisp br Prolog is an extension of core Prolog that features polymorphic typing modular programming and higher order programming including direct support for terms with variable binding operators through so called tree syntax and higher order pattern unification br br br Notes br br br br br br Further reading 