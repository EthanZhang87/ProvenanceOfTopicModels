title: Transport Layer Security
id: 187813
Transport Layer Security TLS is a cryptographic protocol designed to provide communications security over a computer network The protocol is widely used in applications such as email instant messaging and voice over IP but its use in securing HTTPS remains the most well known br The TLS protocol aims primarily to provide security including privacy confidentiality integrity and authenticity through the use of cryptography such as the use of certificates between two or more communicating computer applications It runs in the presentation layer and is itself composed of two layers the TLS record and the TLS handshake protocols br The closely related Datagram Transport Layer Security DTLS is a communications protocol that provides security to datagram based applications In technical writing references to D TLS are often seen when it applies to both versions br TLS is a proposed Internet Engineering Task Force IETF standard first defined in and the current version is TLS defined in August TLS builds on the now deprecated SSL Secure Sockets Layer specifications developed by Netscape Communications for adding the HTTPS protocol to their Netscape Navigator web browser br br br Description br Client server applications use the TLS protocol to communicate across a network in a way designed to prevent eavesdropping and tampering br Since applications can communicate either with or without TLS or SSL it is necessary for the client to request that the server set up a TLS connection One of the main ways of achieving this is to use a different port number for TLS connections Port is typically used for unencrypted HTTP traffic while port is the common port used for encrypted HTTPS traffic Another mechanism is to make a protocol specific STARTTLS request to the server to switch the connection to TLS for example when using the mail and news protocols br Once the client and server have agreed to use TLS they negotiate a stateful connection by using a handshaking procedure see TLS handshake The protocols use a handshake with an asymmetric cipher to establish not only cipher settings but also a session specific shared key with which further communication is encrypted using a symmetric cipher During this handshake the client and server agree on various parameters used to establish the connection s security br br The handshake begins when a client connects to a TLS enabled server requesting a secure connection and the client presents a list of supported cipher suites ciphers and hash functions br From this list the server picks a cipher and hash function that it also supports and notifies the client of the decision br The server usually then provides identification in the form of a digital certificate The certificate contains the server name the trusted certificate authority CA that vouches for the authenticity of the certificate and the server s public encryption key br The client confirms the validity of the certificate before proceeding br To generate the session keys used for the secure connection the client either br encrypts a random number PreMasterSecret with the server s public key and sends the result to the server which only the server should be able to decrypt with its private key both parties then use the random number to generate a unique session key for subsequent encryption and decryption of data during the session or br uses Diffie Hellman key exchange or its variant elliptic curve DH to securely generate a random and unique session key for encryption and decryption that has the additional property of forward secrecy if the server s private key is disclosed in future it cannot be used to decrypt the current session even if the session is intercepted and recorded by a third party br This concludes the handshake and begins the secured connection which is encrypted and decrypted with the session key until the connection closes If any one of the above steps fails then the TLS handshake fails and the connection is not created br TLS and SSL do not fit neatly into any single layer of the OSI model or the TCP IP model TLS runs on top of some reliable transport protocol e g TCP which would imply that it is above the transport layer It serves encryption to higher layers which is normally the function of the presentation layer However applications generally use TLS as if it were a transport layer even though applications using TLS must actively control initiating TLS handshakes and handling of exchanged authentication certificates br When secured by TLS connections between a client e g a web browser and a server e g wikipedia org will have all of the following properties br br The connection is private or has confidentiality because a symmetric key algorithm is used to encrypt the data transmitted The keys for this symmetric encryption are generated uniquely for each connection and are based on a shared secret that was negotiated at the start of the session The server and client negotiate the details of which encryption algorithm and cryptographic keys to use before the first byte of data is transmitted see below The negotiation of a shared secret is both secure the negotiated secret is unavailable to eavesdroppers and cannot be obtained even by an attacker who places themselves in the middle of the connection and reliable no attacker can modify the communications during the negotiation without being detected br The identity of the communicating parties can be authenticated using public key cryptography This authentication is required for the server and optional for the client br The connection is reliable or has integrity because each message transmitted includes a message integrity check using a message authentication code to prevent undetected loss or alteration of the data during transmission br TLS supports many different methods for exchanging keys encrypting data and authenticating message integrity As a result secure configuration of TLS involves many configurable parameters and not all choices provide all of the privacy related properties described in the list above see the tables below Key exchange Cipher security and Data integrity br Attempts have been made to subvert aspects of the communications security that TLS seeks to provide and the protocol has been revised several times to address these security threats Developers of web browsers have repeatedly revised their products to defend against potential security weaknesses after these were discovered see TLS SSL support history of web browsers br br br Datagram Transport Layer Security br Datagram Transport Layer Security abbreviated DTLS is a related communications protocol providing security to datagram based applications by allowing them to communicate in a way designed to prevent eavesdropping tampering or message forgery The DTLS protocol is based on the stream oriented Transport Layer Security TLS protocol and is intended to provide similar security guarantees However unlike TLS it can be used with most datagram oriented protocols including User Datagram Protocol UDP Datagram Congestion Control Protocol DCCP Control And Provisioning of Wireless Access Points CAPWAP Stream Control Transmission Protocol SCTP encapsulation and Secure Real time Transport Protocol SRTP br As the DTLS protocol datagram preserves the semantics of the underlying transport the application it does not suffer from the delays associated with stream protocols however the application has to deal with packet reordering loss of datagram and data larger than the size of a datagram network packet Because DTLS uses UDP or SCTP rather than TCP it avoids the TCP meltdown problem when being used to create a VPN tunnel br The original release of DTLS version was not a standalone document It was given as a series of deltas to TLS Similarly the follow up release of DTLS is a delta to TLS It was given the version number of DTLS to match its TLS version Lastly the DTLS is a delta to TLS Like the two previous versions DTLS is intended to provide equivalent security guarantees to TLS with the exception of order protection non replayability br Many VPN clients including Cisco AnyConnect InterCloud Fabric OpenConnect ZScaler tunnel F Networks Edge VPN Client and Citrix Systems NetScaler use DTLS to secure UDP traffic In addition all modern web browsers support DTLS SRTP for WebRTC br br br History and development br br br Secure Data Network System br br The Transport Layer Security Protocol TLS together with several other basic network security platforms was developed through a joint initiative begun in August among the National Security Agency the National Bureau of Standards the Defense Communications Agency and twelve communications and computer corporations who initiated a special project called the Secure Data Network System SDNS The program was described in September at the th National Computer Security Conference in an extensive set of published papers The innovative research program focused on designing the next generation of secure computer communications network and product specifications to be implemented for applications on public and private internets It was intended to complement the rapidly emerging new OSI internet standards moving forward both in the U S government s GOSIP Profiles and in the huge ITU ISO JTC internet effort internationally Originally known as the SP protocol it was renamed TLS and subsequently published in as international standard ITU T X ISO IEC br br br Secure Network Programming SNP br Early research efforts towards transport layer security included the Secure Network Programming SNP application programming interface API which in explored the approach of having a secure transport layer API closely resembling Berkeley sockets to facilitate retrofitting pre existing network applications with security measures SNP was published and presented in the USENIX Summer Technical Conference The SNP project was funded by a grant from NSA to Professor Simon Lam at UT Austin in Secure Network Programming won the ACM Software System Award Simon Lam was inducted into the Internet Hall of Fame for inventing secure sockets and implementing the first secure sockets layer named SNP in br br br SSL and br br Netscape developed the original SSL protocols and Taher Elgamal chief scientist at Netscape Communications from to has been described as the father of SSL SSL version was never publicly released because of serious security flaws in the protocol Version after being released in February was quickly found to contain a number of security and usability flaws It used the same cryptographic keys for message authentication and encryption It had a weak MAC construction that used the MD hash function with a secret prefix making it vulnerable to length extension attacks It also provided no protection for either the opening handshake or an explicit message close both of which meant man in the middle attacks could go undetected Moreover SSL assumed a single service and a fixed domain certificate conflicting with the widely used feature of virtual hosting in Web servers so most websites were effectively impaired from using SSL br These flaws necessitated the complete redesign of the protocol to SSL version Released in it was produced by Paul Kocher working with Netscape engineers Phil Karlton and Alan Freier with a reference implementation by Christopher Allen and Tim Dierks of Certicom Newer versions of SSL TLS are based on SSL The draft of SSL was published by IETF as a historical document in RFC br SSL was deprecated in by RFC In SSL was found to be vulnerable to the POODLE attack that affects all block ciphers in SSL RC the only non block cipher supported by SSL is also feasibly broken as used in SSL SSL was deprecated in June by RFC br br br TLS br TLS was first defined in RFC in January as an upgrade of SSL Version and written by Christopher Allen and Tim Dierks of Certicom As stated in the RFC the differences between this protocol and SSL are not dramatic but they are significant enough to preclude interoperability between TLS and SSL Tim Dierks later wrote that these changes and the renaming from SSL to TLS were a face saving gesture to Microsoft so it wouldn t look like the IETF was just rubberstamping Netscape s protocol br The PCI Council suggested that organizations migrate from TLS to TLS or higher before June In October Apple Google Microsoft and Mozilla jointly announced they would deprecate TLS and in March TLS and were formally deprecated in RFC in March br br br TLS br TLS was defined in RFC in April It is an update from TLS version Significant differences in this version include br br Added protection against cipher block chaining CBC attacks br The implicit initialization vector IV was replaced with an explicit IV br Change in handling of padding errors br Support for IANA registration of parameters br Support for TLS versions and was widely deprecated by web sites around disabling access to Firefox versions before and Chromium based browsers before br br br TLS br TLS was defined in RFC in August It is based on the earlier TLS specification Major differences include br br The MD and SHA combination in the pseudorandom function PRF was replaced with SHA with an option to use cipher suite specified PRFs br The MD and SHA combination in the finished message hash was replaced with SHA with an option to use cipher suite specific hash algorithms However the size of the hash in the finished message must still be at least bits br The MD and SHA combination in the digitally signed element was replaced with a single hash negotiated during handshake which defaults to SHA br Enhancement in the client s and server s ability to specify which hashes and signature algorithms they accept br Expansion of support for authenticated encryption ciphers used mainly for Galois Counter Mode GCM and CCM mode of Advanced Encryption Standard AES encryption br TLS Extensions definition and AES cipher suites were added br All TLS versions were further refined in RFC in March removing their backward compatibility with SSL such that TLS sessions never negotiate the use of Secure Sockets Layer SSL version There is currently no formal date for TLS to be deprecated The specifications for TLS became redefined as well by the Standards Track Document RFC to keep it as secure as possible it is to be seen as a failover protocol now meant only to be negotiated with clients which are unable to talk over TLS The original RFC definition for TLS is since then obsolete br br br TLS br TLS was defined in RFC in August It is based on the earlier TLS specification Major differences from TLS include br br Separating key agreement and authentication algorithms from the cipher suites br Removing support for weak and less used named elliptic curves br Removing support for MD and SHA cryptographic hash functions br Requiring digital signatures even when a previous configuration is used br Integrating HKDF and the semi ephemeral DH proposal br Replacing resumption with PSK and tickets br Supporting RTT handshakes and initial support for RTT br Mandating perfect forward secrecy by means of using ephemeral keys during the EC DH key agreement br Dropping support for many insecure or obsolete features including compression renegotiation non AEAD ciphers null ciphers non PFS key exchange among which are static RSA and static DH key exchanges custom DHE groups EC point format negotiation Change Cipher Spec protocol Hello message UNIX time and the length field AD input to AEAD ciphers br Prohibiting SSL or RC negotiation for backwards compatibility br Integrating use of session hash br Deprecating use of the record layer version number and freezing the number for improved backwards compatibility br Moving some security related algorithm details from an appendix to the specification and relegating ClientKeyShare to an appendix br Adding the ChaCha stream cipher with the Poly message authentication code br Adding the Ed and Ed digital signature algorithms br Adding the x and x key exchange protocols br Adding support for sending multiple OCSP responses br Encrypting all handshake messages after the ServerHello br Network Security Services NSS the cryptography library developed by Mozilla and used by its web browser Firefox enabled TLS by default in February TLS support was subsequently added but due to compatibility issues for a small number of users not automatically enabled to Firefox which was released in March TLS was enabled by default in May with the release of Firefox br Google Chrome set TLS as the default version for a short time in It then removed it as the default due to incompatible middleboxes such as Blue Coat web proxies br The intolerance of the new version of TLS was protocol ossification middleboxes had ossified the protocol s version parameter As a result version mimics the wire image of version This change occurred very late in the design process only having been discovered during browser deployment The discovery of this intolerance also led to the prior version negotiation strategy where the highest matching version was picked being abandoned due to unworkable levels of ossification Greasing an extension point where one protocol participant claims support for non existent extensions to ensure that unrecognised but actually existent extensions are tolerated and so to resist ossification was originally designed for TLS but it has since been adopted elsewhere br During the IETF Hackathon which took place in Singapore in the TLS Group worked on adapting open source applications to use TLS The TLS group was made up of individuals from Japan United Kingdom and Mauritius via the cyberstorm mu team This work was continued in the IETF Hackathon in London and the IETF Hackathon in Montreal br wolfSSL enabled the use of TLS as of version released in May As the first commercial TLS implementation wolfSSL supported Draft and now supports Draft the final version as well as many older versions A series of blogs were published on the performance difference between TLS and br In September the popular OpenSSL project released version of its library in which support for TLS was the headline new feature br Support for TLS was added to Secure Channel schannel for the GA releases of Windows and Windows Server br br br Enterprise Transport Security br The Electronic Frontier Foundation praised TLS and expressed concern about the variant protocol Enterprise Transport Security ETS that intentionally disables important security measures in TLS Originally called Enterprise TLS eTLS ETS is a published standard known as the ETSI TS Middlebox Security Protocol Part Enterprise Transport Security It is intended for use entirely within proprietary networks such as banking systems ETS does not support forward secrecy so as to allow third party organizations connected to the proprietary networks to be able to use their private key to monitor network traffic for the detection of malware and to make it easier to conduct audits Despite the claimed benefits the EFF warned that the loss of forward secrecy could make it easier for data to be exposed along with saying that there are better ways to analyze traffic br br br Digital certificates br br A digital certificate certifies the ownership of a public key by the named subject of the certificate and indicates certain expected usages of that key This allows others relying parties to rely upon signatures or on assertions made by the private key that corresponds to the certified public key Keystores and trust stores can be in various formats such as pem crt pfx and jks br br br Certificate authorities br br TLS typically relies on a set of trusted third party certificate authorities to establish the authenticity of certificates Trust is usually anchored in a list of certificates distributed with user agent software and can be modified by the relying party br According to Netcraft who monitors active TLS certificates the market leading certificate authority CA has been Symantec since the beginning of their survey or VeriSign before the authentication services business unit was purchased by Symantec As of Symantec accounted for just under a third of all certificates and of the valid certificates used by the million busiest websites as counted by Netcraft In Symantec sold its TLS SSL business to DigiCert In an updated report it was shown that IdenTrust DigiCert and Sectigo are the top certificate authorities in terms of market share since May br As a consequence of choosing X certificates certificate authorities and a public key infrastructure are necessary to verify the relation between a certificate and its owner as well as to generate sign and administer the validity of certificates While this can be more convenient than verifying the identities via a web of trust the mass surveillance disclosures made it more widely known that certificate authorities are a weak point from a security standpoint allowing man in the middle attacks MITM if the certificate authority cooperates or is compromised br br br Importance of SSL Certificates br Encryption SSL certificates encrypt data sent between a web server and a user s browser ensuring that sensitive information is protected throughout transmission This encryption technology stops unauthorized parties from intercepting and interpreting data so protecting it from possible risks such as hacking or data breaches br Authentication SSL certificates also offer authentication certifying the integrity of a website and that visitors are connecting to the correct server rather than a malicious impostor This authentication method helps consumers gain trust by ensuring that they are dealing with a trustworthy and secure website br Integrity Another important role of SSL certificates is to ensure data integrity SSL uses cryptographic techniques to verify that data communicated between the server and the browser is intact and unmodified during transit This keeps malevolent actors from interfering with the data ensuring its integrity and trustworthiness br br br Algorithms br br br Key exchange or key agreement br Before a client and server can begin to exchange information protected by TLS they must securely exchange or agree upon an encryption key and a cipher to use when encrypting data see Cipher Among the methods used for key exchange agreement are public and private keys generated with RSA denoted TLS RSA in the TLS handshake protocol Diffie Hellman TLS DH ephemeral Diffie Hellman TLS DHE elliptic curve Diffie Hellman TLS ECDH ephemeral elliptic curve Diffie Hellman TLS ECDHE anonymous Diffie Hellman TLS DH anon pre shared key TLS PSK and Secure Remote Password TLS SRP br The TLS DH anon and TLS ECDH anon key agreement methods do not authenticate the server or the user and hence are rarely used because those are vulnerable to man in the middle attacks Only TLS DHE and TLS ECDHE provide forward secrecy br Public key certificates used during exchange agreement also vary in the size of the public private encryption keys used during the exchange and hence the robustness of the security provided In July Google announced that it would no longer use bit public keys and would switch instead to bit keys to increase the security of the TLS encryption it provides to its users because the encryption strength is directly related to the key size br br br Cipher br br Notes br br br Data integrity br A message authentication code MAC is used for data integrity HMAC is used for CBC mode of block ciphers Authenticated encryption AEAD such as GCM and CCM mode uses AEAD integrated MAC and doesn t use HMAC HMAC based PRF or HKDF is used for TLS handshake br br br Applications and adoption br In applications design TLS is usually implemented on top of Transport Layer protocols encrypting all of the protocol related data of protocols such as HTTP FTP SMTP NNTP and XMPP br Historically TLS has been used primarily with reliable transport protocols such as the Transmission Control Protocol TCP However it has also been implemented with datagram oriented transport protocols such as the User Datagram Protocol UDP and the Datagram Congestion Control Protocol DCCP usage of which has been standardized independently using the term Datagram Transport Layer Security DTLS br br br Websites br A primary use of TLS is to secure World Wide Web traffic between a website and a web browser encoded with the HTTP protocol This use of TLS to secure HTTP traffic constitutes the HTTPS protocol br br Notes br br br Web browsers br br As of April the latest versions of all major web browsers support TLS and and have them enabled by default However not all supported Microsoft operating systems support the latest version of IE Additionally many Microsoft operating systems currently support multiple versions of IE but this has changed according to Microsoft s Internet Explorer Support Lifecycle Policy FAQ Archived at the Wayback Machine beginning January only the most current version of Internet Explorer available for a supported operating system will receive technical support and security updates The page then goes on to list the latest supported version of IE at that date for each operating system The next critical date would be when an operating system reaches the end of life stage Since June Internet Explorer dropped support for Windows editions which follow Microsoft s Modern Lifecycle Policy br Mitigations against known attacks are not enough yet br br Mitigations against POODLE attack some browsers already prevent fallback to SSL however this mitigation needs to be supported by not only clients but also servers Disabling SSL itself implementation of anti POODLE record splitting or denying CBC ciphers in SSL is required br Google Chrome complete TLS FALLBACK SCSV is implemented since version fallback to SSL is disabled since version SSL itself is disabled by default since version Support of SSL itself was dropped since version br Mozilla Firefox complete support of SSL itself is dropped since version SSL itself is disabled by default and fallback to SSL are disabled since version TLS FALLBACK SCSV is implemented since version In ESR SSL itself is disabled by default and TLS FALLBACK SCSV is implemented since ESR br Internet Explorer partial only in version SSL is disabled by default since April Version and older are still vulnerable against POODLE br Opera complete TLS FALLBACK SCSV is implemented since version anti POODLE record splitting which is effective only with client side implementation is implemented since version SSL itself is disabled by default since version Support of SSL itself will be dropped since version br Safari complete only on OS X and later and iOS CBC ciphers during fallback to SSL is denied but this means it will use RC which is not recommended as well Support of SSL itself is dropped on OS X and later and iOS br Mitigation against RC attacks br Google Chrome disabled RC except as a fallback since version RC is disabled since Chrome br Firefox disabled RC except as a fallback since version Firefox disabled RC by default br Opera disabled RC except as a fallback since version RC is disabled since Opera br Internet Explorer for Windows Server R and for Windows Server have set the priority of RC to lowest and can also disable RC except as a fallback through registry settings Internet Explorer Mobile for Windows Phone disable RC except as a fallback if no other enabled algorithm works Edge and IE disable RC completely in August br Mitigation against FREAK attack br The Android Browser included with Android and older is still vulnerable to the FREAK attack br Internet Explorer Mobile is still vulnerable to the FREAK attack br Google Chrome Internet Explorer desktop Safari desktop mobile and Opera mobile have FREAK mitigations in place br Mozilla Firefox on all platforms and Google Chrome on Windows were not affected by FREAK br br br Libraries br br Most SSL and TLS programming libraries are free and open source software br br BoringSSL a fork of OpenSSL for Chrome Chromium and Android as well as other Google applications br Botan a BSD licensed cryptographic library written in C br BSAFE Micro Edition Suite a multi platform implementation of TLS written in C using a FIPS validated cryptographic module br BSAFE SSL J a TLS library providing both a proprietary API and JSSE API using FIPS validated cryptographic module br cryptlib a portable open source cryptography library includes TLS SSL implementation br Delphi programmers may use a library called Indy which utilizes OpenSSL or alternatively ICS which supports TLS now br GnuTLS a free implementation LGPL licensed br Java Secure Socket Extension JSSE the Java API and provider implementation named SunJSSE br LibreSSL a fork of OpenSSL by OpenBSD project br MatrixSSL a dual licensed implementation br Mbed TLS previously PolarSSL A tiny SSL library implementation for embedded devices that is designed for ease of use br Network Security Services FIPS validated open source library br OpenSSL a free implementation BSD license with some extensions br Schannel an implementation of SSL and TLS Microsoft Windows as part of its package br Secure Transport an implementation of SSL and TLS used in OS X and iOS as part of their packages br wolfSSL previously CyaSSL Embedded SSL TLS Library with a strong focus on speed and size br A paper presented at the ACM conference on computer and communications security showed that many applications used some of these SSL libraries incorrectly leading to vulnerabilities According to the authors br br The root cause of most of these vulnerabilities is the terrible design of the APIs to the underlying SSL libraries Instead of expressing high level security properties of network tunnels such as confidentiality and authentication these APIs expose low level details of the SSL protocol to application developers As a consequence developers often use SSL APIs incorrectly misinterpreting and misunderstanding their manifold parameters options side effects and return values br br br Other uses br The Simple Mail Transfer Protocol SMTP can also be protected by TLS These applications use public key certificates to verify the identity of endpoints br TLS can also be used for tunnelling an entire network stack to create a VPN which is the case with OpenVPN and OpenConnect Many vendors have by now married TLS s encryption and authentication capabilities with authorization There has also been substantial development since the late s in creating client technology outside of Web browsers in order to enable support for client server applications Compared to traditional IPsec VPN technologies TLS has some inherent advantages in firewall and NAT traversal that make it easier to administer for large remote access populations br TLS is also a standard method for protecting Session Initiation Protocol SIP application signaling TLS can be used for providing authentication and encryption of the SIP signalling associated with VoIP and other SIP based applications br br br Security br br br Attacks against TLS SSL br Significant attacks against TLS SSL are listed below br In February IETF issued an informational RFC summarizing the various known attacks against TLS SSL br br br Renegotiation attack br A vulnerability of the renegotiation procedure was discovered in August that can lead to plaintext injection attacks against SSL and all current versions of TLS For example it allows an attacker who can hijack an https connection to splice their own requests into the beginning of the conversation the client has with the web server The attacker can t actually decrypt the client server communication so it is different from a typical man in the middle attack A short term fix is for web servers to stop allowing renegotiation which typically will not require other changes unless client certificate authentication is used To fix the vulnerability a renegotiation indication extension was proposed for TLS It will require the client and server to include and verify information about previous handshakes in any renegotiation handshakes This extension has become a proposed standard and has been assigned the number RFC The RFC has been implemented by several libraries br br br Downgrade attacks FREAK attack and Logjam attack br br A protocol downgrade attack also called a version rollback attack tricks a web server into negotiating connections with previous versions of TLS such as SSLv that have long since been abandoned as insecure br Previous modifications to the original protocols like False Start adopted and enabled by Google Chrome or Snap Start reportedly introduced limited TLS protocol downgrade attacks or allowed modifications to the cipher suite list sent by the client to the server In doing so an attacker might succeed in influencing the cipher suite selection in an attempt to downgrade the cipher suite negotiated to use either a weaker symmetric encryption algorithm or a weaker key exchange A paper presented at an ACM conference on computer and communications security in demonstrated that the False Start extension was at risk in certain circumstances it could allow an attacker to recover the encryption keys offline and to access the encrypted data br Encryption downgrade attacks can force servers and clients to negotiate a connection using cryptographically weak keys In a man in the middle attack called FREAK was discovered affecting the OpenSSL stack the default Android web browser and some Safari browsers The attack involved tricking servers into negotiating a TLS connection using cryptographically weak bit encryption keys br Logjam is a security exploit discovered in May that exploits the option of using legacy export grade bit Diffie Hellman groups dating back to the s It forces susceptible servers to downgrade to cryptographically weak bit Diffie Hellman groups An attacker can then deduce the keys the client and server determine using the Diffie Hellman key exchange br br br Cross protocol attacks DROWN br br The DROWN attack is an exploit that attacks servers supporting contemporary SSL TLS protocol suites by exploiting their support for the obsolete insecure SSLv protocol to leverage an attack on connections using up to date protocols that would otherwise be secure DROWN exploits a vulnerability in the protocols used and the configuration of the server rather than any specific implementation error Full details of DROWN were announced in March together with a patch for the exploit At that time more than of the top million most popular websites were among the TLS protected websites that were vulnerable to the DROWN attack br br br BEAST attack br On September researchers Thai Duong and Juliano Rizzo demonstrated a proof of concept called BEAST Browser Exploit Against SSL TLS using a Java applet to violate same origin policy constraints for a long known cipher block chaining CBC vulnerability in TLS an attacker observing consecutive ciphertext blocks C C can test if the plaintext block P is equal to x by choosing the next plaintext block P x C C as per CBC operation C E C P E C x C C E C x which will be equal to C if x P Practical exploits had not been previously demonstrated for this vulnerability which was originally discovered by Phillip Rogaway in The vulnerability of the attack had been fixed with TLS in but TLS had not seen wide adoption prior to this attack demonstration br RC as a stream cipher is immune to BEAST attack Therefore RC was widely used as a way to mitigate BEAST attack on the server side However in researchers found more weaknesses in RC Thereafter enabling RC on server side was no longer recommended br Chrome and Firefox themselves are not vulnerable to BEAST attack however Mozilla updated their NSS libraries to mitigate BEAST like attacks NSS is used by Mozilla Firefox and Google Chrome to implement SSL Some web servers that have a broken implementation of the SSL specification may stop working as a result br Microsoft released Security Bulletin MS on January which fixed the BEAST vulnerability by changing the way that the Windows Secure Channel Schannel component transmits encrypted network packets from the server end Users of Internet Explorer prior to version that run on older versions of Windows Windows Windows and Windows Server R can restrict use of TLS to or higher br Apple fixed BEAST vulnerability by implementing n split and turning it on by default in OS X Mavericks released on October br br br CRIME and BREACH attacks br br The authors of the BEAST attack are also the creators of the later CRIME attack which can allow an attacker to recover the content of web cookies when data compression is used along with TLS When used to recover the content of secret authentication cookies it allows an attacker to perform session hijacking on an authenticated web session br While the CRIME attack was presented as a general attack that could work effectively against a large number of protocols including but not limited to TLS and application layer protocols such as SPDY or HTTP only exploits against TLS and SPDY were demonstrated and largely mitigated in browsers and servers The CRIME exploit against HTTP compression has not been mitigated at all even though the authors of CRIME have warned that this vulnerability might be even more widespread than SPDY and TLS compression combined In a new instance of the CRIME attack against HTTP compression dubbed BREACH was announced Based on the CRIME attack a BREACH attack can extract login tokens email addresses or other sensitive information from TLS encrypted web traffic in as little as seconds depending on the number of bytes to be extracted provided the attacker tricks the victim into visiting a malicious web link or is able to inject content into valid pages the user is visiting ex a wireless network under the control of the attacker All versions of TLS and SSL are at risk from BREACH regardless of the encryption algorithm or cipher used Unlike previous instances of CRIME which can be successfully defended against by turning off TLS compression or SPDY header compression BREACH exploits HTTP compression which cannot realistically be turned off as virtually all web servers rely upon it to improve data transmission speeds for users This is a known limitation of TLS as it is susceptible to chosen plaintext attack against the application layer data it was meant to protect br br br Timing attacks on padding br Earlier TLS versions were vulnerable against the padding oracle attack discovered in A novel variant called the Lucky Thirteen attack was published in br Some experts also recommended avoiding triple DES CBC Since the last supported ciphers developed to support any program using Windows XP s SSL TLS library like Internet Explorer on Windows XP are RC and Triple DES and since RC is now deprecated see discussion of RC attacks this makes it difficult to support any version of SSL for any program using this library on XP br A fix was released as the Encrypt then MAC extension to the TLS specification released as RFC The Lucky Thirteen attack can be mitigated in TLS by using only AES GCM ciphers AES CBC remains vulnerable SSL may safeguard email VoIP and other types of communications over insecure networks in addition to its primary use case of secure data transmission between a client and the server br br br POODLE attack br br On October Google researchers published a vulnerability in the design of SSL which makes CBC mode of operation with SSL vulnerable to a padding attack CVE They named this attack POODLE Padding Oracle On Downgraded Legacy Encryption On average attackers only need to make SSL requests to reveal one byte of encrypted messages br Although this vulnerability only exists in SSL and most clients and servers support TLS and above all major browsers voluntarily downgrade to SSL if the handshakes with newer versions of TLS fail unless they provide the option for a user or administrator to disable SSL and the user or administrator does so Therefore the man in the middle can first conduct a version rollback attack and then exploit this vulnerability br On December a variant of POODLE was announced that impacts TLS implementations that do not properly enforce padding byte requirements br br br RC attacks br br Despite the existence of attacks on RC that broke its security cipher suites in SSL and TLS that were based on RC were still considered secure prior to based on the way in which they were used in SSL and TLS In the RC suite was actually recommended as a work around for the BEAST attack New forms of attack disclosed in March conclusively demonstrated the feasibility of breaking RC in TLS suggesting it was not a good workaround for BEAST An attack scenario was proposed by AlFardan Bernstein Paterson Poettering and Schuldt that used newly discovered statistical biases in the RC key table to recover parts of the plaintext with a large number of TLS encryptions An attack on RC in TLS and SSL that requires encryptions to break RC was unveiled on July and later described as feasible in the accompanying presentation at a USENIX Security Symposium in August In July subsequent improvements in the attack make it increasingly practical to defeat the security of RC encrypted TLS br As many modern browsers have been designed to defeat BEAST attacks except Safari for Mac OS X or earlier for iOS or earlier and for Windows see Web browsers RC is no longer a good choice for TLS The CBC ciphers which were affected by the BEAST attack in the past have become a more popular choice for protection Mozilla and Microsoft recommend disabling RC where possible RFC prohibits the use of RC cipher suites in all versions of TLS br On September Microsoft Google and Mozilla announced that RC cipher suites would be disabled by default in their browsers Microsoft Edge Internet Explorer on Windows Firefox and Chrome in early br br br Truncation attack br A TLS logout truncation attack blocks a victim s account logout requests so that the user unknowingly remains logged into a web service When the request to sign out is sent the attacker injects an unencrypted TCP FIN message no more data from sender to close the connection The server therefore doesn t receive the logout request and is unaware of the abnormal termination br Published in July the attack causes web services such as Gmail and Hotmail to display a page that informs the user that they have successfully signed out while ensuring that the user s browser maintains authorization with the service allowing an attacker with subsequent access to the browser to access and take over control of the user s logged in account The attack does not rely on installing malware on the victim s computer attackers need only place themselves between the victim and the web server e g by setting up a rogue wireless hotspot This vulnerability also requires access to the victim s computer br Another possibility is when using FTP the data connection can have a false FIN in the data stream and if the protocol rules for exchanging close notify alerts is not adhered to a file can be truncated br br br Plaintext attack against DTLS br In February two researchers from Royal Holloway University of London discovered a timing attack which allowed them to recover parts of the plaintext from a DTLS connection using the OpenSSL or GnuTLS implementation of DTLS when Cipher Block Chaining mode encryption was used br br br Unholy PAC attack br This attack discovered in mid exploits weaknesses in the Web Proxy Autodiscovery Protocol WPAD to expose the URL that a web user is attempting to reach via a TLS enabled web link Disclosure of a URL can violate a user s privacy not only because of the website accessed but also because URLs are sometimes used to authenticate users Document sharing services such as those offered by Google and Dropbox also work by sending a user a security token that s included in the URL An attacker who obtains such URLs may be able to gain full access to a victim s account or data br The exploit works against almost all browsers and operating systems br br br Sweet attack br The Sweet attack breaks all bit block ciphers used in CBC mode as used in TLS by exploiting a birthday attack and either a man in the middle attack or injection of a malicious JavaScript into a web page The purpose of the man in the middle attack or the JavaScript injection is to allow the attacker to capture enough traffic to mount a birthday attack br br br Implementation errors Heartbleed bug BERserk attack Cloudflare bug br br The Heartbleed bug is a serious vulnerability specific to the implementation of SSL TLS in the popular OpenSSL cryptographic software library affecting versions to f This weakness reported in April allows attackers to steal private keys from servers that should normally be protected The Heartbleed bug allows anyone on the Internet to read the memory of the systems protected by the vulnerable versions of the OpenSSL software This compromises the secret private keys associated with the public certificates used to identify the service providers and to encrypt the traffic the names and passwords of the users and the actual content This allows attackers to eavesdrop on communications steal data directly from the services and users and to impersonate services and users The vulnerability is caused by a buffer over read bug in the OpenSSL software rather than a defect in the SSL or TLS protocol specification br In September a variant of Daniel Bleichenbacher s PKCS v RSA Signature Forgery vulnerability was announced by Intel Security Advanced Threat Research This attack dubbed BERserk is a result of incomplete ASN length decoding of public key signatures in some SSL implementations and allows a man in the middle attack by forging a public key signature br In February after media reported the hidden pre installation of superfish adware on some Lenovo notebooks a researcher found a trusted root certificate on affected Lenovo machines to be insecure as the keys could easily be accessed using the company name Komodia as a passphrase The Komodia library was designed to intercept client side TLS SSL traffic for parental control and surveillance but it was also used in numerous adware programs including Superfish that were often surreptitiously installed unbeknownst to the computer user In turn these potentially unwanted programs installed the corrupt root certificate allowing attackers to completely control web traffic and confirm false websites as authentic br In May it was reported that dozens of Danish HTTPS protected websites belonging to Visa Inc were vulnerable to attacks allowing hackers to inject malicious code and forged content into the browsers of visitors The attacks worked because the TLS implementation used on the affected servers incorrectly reused random numbers nonces that are intended to be used only once ensuring that each TLS handshake is unique br In February an implementation error caused by a single mistyped character in code used to parse HTML created a buffer overflow error on Cloudflare servers Similar in its effects to the Heartbleed bug discovered in this overflow error widely known as Cloudbleed allowed unauthorized third parties to read data in the memory of programs running on the servers data that should otherwise have been protected by TLS br br br Survey of websites vulnerable to attacks br As of July the Trustworthy Internet Movement estimated the ratio of websites that are vulnerable to TLS attacks br br br Forward secrecy br br Forward secrecy is a property of cryptographic systems which ensures that a session key derived from a set of public and private keys will not be compromised if one of the private keys is compromised in the future Without forward secrecy if the server s private key is compromised not only will all future TLS encrypted sessions using that server certificate be compromised but also any past sessions that used it as well provided that these past sessions were intercepted and stored at the time of transmission An implementation of TLS can provide forward secrecy by requiring the use of ephemeral Diffie Hellman key exchange to establish session keys and some notable TLS implementations do so exclusively e g Gmail and other Google HTTPS services that use OpenSSL However many clients and servers supporting TLS including browsers and web servers are not configured to implement such restrictions In practice unless a web service uses Diffie Hellman key exchange to implement forward secrecy all of the encrypted web traffic to and from that service can be decrypted by a third party if it obtains the server s master private key e g by means of a court order br Even where Diffie Hellman key exchange is implemented server side session management mechanisms can impact forward secrecy The use of TLS session tickets a TLS extension causes the session to be protected by AES CBC SHA regardless of any other negotiated TLS parameters including forward secrecy ciphersuites and the long lived TLS session ticket keys defeat the attempt to implement forward secrecy Stanford University research in also found that of TLS servers surveyed of the servers deploying ephemeral Diffie Hellman DHE key exchange to support forward secrecy were using weak Diffie Hellman parameters These weak parameter choices could potentially compromise the effectiveness of the forward secrecy that the servers sought to provide br Since late Google has provided forward secrecy with TLS by default to users of its Gmail service along with Google Docs and encrypted search among other services br Since November Twitter has provided forward secrecy with TLS to users of its service As of August about of TLS enabled websites are configured to use cipher suites that provide forward secrecy to most web browsers br br br TLS interception br br TLS interception or HTTPS interception if applied particularly to that protocol is the practice of intercepting an encrypted data stream in order to decrypt it read and possibly manipulate it and then re encrypt it and send the data on its way again This is done by way of a transparent proxy the interception software terminates the incoming TLS connection inspects the HTTP plaintext and then creates a new TLS connection to the destination br TLS HTTPS interception is used as an information security measure by network operators in order to be able to scan for and protect against the intrusion of malicious content into the network such as computer viruses and other malware Such content could otherwise not be detected as long as it is protected by encryption which is increasingly the case as a result of the routine use of HTTPS and other secure protocols br A significant drawback of TLS HTTPS interception is that it introduces new security risks of its own One notable limitation is that it provides a point where network traffic is available unencrypted thus giving attackers an incentive to attack this point in particular in order to gain access to otherwise secure content The interception also allows the network operator or persons who gain access to its interception system to perform man in the middle attacks against network users A study found that HTTPS interception has become startlingly widespread and that interception products as a class have a dramatically negative impact on connection security br br br Protocol details br The TLS protocol exchanges records which encapsulate the data to be exchanged in a specific format see below Each record can be compressed padded appended with a message authentication code MAC or encrypted all depending on the state of the connection Each record has a content type field that designates the type of data encapsulated a length field and a TLS version field The data encapsulated may be control or procedural messages of the TLS itself or simply the application data needed to be transferred by TLS The specifications cipher suite keys etc required to exchange application data by TLS are agreed upon in the TLS handshake between the client requesting the data and the server responding to requests The protocol therefore defines both the structure of payloads transferred in TLS and the procedure to establish and monitor the transfer br br br TLS handshake br br When the connection starts the record encapsulates a control protocol the handshake messaging protocol content type This protocol is used to exchange all the information required by both sides for the exchange of the actual application data by TLS It defines the format of messages and the order of their exchange These may vary according to the demands of the client and server i e there are several possible procedures to set up the connection This initial exchange results in a successful TLS connection both parties ready to transfer application data with TLS or an alert message as specified below br br br Basic TLS handshake br A typical connection example follows illustrating a handshake where the server but not the client is authenticated by its certificate br br Negotiation phase br A client sends a ClientHello message specifying the highest TLS protocol version it supports a random number a list of suggested cipher suites and suggested compression methods If the client is attempting to perform a resumed handshake it may send a session ID If the client can use Application Layer Protocol Negotiation it may include a list of supported application protocols such as HTTP br The server responds with a ServerHello message containing the chosen protocol version a random number cipher suite and compression method from the choices offered by the client To confirm or allow resumed handshakes the server may send a session ID The chosen protocol version should be the highest that both the client and server support For example if the client supports TLS version and the server supports version version should be selected version should not be selected br The server sends its Certificate message depending on the selected cipher suite this may be omitted by the server br The server sends its ServerKeyExchange message depending on the selected cipher suite this may be omitted by the server This message is sent for all DHE ECDHE and DH anon cipher suites br The server sends a ServerHelloDone message indicating it is done with handshake negotiation br The client responds with a ClientKeyExchange message which may contain a PreMasterSecret public key or nothing Again this depends on the selected cipher This PreMasterSecret is encrypted using the public key of the server certificate br The client and server then use the random numbers and PreMasterSecret to compute a common secret called the master secret All other key data session keys such as IV symmetric encryption key MAC key for this connection is derived from this master secret and the client and server generated random values which is passed through a carefully designed pseudorandom function br The client now sends a ChangeCipherSpec record essentially telling the server Everything I tell you from now on will be authenticated and encrypted if encryption parameters were present in the server certificate The ChangeCipherSpec is itself a record level protocol with content type of br The client sends an authenticated and encrypted Finished message containing a hash and MAC over the previous handshake messages br The server will attempt to decrypt the client s Finished message and verify the hash and MAC If the decryption or verification fails the handshake is considered to have failed and the connection should be terminated br Finally the server sends a ChangeCipherSpec telling the client Everything I tell you from now on will be authenticated and encrypted if encryption was negotiated br The server sends its authenticated and encrypted Finished message br The client performs the same decryption and verification procedure as the server did in the previous step br Application phase at this point the handshake is complete and the application protocol is enabled with content type of Application messages exchanged between client and server will also be authenticated and optionally encrypted exactly like in their Finished message Otherwise the content type will return and the client will not authenticate br br br Client authenticated TLS handshake br The following full example shows a client being authenticated in addition to the server as in the example above see mutual authentication via TLS using certificates exchanged between both peers br br Negotiation Phase br A client sends a ClientHello message specifying the highest TLS protocol version it supports a random number a list of suggested cipher suites and compression methods br The server responds with a ServerHello message containing the chosen protocol version a random number cipher suite and compression method from the choices offered by the client The server may also send a session id as part of the message to perform a resumed handshake br The server sends its Certificate message depending on the selected cipher suite this may be omitted by the server br The server sends its ServerKeyExchange message depending on the selected cipher suite this may be omitted by the server This message is sent for all DHE ECDHE and DH anon ciphersuites br The server sends a CertificateRequest message to request a certificate from the client br The server sends a ServerHelloDone message indicating it is done with handshake negotiation br The client responds with a Certificate message which contains the client s certificate but not its private key br The client sends a ClientKeyExchange message which may contain a PreMasterSecret public key or nothing Again this depends on the selected cipher This PreMasterSecret is encrypted using the public key of the server certificate br The client sends a CertificateVerify message which is a signature over the previous handshake messages using the client s certificate s private key This signature can be verified by using the client s certificate s public key This lets the server know that the client has access to the private key of the certificate and thus owns the certificate br The client and server then use the random numbers and PreMasterSecret to compute a common secret called the master secret All other key data session keys for this connection is derived from this master secret and the client and server generated random values which is passed through a carefully designed pseudorandom function br The client now sends a ChangeCipherSpec record essentially telling the server Everything I tell you from now on will be authenticated and encrypted if encryption was negotiated The ChangeCipherSpec is itself a record level protocol and has type and not br Finally the client sends an encrypted Finished message containing a hash and MAC over the previous handshake messages br The server will attempt to decrypt the client s Finished message and verify the hash and MAC If the decryption or verification fails the handshake is considered to have failed and the connection should be torn down br Finally the server sends a ChangeCipherSpec telling the client Everything I tell you from now on will be authenticated and encrypted if encryption was negotiated br The server sends its own encrypted Finished message br The client performs the same decryption and verification procedure as the server did in the previous step br Application phase at this point the handshake is complete and the application protocol is enabled with content type of Application messages exchanged between client and server will also be encrypted exactly like in their Finished message br br br Resumed TLS handshake br Public key operations e g RSA are relatively expensive in terms of computational power TLS provides a secure shortcut in the handshake mechanism to avoid these operations resumed sessions Resumed sessions are implemented using session IDs or session tickets br Apart from the performance benefit resumed sessions can also be used for single sign on as it guarantees that both the original session and any resumed session originate from the same client This is of particular importance for the FTP over TLS SSL protocol which would otherwise suffer from a man in the middle attack in which an attacker could intercept the contents of the secondary data connections br br br TLS handshake br The TLS handshake was condensed to only one round trip compared to the two round trips required in previous versions of TLS SSL br To start the handshake the client guesses which key exchange algorithm will be selected by the server and sends a ClientHello message to the server containing a list of supported ciphers in order of the client s preference and public keys for some or all of its key exchange guesses If the client successfully guesses the key exchange algorithm round trip is eliminated from the handshake After receiving the ClientHello the server selects a cipher and sends back a ServerHello with its own public key followed by server Certificate and Finished messages br After the client receives the server s finished message it now is coordinated with the server on which cipher suite to use br br br Session IDs br In an ordinary full handshake the server sends a session id as part of the ServerHello message The client associates this session id with the server s IP address and TCP port so that when the client connects again to that server it can use the session id to shortcut the handshake In the server the session id maps to the cryptographic parameters previously negotiated specifically the master secret Both sides must have the same master secret or the resumed handshake will fail this prevents an eavesdropper from using a session id The random data in the ClientHello and ServerHello messages virtually guarantee that the generated connection keys will be different from in the previous connection In the RFCs this type of handshake is called an abbreviated handshake It is also described in the literature as a restart handshake br br Negotiation phase br A client sends a ClientHello message specifying the highest TLS protocol version it supports a random number a list of suggested cipher suites and compression methods Included in the message is the session id from the previous TLS connection br The server responds with a ServerHello message containing the chosen protocol version a random number cipher suite and compression method from the choices offered by the client If the server recognizes the session id sent by the client it responds with the same session id The client uses this to recognize that a resumed handshake is being performed If the server does not recognize the session id sent by the client it sends a different value for its session id This tells the client that a resumed handshake will not be performed At this point both the client and server have the master secret and random data to generate the key data to be used for this connection br The server now sends a ChangeCipherSpec record essentially telling the client Everything I tell you from now on will be encrypted The ChangeCipherSpec is itself a record level protocol and has type and not br Finally the server sends an encrypted Finished message containing a hash and MAC over the previous handshake messages br The client will attempt to decrypt the server s Finished message and verify the hash and MAC If the decryption or verification fails the handshake is considered to have failed and the connection should be torn down br Finally the client sends a ChangeCipherSpec telling the server Everything I tell you from now on will be encrypted br The client sends its own encrypted Finished message br The server performs the same decryption and verification procedure as the client did in the previous step br Application phase at this point the handshake is complete and the application protocol is enabled with content type of Application messages exchanged between client and server will also be encrypted exactly like in their Finished message br br br Session tickets br RFC extends TLS via use of session tickets instead of session IDs It defines a way to resume a TLS session without requiring that session specific state is stored at the TLS server br When using session tickets the TLS server stores its session specific state in a session ticket and sends the session ticket to the TLS client for storing The client resumes a TLS session by sending the session ticket to the server and the server resumes the TLS session according to the session specific state in the ticket The session ticket is encrypted and authenticated by the server and the server verifies its validity before using its contents br One particular weakness of this method with OpenSSL is that it always limits encryption and authentication security of the transmitted TLS session ticket to AES CBC SHA no matter what other TLS parameters were negotiated for the actual TLS session This means that the state information the TLS session ticket is not as well protected as the TLS session itself Of particular concern is OpenSSL s storage of the keys in an application wide context SSL CTX i e for the life of the application and not allowing for re keying of the AES CBC SHA TLS session tickets without resetting the application wide OpenSSL context which is uncommon error prone and often requires manual administrative intervention br br br TLS record br This is the general format of all TLS records br br Content type br This field identifies the Record Layer Protocol Type contained in this record br br Legacy version br This field identifies the major and minor version of TLS prior to TLS for the contained message For a ClientHello message this need not be the highest version supported by the client For TLS and later this must to be set x and application must send supported versions in an extra message extension block br br Length br The length of protocol message s MAC and padding fields combined i e q not to exceed bytes KiB br Protocol message s br One or more messages identified by the Protocol field Note that this field may be encrypted depending on the state of the connection br MAC and padding br A message authentication code computed over the protocol message s field with additional key material included Note that this field may be encrypted or not included entirely depending on the state of the connection br No MAC or padding fields can be present at end of TLS records before all cipher algorithms and parameters have been negotiated and handshaked and then confirmed by sending a CipherStateChange record see below for signalling that these parameters will take effect in all further records sent by the same peer br br br Handshake protocol br Most messages exchanged during the setup of the TLS session are based on this record unless an error or warning occurs and needs to be signaled by an Alert protocol record see below or the encryption mode of the session is modified by another record see ChangeCipherSpec protocol below br br Message type br This field identifies the handshake message type br br Handshake message data length br This is a byte field indicating the length of the handshake data not including the header br Note that multiple handshake messages may be combined within one record br br br Alert protocol br This record should normally not be sent during normal handshaking or application exchanges However this message can be sent at any time during the handshake and up to the closure of the session If this is used to signal a fatal error the session will be closed immediately after sending this record so this record is used to give a reason for this closure If the alert level is flagged as a warning the remote can decide to close the session if it decides that the session is not reliable enough for its needs before doing so the remote may also send its own signal br br Level br This field identifies the level of alert If the level is fatal the sender should close the session immediately Otherwise the recipient may decide to terminate the session itself by sending its own fatal alert and closing the session itself immediately after sending it The use of Alert records is optional however if it is missing before the session closure the session may be resumed automatically with its handshakes br Normal closure of a session after termination of the transported application should preferably be alerted with at least the Close notify Alert type with a simple warning level to prevent such automatic resume of a new session Signalling explicitly the normal closure of a secure session before effectively closing its transport layer is useful to prevent or detect attacks like attempts to truncate the securely transported data if it intrinsically does not have a predetermined length or duration that the recipient of the secured data may expect br br Description br This field identifies which type of alert is being sent br br br ChangeCipherSpec protocol br br CCS protocol type br Currently only br br br Application protocol br br Length br Length of application data excluding the protocol header and including the MAC and padding trailers br MAC br bytes for the SHA based HMAC bytes for the SHA based HMAC bytes for the MD based HMAC br Padding br Variable length last byte contains the padding length br br br Support for name based virtual servers br From the application protocol point of view TLS belongs to a lower layer although the TCP IP model is too coarse to show it This means that the TLS handshake is usually except in the STARTTLS case performed before the application protocol can start In the name based virtual server feature being provided by the application layer all co hosted virtual servers share the same certificate because the server has to select and send a certificate immediately after the ClientHello message This is a big problem in hosting environments because it means either sharing the same certificate among all customers or using a different IP address for each of them br There are two known workarounds provided by X br br If all virtual servers belong to the same domain a wildcard certificate can be used Besides the loose host name selection that might be a problem or not there is no common agreement about how to match wildcard certificates Different rules are applied depending on the application protocol or software used br Add every virtual host name in the subjectAltName extension The major problem being that the certificate needs to be reissued whenever a new virtual server is added br To provide the server name RFC Transport Layer Security TLS Extensions allow clients to include a Server Name Indication extension SNI in the extended ClientHello message This extension hints to the server immediately which name the client wishes to connect to so the server br can select the appropriate certificate to send to the clients br RFC also documents a method to implement name based virtual hosting by upgrading HTTP to TLS via an HTTP Upgrade header Normally this is to securely implement HTTP over TLS within the main http URI scheme which avoids forking the URI space and reduces the number of used ports however few implementations currently support this br br br Standards br br br Primary standards br The current approved version of D TLS is version which are specified in br br RFC The Transport Layer Security TLS Protocol Version br RFC The Datagram Transport Layer Security DTLS Protocol Version br The current standards replaces these former versions which are now considered obsolete br br RFC The Transport Layer Security TLS Protocol Version br RFC Datagram Transport Layer Security Version br RFC The Transport Layer Security TLS Protocol Version br RFC Datagram Transport Layer Security br RFC The TLS Protocol Version br RFC The Secure Sockets Layer SSL Protocol Version br Internet Draft The SSL Protocol br br br Extensions br Other RFCs subsequently extended D TLS br Extensions to D TLS include br br RFC GOST Cipher Suites for Transport Layer Security TLS Protocol Version br Extensions to D TLS include br br RFC AES Galois Counter Mode GCM Cipher Suites for TLS br RFC TLS Elliptic Curve Cipher Suites with SHA and AES Galois Counter Mode GCM br RFC Transport Layer Security TLS Renegotiation Indication Extension br RFC Transport Layer Security TLS Authorization Extensions br RFC Camellia Cipher Suites for TLS br RFC Transport Layer Security TLS Extensions Extension Definitions includes Server Name Indication and OCSP stapling br RFC Using OpenPGP Keys for Transport Layer Security TLS Authentication br RFC Prohibiting Secure Sockets Layer SSL Version br RFC Addition of the ARIA Cipher Suites to Transport Layer Security TLS br RFC Datagram Transport Layer Security Version br RFC Addition of the Camellia Cipher Suites to Transport Layer Security TLS br RFC Suite B Profile for Transport Layer Security TLS br RFC AES CCM Cipher Suites for Transport Layer Security TLS br RFC Elliptic Curve Cryptography ECC Brainpool Curves for Transport Layer Security TLS br RFC AES CCM Elliptic Curve Cryptography ECC Cipher Suites for TLS br RFC Transport Layer Security TLS Application Layer Protocol Negotiation Extension br RFC Encrypt then MAC for Transport Layer Security TLS and Datagram Transport Layer Security DTLS br RFC Prohibiting RC Cipher Suites br RFC TLS Fallback Signaling Cipher Suite Value SCSV for Preventing Protocol Downgrade Attacks br RFC Deprecating Secure Sockets Layer Version br RFC Transport Layer Security TLS Session Hash and Extended Master Secret Extension br RFC A Transport Layer Security TLS ClientHello Padding Extension br RFC GOST Cipher Suites for Transport Layer Security TLS Protocol Version br Extensions to D TLS include br br RFC Transport Layer Security TLS Extensions describes both a set of specific extensions and a generic extension mechanism br RFC Elliptic Curve Cryptography ECC Cipher Suites for Transport Layer Security TLS br RFC TLS Handshake Message for Supplemental Data br RFC TLS User Mapping Extension br RFC Pre Shared Key PSK Ciphersuites with NULL Encryption for Transport Layer Security TLS br RFC Using the Secure Remote Password SRP Protocol for TLS Authentication Defines the TLS SRP ciphersuites br RFC Transport Layer Security TLS Session Resumption without Server Side State br RFC Using OpenPGP Keys for Transport Layer Security TLS Authentication obsoleted by RFC br RFC The EAP TLS Authentication Protocol br Extensions to TLS include br br RFC Using TLS with IMAP POP and ACAP Specifies an extension to the IMAP POP and ACAP services that allow the server and client to use transport layer security to provide private authenticated communication over the Internet br RFC Addition of Kerberos Cipher Suites to Transport Layer Security TLS The bit cipher suites defined in this memo appear only for the purpose of documenting the fact that those cipher suite codes have already been assigned br RFC Upgrading to TLS Within HTTP explains how to use the Upgrade mechanism in HTTP to initiate Transport Layer Security TLS over an existing TCP connection This allows unsecured and secured HTTP traffic to share the same well known port in this case http at rather than https at br RFC HTTP Over TLS distinguishes secured traffic from insecure traffic by the use of a different server port br RFC SMTP Service Extension for Secure SMTP over Transport Layer Security Specifies an extension to the SMTP service that allows an SMTP server and client to use transport layer security to provide private authenticated communication over the Internet br RFC AES Ciphersuites for TLS Adds Advanced Encryption Standard AES cipher suites to the previously existing symmetric ciphers br RFC Transport Layer Security TLS Extensions adds a mechanism for negotiating protocol extensions during session initialisation and defines some extensions Made obsolete by RFC br RFC Transport Layer Security Protocol Compression Methods specifies the framework for compression methods and the DEFLATE compression method br RFC Transport Layer Security TLS Protocol Compression Using Lempel Ziv Stac LZS br RFC Addition of Camellia Cipher Suites to Transport Layer Security TLS br RFC Addition of SEED Cipher Suites to Transport Layer Security TLS br RFC Securing FTP with TLS br RFC Pre Shared Key Ciphersuites for Transport Layer Security TLS adds three sets of new cipher suites for the TLS protocol to support authentication based on pre shared keys br br br Informational RFCs br RFC Summarizing Known Attacks on Transport Layer Security TLS and Datagram TLS DTLS br RFC Recommendations for Secure Use of Transport Layer Security TLS and Datagram Transport Layer Security DTLS br br br See also br Application Layer Protocol Negotiation a TLS extension used for SPDY and TLS False Start br Bullrun decryption program a secret anti encryption program run by the U S National Security Agency br Certificate authority br Certificate Transparency br Delegated credential br HTTP Strict Transport Security HSTS br Key ring file br Private Communications Technology PCT a historic Microsoft competitor to SSL br QUIC Quick UDP Internet Connections was designed to provide security protection equivalent to TLS SSL QUIC s main goal is to improve perceived performance of connection oriented web applications that are currently using TCP br Server Gated Cryptography br tcpcrypt br Datagram Transport Layer Security br TLS acceleration br br br br br br Works cited br Sullivan Nick Why TLS isn t in browsers yet The Cloudflare Blog Archived from the original on Retrieved br Thomson Martin Pauly Tommy December Long Term Viability of Protocol Extension Mechanisms doi RFC RFC br br br Further reading br br Wagner David Schneier Bruce November Analysis of the SSL Protocol PDF The Second USENIX Workshop on Electronic Commerce Proceedings USENIX Press pp Archived PDF from the original on Retrieved br Rescorla Eric SSL and TLS Designing and Building Secure Systems United States Addison Wesley Pub Co ISBN br Stephen A Thomas SSL and TLS essentials securing the Web New York Wiley ISBN br Bard Gregory A Challenging But Feasible Blockwise Adaptive Chosen Plaintext Attack on SSL International Association for Cryptologic Research Archived from the original on Retrieved br Canvel Brice Password Interception in a SSL TLS Channel Archived from the original on Retrieved br RFC of change for TLS Renegotiation doi RFC RFC br Creating VPNs with IPsec and SSL TLS Archived at the Wayback Machine Linux Journal article by Rami Rosen br Joshua Davies Implementing SSL TLS Wiley ISBN br Polk Tim McKay Kerry Chokhani Santosh April Guidelines for the Selection Configuration and Use of Transport Layer Security TLS Implementations PDF National Institute of Standards and Technology Archived from the original PDF on Retrieved br Abdou AbdelRahman van Oorschot Paul August Server Location Verification SLV and Server Location Pinning Augmenting TLS Authentication Transactions on Privacy and Security ACM doi S CID Archived from the original on Retrieved br Ivan Ristic Bulletproof TLS and PKI Second Edition Feisty Duck ISBN br br br External links br Internet Engineering Task Force TLS Workgroup Archived at the Wayback Machine