title: Scala (programming language)
id: 3254510
Scala SKAH lah is a strong statically typed high level general purpose programming language that supports both object oriented programming and functional programming Designed to be concise many of Scala s design decisions are intended to address criticisms of Java br Scala source code can be compiled to Java bytecode and run on a Java virtual machine JVM Scala can also be transpiled to JavaScript to run in a browser or compiled directly to a native executable When running on the JVM Scala provides language interoperability with Java so that libraries written in either language may be referenced directly in Scala or Java code Like Java Scala is object oriented and uses a syntax termed curly brace which is similar to the language C Since Scala there is also an option to use the off side rule indenting to structure blocks and its use is advised Martin Odersky has said that this turned out to be the most productive change introduced in Scala br Unlike Java Scala has many features of functional programming languages like Scheme Standard ML and Haskell including currying immutability lazy evaluation and pattern matching It also has an advanced type system supporting algebraic data types covariance and contravariance higher order types but not higher rank types anonymous types operator overloading optional parameters named parameters raw strings and an experimental exception only version of algebraic effects that can be seen as a more powerful version of Java s checked exceptions br The name Scala is a portmanteau of scalable and language signifying that it is designed to grow with the demands of its users br br br History br The design of Scala started in at the cole Polytechnique F d rale de Lausanne EPFL in Lausanne Switzerland by Martin Odersky It followed on from work on Funnel a programming language combining ideas from functional programming and Petri nets Odersky formerly worked on Generic Java and javac Sun s Java compiler br After an internal release in late Scala was released publicly in early on the Java platform A second version v followed in March br On January the Scala team won a five year research grant of over million from the European Research Council On May Odersky and collaborators launched Typesafe Inc later renamed Lightbend Inc a company to provide commercial support training and services for Scala Typesafe received a million investment in from Greylock Partners br As of June Scala maintainers are planning on delivering version by the end of They are concentrating on improving a number of features such as decreasing build times achieving closer integration with tooling enriching user experience UX improving reporting and refining the compiler s stability and accuracy br br br Platforms and license br Scala runs on the Java platform Java virtual machine and is compatible with existing Java programs As Android applications are typically written in Java and translated from Java bytecode into Dalvik bytecode which may be further translated to native machine code during installation when packaged Scala s Java compatibility makes it well suited to Android development the more so when a functional approach is preferred br The reference Scala software distribution including compiler and libraries is released under the Apache license br br br Other compilers and targets br Scala js is a Scala compiler that compiles to JavaScript making it possible to write Scala programs that can run in web browsers or Node js The compiler in development since was announced as no longer experimental in v Version v M was released in June and version in September br Scala Native is a Scala compiler that targets the LLVM compiler infrastructure to create executable code that uses a lightweight managed runtime which uses the Boehm garbage collector The project is led by Denys Shabalin and had its first release on March Development of Scala Native began in with a goal of being faster than just in time compilation for the JVM by eliminating the initial runtime compilation of code and also providing the ability to call native routines directly br A reference Scala compiler targeting the NET Framework and its Common Language Runtime was released in June but was officially dropped in br br br Examples br br br Hello World example br The Hello World program written in Scala has this form br br Unlike the stand alone Hello World application for Java there is no class declaration and nothing is declared to be static br When the program is stored in file HelloWorld scala the user compiles it with the command br br scalac HelloWorld scala br br and runs it with br br scala HelloWorld br br This is analogous to the process for compiling and running Java code Indeed Scala s compiling and executing model is identical to that of Java making it compatible with Java build tools such as Apache Ant br A shorter version of the Hello World Scala program is br br Scala includes an interactive shell and scripting support Saved in a file named HelloWorld scala this can be run as a script using the command br br scala HelloWorld scala br br Commands can also be entered directly into the Scala interpreter using the option e br br scala e println Hello World br br Expressions can be entered interactively in the REPL br br br Basic example br The following example shows the differences between Java and Scala syntax The function mathFunction takes an integer squares it and then adds the cube root of that number to the natural log of that number returning the result i e br br br br br n br br br br br br br br br br ln br br br br n br br br br br br br br displaystyle n ln n br br br br Some syntactic differences in this code are br br Scala does not require semicolons to end statements br Value types are capitalized sentence case Int Double Boolean instead of int double boolean br Parameter and return types follow as in Pascal rather than precede as in C br Methods must be preceded by def br Local or class variables must be preceded by val indicates an immutable variable or var indicates a mutable variable br The return operator is unnecessary in a function although allowed the value of the last executed statement or expression is normally the function s value br Instead of the Java cast operator Type foo Scala uses foo asInstanceOf Type or a specialized function such as toDouble or toInt br Instead of Java s import foo Scala uses import foo br Function or method foo can also be called as just foo method thread send signo can also be called as just thread send signo and method foo toString can also be called as just foo toString br These syntactic relaxations are designed to allow support for domain specific languages br Some other basic syntactic differences br br Array references are written like function calls e g array i rather than array i Internally in Scala the former expands into array apply i which returns the reference br Generic types are written as e g List String rather than Java s List String br Instead of the pseudo type void Scala has the actual singleton class Unit see below br br br Example with classes br The following example contrasts the definition of classes in Java and Scala br br The code above shows some of the conceptual differences between Java and Scala s handling of classes br br Scala has no static variables or methods Instead it has singleton objects which are essentially classes with only one instance Singleton objects are declared using object instead of class It is common to place static variables and methods in a singleton object with the same name as the class name which is then known as a companion object The underlying class for the singleton object has a appended Hence for class Foo with companion object object Foo under the hood there s a class Foo containing the companion object s code and one object of this class is created using the singleton pattern br In place of constructor parameters Scala has class parameters which are placed on the class similar to parameters to a function When declared with a val or var modifier fields are also defined with the same name and automatically initialized from the class parameters Under the hood external access to public fields always goes through accessor getter and mutator setter methods which are automatically created The accessor function has the same name as the field which is why it s unnecessary in the above example to explicitly declare accessor methods Note that alternative constructors can also be declared as in Java Code that would go into the default constructor other than initializing the member variables goes directly at class level br In Scala it is possible to define operators by using symbols as method names In place of addPoint the Scala example defines which is then invoked with infix notation as grid this br Default visibility in Scala is public br br br Features with reference to Java br Scala has the same compiling model as Java and C namely separate compiling and dynamic class loading so that Scala code can call Java libraries br Scala s operational characteristics are the same as Java s The Scala compiler generates byte code that is nearly identical to that generated by the Java compiler In fact Scala code can be decompiled to readable Java code with the exception of certain constructor operations To the Java virtual machine JVM Scala code and Java code are indistinguishable The only difference is one extra runtime library scala library jar br Scala adds a large number of features compared with Java and has some fundamental differences in its underlying model of expressions and types which make the language theoretically cleaner and eliminate several corner cases in Java From the Scala perspective this is practically important because several added features in Scala are also available in C br br br Syntactic flexibility br As mentioned above Scala has a good deal of syntactic flexibility compared with Java The following are some examples br br Semicolons are unnecessary lines are automatically joined if they begin or end with a token that cannot normally come in this position or if there are unclosed parentheses or brackets br Any method can be used as an infix operator e g d apples format num and d apples format num are equivalent In fact arithmetic operators like and are treated just like any other methods since function names are allowed to consist of sequences of arbitrary symbols with a few exceptions made for things like parens brackets and braces that must be handled specially the only special treatment that such symbol named methods undergo concerns the handling of precedence br Methods apply and update have syntactic short forms foo where foo is a value singleton object or class instance is short for foo apply and foo is short for foo update Similarly foo is short for foo apply and foo is short for foo update This is used for collection classes and extends to many other cases such as STM cells br Scala distinguishes between no parens def foo and empty parens def foo methods When calling an empty parens method the parentheses may be omitted which is useful when calling into Java libraries that do not know this distinction e g using foo toString instead of foo toString By convention a method should be defined with empty parens when it performs side effects br Method names ending in colon expect the argument on the left hand side and the receiver on the right hand side For example the Nil is the same as Nil the first form corresponding visually to the result a list with first element and second element br Class body variables can be transparently implemented as separate getter and setter methods For trait FooLike var bar Int an implementation may be object Foo extends FooLike private var x def bar x def bar value Int x value The call site will still be able to use a concise foo bar br The use of curly braces instead of parentheses is allowed in method calls This allows pure library implementations of new control structures For example breakable if break looks as if breakable was a language defined keyword but really is just a method taking a thunk argument Methods that take thunks or functions often place these in a second parameter list allowing to mix parentheses and curly braces syntax Vector fill math random is the same as Vector fill math random The curly braces variant allows the expression to span multiple lines br For expressions explained further down can accommodate any type that defines monadic methods such as map flatMap and filter br By themselves these may seem like questionable choices but collectively they serve the purpose of allowing domain specific languages to be defined in Scala without needing to extend the compiler For example Erlang s special syntax for sending a message to an actor i e actor message can be and is implemented in a Scala library without needing language extensions br br br Unified type system br Java makes a sharp distinction between primitive types e g int and boolean and reference types any class Only reference types are part of the inheritance scheme deriving from java lang Object In Scala all types inherit from a top level class Any whose immediate children are AnyVal value types such as Int and Boolean and AnyRef reference types as in Java This means that the Java distinction between primitive types and boxed types e g int vs Integer is not present in Scala boxing and unboxing is completely transparent to the user Scala allows for new value types to be defined by the user br br br For expressions br Instead of the Java foreach loops for looping through an iterator Scala has for expressions which are similar to list comprehensions in languages such as Haskell or a combination of list comprehensions and generator expressions in Python For expressions using the yield keyword allow a new collection to be generated by iterating over an existing one returning a new collection of the same type They are translated by the compiler into a series of map flatMap and filter calls Where yield is not used the code approximates to an imperative style loop by translating to foreach br A simple example is br br The result of running it is the following vector br br Vector br Note that the expression to is not special syntax The method to is rather defined in the standard Scala library as an extension method on integers using a technique known as implicit conversions that allows new methods to be added to existing types br A more complex example of iterating over a map is br br Expression mention times mentions is an example of pattern matching see below Iterating over a map returns a set of key value tuples and pattern matching allows the tuples to easily be destructured into separate variables for the key and value Similarly the result of the comprehension also returns key value tuples which are automatically built back up into a map because the source object from the variable mentions is a map Note that if mentions instead held a list set array or other collection of tuples exactly the same code above would yield a new collection of the same type br br br Functional tendencies br While supporting all of the object oriented features available in Java and in fact augmenting them in various ways Scala also provides a large number of capabilities that are normally found only in functional programming languages Together these features allow Scala programs to be written in an almost completely functional style and also allow functional and object oriented styles to be mixed br Examples are br br No distinction between statements and expressions br Type inference br Anonymous functions with capturing semantics i e closures br Immutable variables and objects br Lazy evaluation br Delimited continuations since br Higher order functions br Nested functions br Currying br Pattern matching br Algebraic data types through case classes br Tuples br br br Everything is an expression br Unlike C or Java but similar to languages such as Lisp Scala makes no distinction between statements and expressions All statements are in fact expressions that evaluate to some value Functions that would be declared as returning void in C or Java and statements like while that logically do not return a value are in Scala considered to return the type Unit which is a singleton type with only one object of that type Functions and operators that never return at all e g the throw operator or a function that always exits non locally using an exception logically have return type Nothing a special type containing no objects that is a bottom type i e a subclass of every possible type This in turn makes type Nothing compatible with every type allowing type inference to function correctly br Similarly an if then else statement is actually an expression which produces a value i e the result of evaluating one of the two branches This means that such a block of code can be inserted wherever an expression is desired obviating the need for a ternary operator in Scala br br For similar reasons return statements are unnecessary in Scala and in fact are discouraged As in Lisp the last expression in a block of code is the value of that block of code and if the block of code is the body of a function it will be returned by the function br To make it clear that all functions are expressions even methods that return Unit are written with an equals sign br br or equivalently with type inference and omitting the unnecessary newline br br br Type inference br Due to type inference the type of variables function return values and many other expressions can typically be omitted as the compiler can deduce it Examples are val x foo for an immutable constant or immutable object or var x for a variable whose value can later be changed Type inference in Scala is essentially local in contrast to the more global Hindley Milner algorithm used in Haskell ML and other more purely functional languages This is done to facilitate object oriented programming The result is that certain types still need to be declared most notably function parameters and the return types of recursive functions e g br br or with a return type declared for a recursive function br br br Anonymous functions br In Scala functions are objects and a convenient syntax exists for specifying anonymous functions An example is the expression x x which specifies a function with one parameter that compares its argument to see if it is less than It is equivalent to the Lisp form lambda x x Note that neither the type of x nor the return type need be explicitly specified and can generally be inferred by type inference but they can be explicitly specified e g as x Int x or even x Int x Boolean br Anonymous functions behave as true closures in that they automatically capture any variables that are lexically available in the environment of the enclosing function Those variables will be available even after the enclosing function returns and unlike in the case of Java s anonymous inner classes do not need to be declared as final It is even possible to modify such variables if they are mutable and the modified value will be available the next time the anonymous function is called br An even shorter form of anonymous function uses placeholder variables For example the following br br list map x sqrt x br can be written more concisely as br br list map sqrt br or even br br list map sqrt br br br Immutability br Scala enforces a distinction between immutable and mutable variables Mutable variables are declared using the var keyword and immutable values are declared using the val keyword br A variable declared using the val keyword cannot be reassigned in the same way that a variable declared using the final keyword can t be reassigned in Java vals are only shallowly immutable that is an object referenced by a val is not guaranteed to itself be immutable br Immutable classes are encouraged by convention however and the Scala standard library provides a rich set of immutable collection classes br Scala provides mutable and immutable variants of most collection classes and the immutable version is always used unless the mutable version is explicitly imported br The immutable variants are persistent data structures that always return an updated copy of an old object instead of updating the old object destructively in place br An example of this is immutable linked lists where prepending an element to a list is done by returning a new list node consisting of the element and a reference to the list tail br Appending an element to a list can only be done by prepending all elements in the old list to a new list with only the new element br In the same way inserting an element in the middle of a list will copy the first half of the list but keep a reference to the second half of the list This is called structural sharing br This allows for very easy concurrency no locks are needed as no shared objects are ever modified br br br Lazy non strict evaluation br Evaluation is strict eager by default In other words Scala evaluates expressions as soon as they are available rather than as needed However it is possible to declare a variable non strict lazy with the lazy keyword meaning that the code to produce the variable s value will not be evaluated until the first time the variable is referenced Non strict collections of various types also exist such as the type Stream a non strict linked list and any collection can be made non strict with the view method Non strict collections provide a good semantic fit to things like server produced data where the evaluation of the code to generate later elements of a list that in turn triggers a request to a server possibly located somewhere else on the web only happens when the elements are actually needed br br br Tail recursion br Functional programming languages commonly provide tail call optimization to allow for extensive use of recursion without stack overflow problems Limitations in Java bytecode complicate tail call optimization on the JVM In general a function that calls itself with a tail call can be optimized but mutually recursive functions cannot Trampolines have been suggested as a workaround Trampoline support has been provided by the Scala library with the object scala util control TailCalls since Scala released July A function may optionally be annotated with tailrec in which case it will not compile unless it is tail recursive br br An example of this optimization could be implemented using the factorial definition For instance the recursive version of the factorial Could be optimized to the tail recursive version like this However this could compromise composability with other functions because of the new argument on its definition so it is common to use closures to preserve its original signature This ensures tail call optimization and thus prevents a stack overflow error br br br Case classes and pattern matching br Scala has built in support for pattern matching which can be thought of as a more sophisticated extensible version of a switch statement where arbitrary data types can be matched rather than just simple types like integers Booleans and strings including arbitrary nesting A special type of class known as a case class is provided which includes automatic support for pattern matching and can be used to model the algebraic data types used in many functional programming languages From the perspective of Scala a case class is simply a normal class for which the compiler automatically adds certain behaviors that could also be provided manually e g definitions of methods providing for deep comparisons and hashing and destructuring a case class on its constructor parameters during pattern matching br An example of a definition of the quicksort algorithm using pattern matching is this br br The idea here is that we partition a list into the elements less than a pivot and the elements not less recursively sort each part and paste the results together with the pivot in between This uses the same divide and conquer strategy of mergesort and other fast sorting algorithms br The match operator is used to do pattern matching on the object stored in list Each case expression is tried in turn to see if it will match and the first match determines the result In this case Nil only matches the literal object Nil but pivot tail matches a non empty list and simultaneously destructures the list according to the pattern given In this case the associated code will have access to a local variable named pivot holding the head of the list and another variable tail holding the tail of the list Note that these variables are read only and are semantically very similar to variable bindings established using the let operator in Lisp and Scheme br Pattern matching also happens in local variable declarations In this case the return value of the call to tail partition is a tuple in this case two lists Tuples differ from other types of containers e g lists in that they are always of fixed size and the elements can be of differing types although here they are both the same Pattern matching is the easiest way of fetching the two parts of the tuple br The form pivot is a declaration of an anonymous function with a placeholder variable see the section above on anonymous functions br The list operators which adds an element onto the beginning of a list similar to cons in Lisp and Scheme and which appends two lists together similar to append in Lisp and Scheme both appear Despite appearances there is nothing built in about either of these operators As specified above any string of symbols can serve as function name and a method applied to an object can be written infix style without the period or parentheses The line above as written br br qsort smaller pivot qsort rest br could also be written thus br br qsort rest pivot qsort smaller br in more standard method call notation Methods that end with a colon are right associative and bind to the object to the right br br br Partial functions br In the pattern matching example above the body of the match operator is a partial function which consists of a series of case expressions with the first matching expression prevailing similar to the body of a switch statement Partial functions are also used in the exception handling portion of a try statement br br Finally a partial function can be used alone and the result of calling it is equivalent to doing a match over it For example the prior code for quicksort can be written thus br br Here a read only variable is declared whose type is a function from lists of integers to lists of integers and bind it to a partial function Note that the single parameter of the partial function is never explicitly declared or named However we can still call this variable exactly as if it were a normal function br br br Object oriented extensions br Scala is a pure object oriented language in the sense that every value is an object Data types and behaviors of objects are described by classes and traits Class abstractions are extended by subclassing and by a flexible mixin based composition mechanism to avoid the problems of multiple inheritance br Traits are Scala s replacement for Java s interfaces Interfaces in Java versions under are highly restricted able only to contain abstract function declarations This has led to criticism that providing convenience methods in interfaces is awkward the same methods must be reimplemented in every implementation and extending a published interface in a backwards compatible way is impossible Traits are similar to mixin classes in that they have nearly all the power of a regular abstract class lacking only class parameters Scala s equivalent to Java s constructor parameters since traits are always mixed in with a class The super operator behaves specially in traits allowing traits to be chained using composition in addition to inheritance The following example is a simple window system br br A variable may be declared thus br br The result of calling mywin draw is br br In other words the call to draw first executed the code in TitleDecoration the last trait mixed in then through the super calls threaded back through the other mixed in traits and eventually to the code in Window even though none of the traits inherited from one another This is similar to the decorator pattern but is more concise and less error prone as it doesn t require explicitly encapsulating the parent window explicitly forwarding functions whose implementation isn t changed or relying on run time initialization of entity relationships In other languages a similar effect could be achieved at compile time with a long linear chain of implementation inheritance but with the disadvantage compared to Scala that one linear inheritance chain would have to be declared for each possible combination of the mix ins br br br Expressive type system br Scala is equipped with an expressive static type system that mostly enforces the safe and coherent use of abstractions The type system is however not sound In particular the type system supports br br Classes and abstract types as object members br Structural types br Path dependent types br Compound types br Explicitly typed self references br Generic classes br Polymorphic methods br Upper and lower type bounds br Variance br Annotation br Views br Scala is able to infer types by use This makes most static type declarations optional Static types need not be explicitly declared unless a compiler error indicates the need In practice some static type declarations are included for the sake of code clarity br br br Type enrichment br A common technique in Scala known as enrich my library originally termed pimp my library by Martin Odersky in concerns were raised about this phrasing due to its negative connotations and immaturity allows new methods to be used as if they were added to existing types This is similar to the C concept of extension methods but more powerful because the technique is not limited to adding methods and can for instance be used to implement new interfaces In Scala this technique involves declaring an implicit conversion from the type receiving the method to a new type typically a class that wraps the original type and provides the additional method If a method cannot be found for a given type the compiler automatically searches for any applicable implicit conversions to types that provide the method in question br This technique allows new methods to be added to an existing class using an add on library such that only code that imports the add on library gets the new functionality and all other code is unaffected br The following example shows the enrichment of type Int with methods isEven and isOdd br br Importing the members of MyExtensions brings the implicit conversion to extension class IntPredicates into scope br br br Concurrency br Scala s standard library includes support for futures and promises in addition to the standard Java concurrency APIs Originally it also included support for the actor model which is now available as a separate source available platform Akka licensed by Lightbend Inc Akka actors may be distributed or combined with software transactional memory transactors Alternative communicating sequential processes CSP implementations for channel based message passing are Communicating Scala Objects or simply via JCSP br An Actor is like a thread instance with a mailbox It can be created by system actorOf overriding the receive method to receive messages and using the exclamation point method to send a message br The following example shows an EchoServer that can receive messages and then print them br br Scala also comes with built in support for data parallel programming in the form of Parallel Collections integrated into its Standard Library since version br The following example shows how to use Parallel Collections to improve performance br br Besides futures and promises actor support and data parallelism Scala also supports asynchronous programming with software transactional memory and event streams br br br Cluster computing br The most well known open source cluster computing solution written in Scala is Apache Spark Additionally Apache Kafka the publish subscribe message queue popular with Spark and other stream processing technologies is written in Scala br br br Testing br There are several ways to test code in Scala ScalaTest supports multiple testing styles and can integrate with Java based testing frameworks ScalaCheck is a library similar to Haskell s QuickCheck specs is a library for writing executable software specifications ScalaMock provides support for testing high order and curried functions JUnit and TestNG are popular testing frameworks written in Java br br br Versions br br br Comparison with other JVM languages br Scala is often compared with Groovy and Clojure two other programming languages also using the JVM Substantial differences between these languages exist in the type system in the extent to which each language supports object oriented and functional programming and in the similarity of their syntax to that of Java br Scala is statically typed while both Groovy and Clojure are dynamically typed This makes the type system more complex and difficult to understand but allows almost all type errors to be caught at compile time and can result in significantly faster execution By contrast dynamic typing requires more testing to ensure program correctness and thus is generally slower to allow greater programming flexibility and simplicity Regarding speed differences current versions of Groovy and Clojure allow optional type annotations to help programs avoid the overhead of dynamic typing in cases where types are practically static This overhead is further reduced when using recent versions of the JVM which has been enhanced with an invoke dynamic instruction for methods that are defined with dynamically typed arguments These advances reduce the speed gap between static and dynamic typing although a statically typed language like Scala is still the preferred choice when execution efficiency is very important br Regarding programming paradigms Scala inherits the object oriented model of Java and extends it in various ways Groovy while also strongly object oriented is more focused in reducing verbosity In Clojure object oriented programming is deemphasised with functional programming being the main strength of the language Scala also has many functional programming facilities including features found in advanced functional languages like Haskell and tries to be agnostic between the two paradigms letting the developer choose between the two paradigms or more frequently some combination thereof br Regarding syntax similarity with Java Scala inherits much of Java s syntax as is the case with Groovy Clojure on the other hand follows the Lisp syntax which is different in both appearance and philosophy br br br Adoption br br br Language rankings br Back in when Scala was in version the ThoughtWorks Technology Radar which is an opinion based biannual report of a group of senior technologists recommended Scala adoption in its languages and frameworks category br In July this assessment was made more specific and now refers to a Scala the good parts which is described as To successfully use Scala you need to research the language and have a very strong opinion on which parts are right for you creating your own definition of Scala the good parts br In the edition of the State of Java survey which collected data from developers on various Java related topics Scala places third in terms of use of alternative languages on the JVM Relative to the prior year s edition of the survey Scala s use among alternative JVM languages fell from to overtaken by Kotlin which rose from in to in br The Popularity of Programming Language Index which tracks searches for language tutorials ranked Scala th in April with a small downward trend and th in Jan This makes Scala the rd most popular JVM based language after Java and Kotlin ranked th br The RedMonk Programming Language Rankings which establishes rankings based on the number of GitHub projects and questions asked on Stack Overflow in January ranked Scala th Here Scala was placed inside a second tier group of languages ahead of Go PowerShell and Haskell and behind Swift Objective C Typescript and R br The TIOBE index of programming language popularity employs internet search engine rankings and similar publication counting to determine language popularity In September it showed Scala in st place In this ranking Scala was ahead of Haskell th and Erlang but below Go th Swift th and Perl th br As of JVM based languages such as Clojure Groovy and Scala are highly ranked but still significantly less popular than the original Java language which is usually ranked in the top three places br br br Companies br In April Twitter announced that it had switched large portions of its backend from Ruby to Scala and intended to convert the rest br Tesla Inc uses Akka with Scala in the backend of the Tesla Virtual Power Plant Thereby the Actor model is used for representing and operating devices that together with other components make up an instance of the virtual power plant and Reactive Streams are used for data collection and data processing br Apache Kafka is implemented in Scala with regards to most of its core and other critical parts It is maintained and extended through the open source project and by the company Confluent br Gilt uses Scala and Play Framework br Foursquare uses Scala and Lift br Coursera uses Scala and Play Framework br Apple Inc uses Scala in certain teams along with Java and the Play framework br The Guardian newspaper s high traffic website guardian co uk announced in April that it was switching from Java to Scala br The New York Times revealed in that its internal content management system Blackbeard is built using Scala Akka and Play br The Huffington Post newspaper started to employ Scala as part of its content delivery system Athena in br Swiss bank UBS approved Scala for general production use br LinkedIn uses the Scalatra microframework to power its Signal API br Meetup uses Unfiltered toolkit for real time APIs br Remember the Milk uses Unfiltered toolkit Scala and Akka for public API and real time updates br Verizon seeking to make a next generation framework using Scala br Airbnb develops open source machine learning software Aerosolve written in Java and Scala br Zalando moved its technology stack from Java to Scala and Play br SoundCloud uses Scala for its back end employing technologies such as Finagle micro services Scalding and Spark data processing br Databricks uses Scala for the Apache Spark Big Data platform br Morgan Stanley uses Scala extensively in their finance and asset related projects br There are teams within Google and Alphabet Inc that use Scala mostly due to acquisitions such as Firebase and Nest br Walmart Canada uses Scala for their back end platform br Duolingo uses Scala for their back end module that generates lessons br HMRC uses Scala for many UK Government tax applications br M Finance uses Scala for their back end platform br br br Criticism br In November Yammer moved away from Scala for reasons that included the learning curve for new team members and incompatibility from one version of the Scala compiler to the next In March former VP of the Platform Engineering group at Twitter Raffi Krikorian stated that he would not have chosen Scala in due to its learning curve The same month LinkedIn SVP Kevin Scott stated their decision to minimize their dependence on Scala br br br See also br br sbt a widely used build tool for Scala projects br Spark Framework is designed to handle and process big data and it solely supports Scala br Neo j is a java spring framework supported by Scala with domain specific functionality analytical capabilities graph algorithms and many more br Play an open source Web application framework that supports Scala br Akka an open source toolkit for building concurrent and distributed applications br Chisel an open source language built on Scala that is used for hardware design and generation br br br br br br Further reading 