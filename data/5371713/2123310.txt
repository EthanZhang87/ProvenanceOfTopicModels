title: Jazelle
id: 2123310
Jazelle DBX direct bytecode execution is an extension that allows some ARM processors to execute Java bytecode in hardware as a third execution state alongside the existing ARM and Thumb modes Jazelle functionality was specified in the ARMv TEJ architecture and the first processor with Jazelle technology was the ARM EJ S Jazelle is denoted by a J appended to the CPU name except for post v cores where it is required albeit only in trivial form for architecture conformance br Jazelle RCT Runtime Compilation Target is a different technology based on ThumbEE mode it supports ahead of time AOT and just in time JIT compilation with Java and other execution environments br The most prominent use of Jazelle DBX is by manufacturers of mobile phones to increase the execution speed of Java ME games and applications A Jazelle aware Java virtual machine JVM will attempt to run Java bytecode in hardware while returning to the software for more complicated or lesser used bytecode operations ARM claims that approximately of bytecode in typical program usage ends up being directly processed in the hardware br The published specifications are very incomplete being only sufficient for writing operating system code that can support a JVM that uses Jazelle The declared intent is that only the JVM software needs to or is allowed to depend on the hardware interface details This tight binding facilitates the hardware and JVM evolving together without affecting other software In effect this gives ARM Holdings considerable control over which JVMs are able to exploit Jazelle It also prevents open source JVMs from using Jazelle These issues do not apply to the ARMv ThumbEE environment the nominal successor to Jazelle DBX br br br Implementation br The Jazelle extension uses low level binary translation implemented as an extra stage between the fetch and decode stages in the processor instruction pipeline Recognised bytecodes are converted into a string of one or more native ARM instructions br The Jazelle mode moves JVM interpretation into hardware for the most common simple JVM instructions This is intended to significantly reduce the cost of interpretation Among other things this reduces the need for Just in time compilation and other JVM accelerating techniques JVM instructions that are not implemented in Jazelle hardware cause appropriate routines in the Jazelle aware JVM implementation to be invoked Details are not published since all JVM innards are transparent except for performance if correctly interpreted br Jazelle mode is entered via the BXJ instructions A hardware implementation of Jazelle will only cover a subset of JVM bytecodes For unhandled bytecodes or if overridden by the operating system the hardware will invoke the software JVM The system is designed so that the software JVM does not need to know which bytecodes are implemented in hardware and a software fallback is provided by the software JVM for the full set of bytecodes br br br Instruction set br The Jazelle instruction set is well documented as Java bytecode However ARM has not released details on the exact execution environment details the documentation provided with Sun s HotSpot Java Virtual Machine goes as far as to state For the avoidance of doubt distribution of products containing software code to exercise the BXJ instruction and enable the use of the ARM Jazelle architecture extension without agreement from ARM is expressly forbidden br Employees of ARM have in the past published several white papers that do give some good pointers about the processor extension Versions of the ARM Architecture reference Manual available from have included pseudocode for the BXJ Branch and eXchange to Java instruction but with the finer details being shown as SUB ARCHITECTURE DEFINED and documented elsewhere br br br Application binary interface ABI br The Jazelle state relies on an agreed calling convention between the JVM and the Jazelle hardware state This application binary interface is not published by ARM rendering Jazelle an undocumented feature for most users and Free Software JVMs br The entire VM state is held within normal ARM registers allowing compatibility with existing operating systems and interrupt handlers unmodified Restarting a bytecode such as following a return from interrupt will re execute the complete sequence of related ARM instructions br Specific registers are designated to hold the most important parts of the JVM state registers R R hold an alias of the top of the Java stack R holds Java local operand zero pointer to this and R contains the Java stack pointer br Jazelle reuses the existing program counter PC or its synonym register R A pointer to the next bytecode goes in R so the use of the PC is not generally user visible except during debugging br br br CPSR Mode indication br Java bytecode is indicated as the current instruction set by a combination of two bits in the ARM CPSR Current Program Status Register The T bit must be cleared and the J bit set br Bytecodes are decoded by the hardware in two stages versus a single stage for Thumb and ARM code and switching between hardware and software decoding Jazelle mode and ARM mode takes clock cycles br For entry to Jazelle hardware state to succeed the JE Jazelle Enable bit in the CP C C bit register must be set clearing of the JE bit by a privileged operating system provides a high level override to prevent application programs from using the hardware Jazelle acceleration Additionally the CV Configuration Valid bit found in CP c c bit must be set to show that there is a consistent Jazelle state setup for the hardware to use br br br BXJ Branch to Java br The BXJ instruction attempts to switch to Jazelle state and if allowed and successful sets the J bit in the CPSR otherwise it falls through and acts as a standard BX Branch instruction The only time when an operating system or debugger must be fully aware of the Jazelle mode is when decoding a faulted or trapped instruction The Java program counter PC pointing to the next instructions must be placed in the Link Register R before executing the BXJ branch request as regardless of hardware or software processing the system must know where to begin decoding br Because the current state is held in the CPSR the bytecode instruction set is automatically reselected after task switching and processing of the current Java bytecode is restarted br Following an entry into the Jazelle state mode bytecodes can be processed in one of three ways decoded and executed natively in hardware handled in software with optimised ARM ThumbEE JVM code or treated as an invalid illegal opcode The third case will cause a branch to an ARM exception mode as will a Java bytecode of xff which is used for setting JVM breakpoints br Execution will continue in hardware until an unhandled bytecode is encountered or an exception occurs Between and bytecodes out of bytecodes specified in the JVM specification are translated and executed directly in the hardware br br br Low level registers br Low level configuration registers for the hardware virtual machine are held in the ARM Co processor CP register c The registers allow detecting enabling or disabling the hardware accelerator if it is available br br The Jazelle Identity Register in register CP C C is read only accessible in all modes br The Jazelle OS Control Register at CP c c is only accessible in kernel mode and will cause an exception when accessed in user mode br The Jazelle Main Configuration Register at CP C C is write only in user mode and read write in kernel mode br A trivial hardware implementation of Jazelle as found in the QEMU emulator is only required to support the BXJ opcode itself treating BXJ as a normal BX instruction and to return RAZ Read As Zero for all of the CP c Jazelle related registers br br br Successor ThumbEE br The ARMv architecture has de emphasized Jazelle and Direct Bytecode Execution of JVM bytecodes In implementation terms only trivial hardware support for Jazelle is now required support for entering and exiting Jazelle mode but not for executing any Java bytecodes br Instead the Thumb Execution Environment ThumbEE was to be preferred but has since also been deprecated Support for ThumbEE was mandatory in ARMv A processors such as the Cortex A and Cortex A and optional in ARMv R processors ThumbEE targeted compiled environments perhaps using JIT technologies It was not at all specific to Java and was fully documented much broader adoption was anticipated than Jazelle was able to achieve br ThumbEE was a variant of the Thumb bit instruction set It integrated null pointer checking defined some new fault mechanisms and repurposed the bit LDM and STM opcode space to support a few instructions such as range checking a new handler invocation scheme and more Accordingly compilers that produced Thumb or Thumb code could be modified to work with ThumbEE based runtime environments br br br 