title: Common Object Request Broker Architecture
id: 43285
The Common Object Request Broker Architecture CORBA is a standard defined by the Object Management Group OMG designed to facilitate the communication of systems that are deployed on diverse platforms CORBA enables collaboration between systems on different operating systems programming languages and computing hardware CORBA uses an object oriented model although the systems that use the CORBA do not have to be object oriented CORBA is an example of the distributed object paradigm br br br Overview br CORBA enables communication between software written in different languages and running on different computers Implementation details from specific operating systems programming languages and hardware platforms are all removed from the responsibility of developers who use CORBA CORBA normalizes the method call semantics between application objects residing either in the same address space application or in remote address spaces same host or remote host on a network Version was released in October br CORBA uses an interface definition language IDL to specify the interfaces that objects present to the outer world CORBA then specifies a mapping from IDL to a specific implementation language like C or Java Standard mappings exist for Ada C C C COBOL Java Lisp PL I Object Pascal Python Ruby and Smalltalk Non standard mappings exist for C Erlang Perl Tcl and Visual Basic implemented by object request brokers ORBs written for those languages Versions of IDL have changed significantly with annotations replacing some pragmas br The CORBA specification dictates there shall be an ORB through which an application would interact with other objects This is how it is implemented in practice br br The application initializes the ORB and accesses an internal Object Adapter which maintains things like reference counting object and reference instantiation policies and object lifetime policies br The Object Adapter is used to register instances of the generated code classes Generated code classes are the result of compiling the user IDL code which translates the high level interface definition into an OS and language specific class base for use by the user application This step is necessary in order to enforce CORBA semantics and provide a clean user process for interfacing with the CORBA infrastructure br Some IDL mappings are more difficult to use than others For example due to the nature of Java the IDL Java mapping is rather straightforward and makes usage of CORBA very simple in a Java application This is also true of the IDL to Python mapping The C mapping requires the programmer to learn datatypes that predate the C Standard Template Library STL By contrast the C mapping is easier to use but requires heavy use of the STL Since the C language is not object oriented the IDL to C mapping requires a C programmer to manually emulate object oriented features br In order to build a system that uses or implements a CORBA based distributed object interface a developer must either obtain or write the IDL code that defines the object oriented interface to the logic the system will use or implement Typically an ORB implementation includes a tool called an IDL compiler that translates the IDL interface into the target language for use in that part of the system A traditional compiler then compiles the generated code to create the linkable object files for use in the application This diagram illustrates how the generated code is used within the CORBA infrastructure br br This figure illustrates the high level paradigm for remote interprocess communications using CORBA The CORBA specification further addresses data typing exceptions network protocols communication timeouts etc For example Normally the server side has the Portable Object Adapter POA that redirects calls either to the local servants or to balance the load to the other servers The CORBA specification and thus this figure leaves various aspects of distributed system to the application to define including object lifetimes although reference counting semantics are available to applications redundancy fail over memory management dynamic load balancing and application oriented models such as the separation between display data control semantics e g see Model view controller etc br In addition to providing users with a language and a platform neutral remote procedure call RPC specification CORBA defines commonly needed services such as transactions and security events time and other domain specific interface models br br br Versions history br This table presents the history of CORBA standard versions br br Note that IDL changes have progressed with annotations e g unit topic replacing some pragmas br br br Servants br A servant is the invocation target containing methods for handling the remote method invocations In the newer CORBA versions the remote object on the server side is split into the object that is exposed to remote invocations and servant to which the former part forwards the method calls It can be one servant per remote object or the same servant can support several possibly all objects associated with the given Portable Object Adapter The servant for each object can be set or found once and forever servant activation or dynamically chosen each time the method on that object is invoked servant location Both servant locator and servant activator can forward the calls to another server In total this system provides a very powerful means to balance the load distributing requests between several machines In the object oriented languages both remote object and its servant are objects from the viewpoint of the object oriented programming br Incarnation is the act of associating a servant with a CORBA object so that it may service requests Incarnation provides a concrete servant form for the virtual CORBA object Activation and deactivation refer only to CORBA objects while the terms incarnation and etherealization refer to servants However the lifetimes of objects and servants are independent You always incarnate a servant before calling activate object but the reverse is also possible create reference activates an object without incarnating a servant and servant incarnation is later done on demand with a Servant Manager br The Portable Object Adapter POA is the CORBA object responsible for splitting the server side remote invocation handler into the remote object and its servant The object is exposed for the remote invocations while the servant contains the methods that are actually handling the requests The servant for each object can be chosen either statically once or dynamically for each remote invocation in both cases allowing the call forwarding to another server br On the server side the POAs form a tree like structure where each POA is responsible for one or more objects being served The branches of this tree can be independently activated deactivated have the different code for the servant location or activation and the different request handling policies br br br Features br The following describes some of the most significant ways that CORBA can be used to facilitate communication among distributed objects br br br Objects By Reference br This reference is either acquired through a stringified Uniform Resource Locator URL NameService lookup similar to Domain Name System DNS or passed in as a method parameter during a call br Object references are lightweight objects matching the interface of the real object remote or local Method calls on the reference result in subsequent calls to the ORB and blocking on the thread while waiting for a reply success or failure The parameters return data if any and exception data are marshaled internally by the ORB according to the local language and OS mapping br br br Data By Value br The CORBA Interface Definition Language provides the language and OS neutral inter object communication definition CORBA Objects are passed by reference while data integers doubles structs enums etc are passed by value The combination of Objects by reference and data by value provides the means to enforce great data typing while compiling clients and servers yet preserve the flexibility inherent in the CORBA problem space br br br Objects By Value OBV br Apart from remote objects the CORBA and RMI IIOP define the concept of the OBV and Valuetypes The code inside the methods of Valuetype objects is executed locally by default If the OBV has been received from the remote side the needed code must be either a priori known for both sides or dynamically downloaded from the sender To make this possible the record defining OBV contains the Code Base that is a space separated list of URLs whence this code should be downloaded The OBV can also have the remote methods br br br CORBA Component Model CCM br CORBA Component Model CCM is an addition to the family of CORBA definitions It was introduced with CORBA and it describes a standard application framework for CORBA components Though not dependent on language dependent Enterprise Java Beans EJB it is a more general form of EJB providing four component types instead of the two that EJB defines It provides an abstraction of entities that can provide and accept services through well defined named interfaces called ports br The CCM has a component container where software components can be deployed The container offers a set of services that the components can use These services include but are not limited to notification authentication persistence and transaction processing These are the most used services any distributed system requires and by moving the implementation of these services from the software components to the component container the complexity of the components is dramatically reduced br br br Portable interceptors br Portable interceptors are the hooks used by CORBA and RMI IIOP to mediate the most important functions of the CORBA system The CORBA standard defines the following types of interceptors br br IOR interceptors mediate the creation of the new references to the remote objects presented by the current server br Client interceptors usually mediate the remote method calls on the client caller side If the object Servant exists on the same server where the method is invoked they also mediate the local calls br Server interceptors mediate the handling of the remote method calls on the server handler side br The interceptors can attach the specific information to the messages being sent and IORs being created This information can be later read by the corresponding interceptor on the remote side Interceptors can also throw forwarding exceptions redirecting request to another target br br br General InterORB Protocol GIOP br br The GIOP is an abstract protocol by which Object request brokers ORBs communicate Standards associated with the protocol are maintained by the Object Management Group OMG The GIOP architecture provides several concrete protocols including br br Internet InterORB Protocol IIOP The Internet Inter Orb Protocol is an implementation of the GIOP for use over the Internet and provides a mapping between GIOP messages and the TCP IP layer br SSL InterORB Protocol SSLIOP SSLIOP is IIOP over SSL providing encryption and authentication br HyperText InterORB Protocol HTIOP HTIOP is IIOP over HTTP providing transparent proxy bypassing br Zipped IOP ZIOP A zipped version of GIOP that reduces the bandwidth usage br br br VMCID Vendor Minor Codeset ID br Each standard CORBA exception includes a minor code to designate the subcategory of the exception Minor exception codes are of type unsigned long and consist of a bit Vendor Minor Codeset ID VMCID which occupies the high order bits and the minor code proper which occupies the low order bits br Minor codes for the standard exceptions are prefaced by the VMCID assigned to OMG defined as the unsigned long constant CORBA OMGVMCID which has the VMCID allocated to OMG occupying the high order bits The minor exception codes associated with the standard exceptions that are found in Table on page are or ed with OMGVMCID to get the minor code value that is returned in the ex body structure see Section Standard Exception Definitions on page and Section Standard Minor Exception Codes on page br Within a vendor assigned space the assignment of values to minor codes is left to the vendor Vendors may request allocation of VMCIDs by sending email to tagrequest omg org A list of currently assigned VMCIDs can be found on the OMG website at http www omg org cgi bin doc vendor tags br The VMCID and xfffff are reserved for experimental use The VMCID OMGVMCID Section Standard Exception Definitions on page and through xf are reserved for OMG use br The Common Object Request Broker Architecture and Specification CORBA br br br Corba Location CorbaLoc br Corba Location CorbaLoc refers to a stringified object reference for a CORBA object that looks similar to a URL br All CORBA products must support two OMG defined URLs corbaloc and corbaname The purpose of these is to provide a human readable and editable way to specify a location where an IOR can be obtained br An example of corbaloc is shown below br br corbaloc StandardNS NameServer POA root br A CORBA product may optionally support the http ftp and file formats The semantics of these is that they provide details of how to download a stringified IOR or recursively download another URL that will eventually provide a stringified IOR Some ORBs do deliver additional formats which are proprietary for that ORB br br br Benefits br CORBA s benefits include language and OS independence freedom from technology linked implementations strong data typing high level of tunability and freedom from the details of distributed data transfers br br Language independence br CORBA was designed to free engineers from limitations of coupling their designs to a particular software language Currently there are many languages supported by various CORBA providers the most popular being Java and C There are also C C only Smalltalk Perl Ada Ruby and Python implementations just to mention a few br OS independence br CORBA s design is meant to be OS independent CORBA is available in Java OS independent as well as natively for Linux Unix Windows Solaris OS X OpenVMS HPUX Android LynxOS VxWorks ThreadX INTEGRITY and others br Freedom from technologies br One of the main implicit benefits is that CORBA provides a neutral playing field for engineers to be able to normalize the interfaces between various new and legacy systems When integrating C C Object Pascal Java Fortran Python and any other language or OS into a single cohesive system design model CORBA provides the means to level the field and allow disparate teams to develop systems and unit tests that can later be joined together into a whole system This does not rule out the need for basic system engineering decisions such as threading timing object lifetime etc These issues are part of any system regardless of technology CORBA allows system elements to be normalized into a single cohesive system model For example the design of a multitier architecture is made simple using Java Servlets in the web server and various CORBA servers containing the business logic and wrapping the database accesses This allows the implementations of the business logic to change while the interface changes would need to be handled as in any other technology For example a database wrapped by a server can have its database schema change for the sake of improved disk usage or performance or even whole scale database vendor change without affecting the external interfaces At the same time C legacy code can talk to C Fortran legacy code and Java database code and can provide data to a web interface br Data typing br CORBA provides flexible data typing for example an ANY datatype CORBA also enforces tightly coupled data typing reducing human errors In a situation where Name Value pairs are passed around it is conceivable that a server provides a number where a string was expected CORBA Interface Definition Language provides the mechanism to ensure that user code conforms to method names return parameter types and exceptions br High tunability br Many implementations e g ORBexpress Ada C and Java implementation and OmniORB open source C and Python implementation have options for tuning the threading and connection management features Not all ORB implementations provide the same features br Freedom from data transfer details br When handling low level connection and threading CORBA provides a high level of detail in error conditions This is defined in the CORBA defined standard exception set and the implementation specific extended exception set Through the exceptions the application can determine if a call failed for reasons such as Small problem so try again The server is dead or The reference does not make sense The general rule is Not receiving an exception means that the method call completed successfully This is a very powerful design feature br Compression br CORBA marshals its data in a binary form and supports compression IONA Remedy IT and Telef nica have worked on an extension to the CORBA standard that delivers compression This extension is called ZIOP and this is now a formal OMG standard br br br Problems and criticism br While CORBA delivered much in the way code was written and software constructed it has been the subject of criticism br Much of the criticism of CORBA stems from poor implementations of the standard and not deficiencies of the standard itself Some of the failures of the standard itself were due to the process by which the CORBA specification was created and the compromises inherent in the politics and business of writing a common standard sourced by many competing implementors br br Initial implementation incompatibilities br The initial specifications of CORBA defined only the IDL not the on the wire format This meant that source code compatibility was the best that was available for several years With CORBA and later this issue was resolved br Location transparency br CORBA s notion of location transparency has been criticized that is that objects residing in the same address space and accessible with a simple function call are treated the same as objects residing elsewhere different processes on the same machine or different machines This is a fundamental design flaw as it makes all object access as complex as the most complex case i e remote network call with a wide class of failures that are not possible in local calls It also hides the inescapable differences between the two classes making it impossible for applications to select an appropriate use strategy that is a call with s latency and guaranteed return will be used very differently from a call with s latency with possible transport failure in which the delivery status is potentially unknown and might take s to time out br Design and process deficiencies br The creation of the CORBA standard is also often cited for its process of design by committee There was no process to arbitrate between conflicting proposals or to decide on the hierarchy of problems to tackle Thus the standard was created by taking a union of the features in all proposals with no regard to their coherence This made the specification complex expensive to implement entirely and often ambiguous br A design committee composed of a mixture of implementation vendors and customers created a diverse set of interests This diversity made difficult a cohesive standard Standards and interoperability increased competition and eased customers movement between alternative implementations This led to much political fighting within the committee and frequent releases of revisions of the CORBA standard that some ORB implementors ensured were difficult to use without proprietary extensions Less ethical CORBA vendors encouraged customer lock in and achieved strong short term results Over time the ORB vendors that encourage portability took over market share br Problems with implementations br Through its history CORBA has been plagued by shortcomings in poor ORB implementations Unfortunately many of the papers criticizing CORBA as a standard are simply criticisms of a particularly bad CORBA ORB implementation br CORBA is a comprehensive standard with many features Few implementations attempt to implement all of the specifications and initial implementations were incomplete or inadequate As there were no requirements to provide a reference implementation members were free to propose features which were never tested for usefulness or implementability Implementations were further hindered by the general tendency of the standard to be verbose and the common practice of compromising by adopting the sum of all submitted proposals which often created APIs that were incoherent and difficult to use even if the individual proposals were perfectly reasonable br Robust implementations of CORBA have been very difficult to acquire in the past but are now much easier to find The SUN Java SDK comes with CORBA built in Some poorly designed implementations have been found to be complex slow incompatible and incomplete Robust commercial versions began to appear but for significant cost As good quality free implementations became available the bad commercial implementations died quickly br Firewalls br CORBA more precisely GIOP is not tied to any particular communications transport A specialization of GIOP is the Internet Inter ORB Protocol or IIOP IIOP uses raw TCP IP connections in order to transmit data br If the client is behind a very restrictive firewall or transparent proxy server environment that only allows HTTP connections to the outside through port communication may be impossible unless the proxy server in question allows the HTTP CONNECT method or SOCKS connections as well At one time it was difficult even to force implementations to use a single standard port they tended to pick multiple random ports instead As of today current ORBs do have these deficiencies Due to such difficulties some users have made increasing use of web services instead of CORBA These communicate using XML SOAP via port which is normally left open or filtered through a HTTP proxy inside the organization for web browsing via HTTP Recent CORBA implementations though support SSL and can be easily configured to work on a single port Some ORBS such as TAO omniORB and JacORB also support bidirectional GIOP which gives CORBA the advantage of being able to use callback communication rather than the polling approach characteristic of web service implementations Also most modern firewalls support GIOP IIOP and are thus CORBA friendly firewalls br br br See also br br br Software engineering br Component based software engineering br Distributed computing br Portable object br Service oriented architecture SOA br br br Component based software technologies br Freedesktop org D Bus current open cross language cross platform object model br GNOME Bonobo deprecated GNOME cross language object model br KDE DCOP deprecated KDE interprocess and software componentry communication system br KDE KParts KDE component framework br Component Object Model COM Microsoft Windows only cross language object model br DCOM Distributed COM extension making COM able to work in networks br Common Language Infrastructure Current NET cross language cross platform object model br XPCOM Cross Platform Component Object Model developed by Mozilla for applications based on it e g Mozilla Application Suite SeaMonkey x br IBM System Object Model SOM and DSOM component systems from IBM used in OS and AIX br Internet Communications Engine ICE br Java remote method invocation Java RMI br Java Platform Enterprise Edition Java EE br JavaBean br OpenAIR br Remote procedure call RPC br Windows Communication Foundation WCF br Software Communications Architecture SCA components for embedded systems cross language cross transport cross platform br br br Language bindings br Language binding br Foreign function interface br Calling convention br Dynamic Invocation Interface br Name mangling br Application programming interface API br Application binary interface ABI br Comparison of application virtual machines br SWIG opensource automatic interfaces bindings generator from many languages to many languages br br br br br br Further reading br CORBA Current Specification OMG br Orfali Robert The Essential Client Server Survival Guide John Wiley Sons ISBN br Orfali Robert Harkey Dan Edwards Jeri The Essential Distributed Objects Survival Guide John Wiley Sons ISBN br Orfali Robert Harkey Dan Client Server Programming with JAVA and CORBA John Wiley Sons ISBN X br Slama Dirk Garbis Jason Russell Perry Enterprise CORBA Prentice Hall ISBN br Henning Michi Vinoski Steve Advanced CORBA Programming with C Addison Wesley ISBN br Korthaus Axel Schader Martin Aleksy Markus June Implementing Distributed Systems with Java and CORBA Springer ISBN Archived from the original on October Retrieved June br Bolton Fintan Pure Corba Sams Publishing ISBN br Siegel Jon April CORBA Fundamentals and Programming John Wiley Sons ISBN br Zahavi Ron Enterprise Application Integration with CORBA Component and Web Based Solutions John Wiley Sons ISBN br Hartman Bret Beznosov hartman Vinoski Steve Flinn Donald April Enterprise Security with EJB and CORBA John Wiley Sons ISBN br Mowbray Thomas J Zahavi Ron The Essential Corba System Integration Using Distributed Objects John Wiley Sons ISBN br Rosen Michael Curtis David October Integrating CORBA and COM Applications John Wiley Sons ISBN br Brose Gerald Vogel Andreas Duddy Keith January Java Programming with CORBA John Wiley Sons ISBN br Schettino John Hohman Robin S O Hara Liz CORBA For Dummies Hungry Minds ISBN br Rosenberger Jeremy L Teach Yourself CORBA in Days Sams Publishing ISBN br Siegel Jon May Quick CORBA John Wiley Sons ISBN br Mowbray Thomas J Malveau Raphael C CORBA Design Patterns John Wiley Sons ISBN br Orfali Robert Harkey Dan Edwards Jeri Instant CORBA John Wiley Sons ISBN br Harmon Paul Morrissey William The Object Technology Casebook John Wiley Sons ISBN br br br External links br br Official OMG CORBA Components page br Unofficial CORBA Component Model page br Comparing IDL to C with IDL to C br Corba Gone But Hopefully Not Forgotten br OMG XMI Specification