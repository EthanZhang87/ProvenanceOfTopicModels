title: Aspect-oriented programming
id: 145329
In computing aspect oriented programming AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross cutting concerns It does so by adding behavior to existing code an advice without modifying the code instead separately specifying which code is modified via a pointcut specification such as log all function calls when the function s name begins with set This allows behaviors that are not central to the business logic such as logging to be added to a program without cluttering the code of core functions br AOP includes programming methods and tools that support the modularization of concerns at the level of the source code while aspect oriented software development refers to a whole engineering discipline br Aspect oriented programming entails breaking down program logic into cohesive areas of functionality so called concerns Nearly all programming paradigms support some level of grouping and encapsulation of concerns into separate independent entities by providing abstractions e g functions procedures modules classes methods that can be used for implementing abstracting and composing these concerns Some concerns cut across multiple abstractions in a program and defy these forms of implementation These concerns are called cross cutting concerns or horizontal concerns br Logging exemplifies a cross cutting concern because a logging strategy must affect every logged part of the system Logging thereby crosscuts all logged classes and methods br All AOP implementations have some cross cutting expressions that encapsulate each concern in one place The difference between implementations lies in the power safety and usability of the constructs provided For example interceptors that specify the methods to express a limited form of cross cutting without much support for type safety or debugging AspectJ has a number of such expressions and encapsulates them in a special class called an aspect For example an aspect can alter the behavior of the base code the non aspect part of a program by applying advice additional behavior at various join points points in a program specified in a quantification or query called a pointcut that detects whether a given join point matches An aspect can also make binary compatible structural changes to other classes such as adding members or parents br br AOP has several direct antecedents A and A reflection and metaobject protocols subject oriented programming Composition Filters and Adaptive Programming br Gregor Kiczales and colleagues at Xerox PARC developed the explicit concept of AOP and followed this with the AspectJ AOP extension to Java IBM s research team pursued a tool approach over a language design approach and in proposed Hyper J and the Concern Manipulation Environment which have not seen wide use br The examples in this article use AspectJ br The Microsoft Transaction Server is considered to be the first major application of AOP followed by Enterprise JavaBeans br br Typically an aspect is scattered or tangled as code making it harder to understand and maintain It is scattered by the function such as logging being spread over a number of unrelated functions that might use its function possibly in entirely unrelated systems or written in different languages Thus changing logging can require modifying all affected modules Aspects become tangled not only with the mainline function of the systems in which they are expressed but also with each other Changing one concern thus entails understanding all the tangled concerns or having some means by which the effect of changes can be inferred br For example consider a banking application with a conceptually very simple method for transferring an amount from one account to another br br However this transfer method overlooks certain considerations that a deployed application would require such as verifying that the current user is authorized to perform this operation encapsulating database transactions to prevent accidental data loss and logging the operation for diagnostic purposes br A version with all those new concerns might look like this br br In this example other interests have become tangled with the basic functionality sometimes called the business logic concern Transactions security and logging all exemplify cross cutting concerns br Now consider what would happen if we suddenly need to change the security considerations for the application In the program s current version security related operations appear scattered across numerous methods and such a change would require major effort br AOP tries to solve this problem by allowing the programmer to express cross cutting concerns in stand alone modules called aspects Aspects can contain advice code joined to specified points in the program and inter type declarations structural members added to other classes For example a security module can include advice that performs a security check before accessing a bank account The pointcut defines the times join points when one can access a bank account and the code in the advice body defines how the security check is implemented That way both the check and the places can be maintained in one place Further a good pointcut can anticipate later program changes so if another developer creates a new method to access the bank account the advice will apply to the new method when it executes br So for the example above implementing logging in an aspect br br One can think of AOP as a debugging tool or a user level tool Advice should be reserved for cases in which one cannot get the function changed user level or do not want to change the function in production code debugging br br The advice related component of an aspect oriented language defines a join point model JPM A JPM defines three things br br When the advice can run These are called join points because they are points in a running program where additional behavior can be usefully joined A join point needs to be addressable and understandable by an ordinary programmer to be useful It should also be stable across inconsequential program changes to maintain aspect stability Many AOP implementations support method executions and field references as join points br A way to specify or quantify join points called pointcuts Pointcuts determine whether a given join point matches Most useful pointcut languages use a syntax like the base language for example AspectJ uses Java signatures and allow reuse through naming and combination br A means of specifying code to run at a join point AspectJ calls this advice and can run it before after and around join points Some implementations also support defining a method in an aspect on another class br Join point models can be compared based on the join points exposed how join points are specified the operations permitted at the join points and the structural enhancements that can be expressed br br There are other kinds of JPMs All advice languages can be defined in terms of their JPM For example a hypothetical aspect language for UML may have the following JPM br br Join points are all model elements br Pointcuts are some Boolean expression combining the model elements br The means of affect at these points are a visualization of all the matched join points br br Inter type declarations provide a way to express cross cutting concerns affecting the structure of modules Also known as open classes and extension methods this enables programmers to declare in one place members or parents of another class typically to combine all the code related to a concern in one aspect For example if a programmer implemented the cross cutting display update concern using visitors an inter type declaration using the visitor pattern might look like this in AspectJ br br This code snippet adds the acceptVisitor method to the Point class br Any structural additions are required to be compatible with the original class so that clients of the existing class continue to operate unless the AOP implementation can expect to control all clients at all times br br AOP programs can affect other programs in two different ways depending on the underlying languages and environments br br a combined program is produced valid in the original language and indistinguishable from an ordinary program to the ultimate interpreter br the ultimate interpreter or environment is updated to understand and implement AOP features br The difficulty of changing environments means most implementations produce compatible combination programs through a type of program transformation known as weaving An aspect weaver reads the aspect oriented code and generates appropriate object oriented code with the aspects integrated The same AOP language can be implemented through a variety of weaving methods so the semantics of a language should never be understood in terms of the weaving implementation Only the speed of an implementation and its ease of deployment are affected by the method of combination used br Systems can implement source level weaving using preprocessors as C was implemented originally in CFront that require access to program source files However Java s well defined binary form enables bytecode weavers to work with any Java program in class file form Bytecode weavers can be deployed during the build process or if the weave model is per class during class loading AspectJ started with source level weaving in delivered a per class bytecode weaver in and offered advanced load time support after the integration of AspectWerkz in br Any solution that combines programs at runtime must provide views that segregate them properly to maintain the programmer s segregated model Java s bytecode support for multiple source files enables any debugger to step through a properly woven class file in a source editor However some third party decompilers cannot process woven code because they expect code produced by Javac rather than all supported bytecode forms see also Criticism below br Deploy time weaving offers another approach This basically implies post processing but rather than patching the generated code this weaving approach subclasses existing classes so that the modifications are introduced by method overriding The existing classes remain untouched even at runtime and all existing tools such as debuggers and profilers can be used during development A similar approach has already proven itself in the implementation of many Java EE application servers such as IBM s WebSphere br br Standard terminology used in Aspect oriented programming may include br br Cross cutting concerns br Even though most classes in an object oriented model will perform a single specific function they often share common secondary requirements with other classes For example we may want to add logging to classes within the data access layer and also to classes in the UI layer whenever a thread enters or exits a method Further concerns can be related to security such as access control or information flow control Even though each class has a very different primary functionality the code needed to perform the secondary functionality is often identical br br Advice br This is the additional code that you want to apply to your existing model In our example this is the logging code that we want to apply whenever the thread enters or exits a method br Pointcut br This refers to the point of execution in the application at which cross cutting concern needs to be applied In our example a pointcut is reached when the thread enters a method and another pointcut is reached when the thread exits the method br br Aspect br The combination of the pointcut and the advice is termed an aspect In the example above we add a logging aspect to our application by defining a pointcut and giving the correct advice br br Aspects emerged from object oriented programming and reflective programming AOP languages have functionality similar to but more restricted than metaobject protocols Aspects relate closely to programming concepts like subjects mixins and delegation Other ways to use aspect oriented programming paradigms include Composition Filters and the hyperslices approach Since at least the s developers have been using forms of interception and dispatch patching that resemble some of the implementation methods for AOP but these never had the semantics that the cross cutting specifications provide in one place br Designers have considered alternative ways to achieve separation of code such as C s partial types but such approaches lack a quantification mechanism that allows reaching several join points of the code with one declarative statement br Though it may seem unrelated in testing the use of mocks or stubs requires the use of AOP techniques such as around advice Here the collaborating objects are for the purpose of the test a cross cutting concern Thus the various Mock Object frameworks provide these features For example a process invokes a service to get a balance amount In the test of the process it is unimportant where the amount comes from but only that the process uses the balance according to the requirements br br Programmers need to be able to read and understand code to prevent errors br Even with proper education understanding cross cutting concerns can be difficult without proper support for visualizing both static structure and the dynamic flow of a program Starting in AspectJ began to provide IDE plug ins to support the visualizing of cross cutting concerns Those features as well as aspect code assist and refactoring are now common br Given the power of AOP making a logical mistake in expressing cross cutting can lead to widespread program failure Conversely another programmer may change the join points in a program such as by renaming or moving methods in ways that the aspect writer did not anticipate and with unforeseen consequences One advantage of modularizing cross cutting concerns is enabling one programmer to easily affect the entire system As a result such problems manifest as a conflict over responsibility between two or more developers for a given failure AOP can expedite solving these problems as only the aspect must be changed Without AOP the corresponding problems can be much more spread out br br The most basic criticism of the effect of AOP is that control flow is obscured and that it is not only worse than the much maligned GOTO statement but is closely analogous to the joke COME FROM statement The obliviousness of application which is fundamental to many definitions of AOP the code in question has no indication that an advice will be applied which is specified instead in the pointcut means that the advice is not visible in contrast to an explicit method call For example compare the COME FROM program br br with an AOP fragment with analogous semantics br br Indeed the pointcut may depend on runtime condition and thus not be statically deterministic This can be mitigated but not solved by static analysis and IDE support showing which advices potentially match br General criticisms are that AOP purports to improve both modularity and the structure of code but some counter that it instead undermines these goals and impedes independent development and understandability of programs Specifically quantification by pointcuts breaks modularity one must in general have whole program knowledge to reason about the dynamic execution of an aspect oriented program Further while its goals modularizing cross cutting concerns are well understood its actual definition is unclear and not clearly distinguished from other well established techniques Cross cutting concerns potentially cross cut each other requiring some resolution mechanism such as ordering Indeed aspects can apply to themselves leading to problems such as the liar paradox br Technical criticisms include that the quantification of pointcuts defining where advices are executed is extremely sensitive to changes in the program which is known as the fragile pointcut problem The problems with pointcuts are deemed intractable If one replaces the quantification of pointcuts with explicit annotations one obtains attribute oriented programming instead which is simply an explicit subroutine call and suffers the identical problem of scattering which AOP was designed to solve br br Many programming languages have implemented AOP within the language or as an external library including br br NET framework languages C Visual Basic NET VB NET br PostSharp is a commercial AOP implementation with a free but limited edition br Unity provides an API to facilitate proven practices in core areas of programming including data access security logging exception handling and others br AspectDN is an AOP implementation allowing to weave the aspects directly on the NET executable files br ActionScript br Ada br AutoHotkey br C C br COBOL br The Cocoa Objective C frameworks br ColdFusion br Common Lisp br Delphi br Delphi Prism br e IEEE br Emacs Lisp br Groovy br Haskell br Java br AspectJ br JavaScript br Logtalk br Lua br make br Matlab br ML br Nemerle br Perl br PHP br Prolog br Python br Racket br Ruby br Squeak Smalltalk br UML br XML br br Distributed AOP br Attribute grammar a formalism that can be used for aspect oriented programming on functional programming languages br Programming paradigms br Subject oriented programming an alternative to aspect oriented programming br Role oriented programming an alternative to aspect oriented programming br Predicate dispatch an older alternative to aspect oriented programming br Executable UML br Decorator pattern br Domain driven design br br Kiczales G Lamping J Mendhekar A Maeda C Lopes C Loingtier J M Irwin J Aspect oriented programming PDF ECOOP Proceedings of the th European Conference on Object Oriented Programming Lecture Notes in Computer Science LNCS Vol pp CiteSeerX doi BFb ISBN The paper generally considered to be the authoritative reference for AOP br Robert E Filman Tzilla Elrad Siobh n Clarke Mehmet Aksit Aspect Oriented Software Development Addison Wesley ISBN br Renaud Pawlak Lionel Seinturier Jean Philippe Retaill Foundations of AOP for J EE Development Apress ISBN br Laddad Ramnivas AspectJ in Action Practical Aspect Oriented Programming Manning ISBN br Jacobson Ivar Pan Wei Ng Aspect Oriented Software Development with Use Cases Addison Wesley ISBN br Aspect oriented Software Development and PHP Dmitry Sheiko br Siobh n Clarke Elisa Baniassad Aspect Oriented Analysis and Design The Theme Approach Addison Wesley ISBN br Raghu Yedduladoddi Aspect Oriented Software Development An Approach to Composing UML Design Models ISBN br Adaptive Object Oriented Programming Using Graph Based Customization Lieberherr Silva Lepe et al br Zambrano Polo y La Borda Arturo Federico June Addressing aspect interactions in an industrial setting experiences problems and solutions doi Retrieved May cite journal Cite journal requires journal help br Wijesuriya Viraj Brian Aspect Oriented Development Lecture Notes University of Colombo School of Computing Sri Lanka br Groves Matthew D AOP in NET Manning ISBN br br Eric Bodden s list of AOP tools in NET framework br Aspect Oriented Software Development annual conference on AOP br AspectJ Programming Guide br The AspectBench Compiler for AspectJ another Java implementation br Series of IBM developerWorks articles on AOP br Laddad Ramnivas January I want my AOP Part JavaWorld Retrieved July A detailed series of articles on basics of aspect oriented programming and AspectJ br What is Aspect Oriented Programming introduction with RemObjects Taco br Constraint Specification Aspect Weaver br Aspect vs Object Oriented Programming Which Technique When Archived April at the Wayback Machine br Gregor Kiczales Professor of Computer Science explaining AOP video min br Aspect Oriented Programming in COBOL Archived at the Wayback Machine br Aspect Oriented Programming in Java with Spring Framework br Wiki dedicated to AOP methods on NET br Early Aspects for Business Process Modeling An Aspect Oriented Language for BPMN br Spring AOP and AspectJ Introduction br AOSD Graduate Course at Bilkent University br Introduction to AOP Software Engineering Radio Podcast Episode br An Objective C implementation of AOP by Szilveszter Molnar br Aspect Oriented programming for iOS and OS X by Manuel Gebele br DevExpress MVVM Framework Introduction to POCO ViewModels