title: Message queue
id: 429709
In computer science message queues and mailboxes are software engineering components typically used for inter process communication IPC or for inter thread communication within the same process They use a queue for messaging the passing of control or of content Group communication systems provide similar kinds of functionality br The message queue paradigm is a sibling of the publisher subscriber pattern and is typically one part of a larger message oriented middleware system Most messaging systems support both the publisher subscriber and message queue models in their API e g Java Message Service JMS br Competing Consumers pattern enables multiple concurrent consumers to process messages on the same message queue br br br Remit and ownership br Message queues implement an asynchronous communication pattern between two or more processes threads whereby the sending and receiving party do not need to interact with the message queue at the same time Messages placed onto the queue are stored until the recipient retrieves them Message queues have implicit or explicit limits on the size of data that may be transmitted in a single message and the number of messages that may remain outstanding on the queue br br br Remit br Many implementations of message queues function internally within an operating system or within an application Such queues exist for the purposes of that system only br Other implementations allow the passing of messages between different computer systems potentially connecting multiple applications and multiple operating systems These message queuing systems typically provide resilience functionality to ensure that messages do not get lost in the event of a system failure Examples of commercial implementations of this kind of message queuing software also known as message oriented middleware include IBM MQ formerly MQ Series and Oracle Advanced Queuing AQ There is a Java standard called Java Message Service which has several proprietary and free software implementations br Real time operating systems RTOSes such as VxWorks and QNX encourage the use of message queuing as the primary inter process or inter thread communication mechanism This can result in integration between message passing and CPU scheduling Early examples of commercial RTOSes that encouraged a message queue basis to inter thread communication also include VRTX and pSOS both of which date to the early s The Erlang programming language uses processes to provide concurrency these processes communicate asynchronously using message queuing br br br Ownership br The message queue software can be either proprietary open source or a mix of both It is then run either on premise in private servers or on external cloud servers message queuing service br br Proprietary options have the longest history and include products from the inception of message queuing such as IBM MQ and those tied to specific operating systems such as Microsoft Message Queuing MSMQ Cloud service providers also provide their proprietary solutions such as Amazon Simple Queue Service SQS StormMQ Solace and IBM MQ br Open source choices of messaging middleware systems includes Apache ActiveMQ Apache Kafka Apache Qpid Apache RocketMQ Enduro X JBoss Messaging JORAM RabbitMQ Sun Open Message Queue and Tarantool br Examples on hardware based messaging middleware vendors are Solace Apigee and IBM MQ br br br Usage br In a typical message queueing implementation a system administrator installs and configures message queueing software a queue manager or broker and defines a named message queue Or they register with a message queuing service br An application then registers a software routine that listens for messages placed onto the queue br Second and subsequent applications may connect to the queue and transfer a message onto it br The queue manager software stores the messages until a receiving application connects and then calls the registered software routine The receiving application then processes the message in an appropriate manner br There are often numerous options as to the exact semantics of message passing including br br Durability messages may be kept in memory written to disk or even committed to a DBMS if the need for reliability indicates a more resource intensive solution br Security policies which applications should have access to these messages br Message purging policies queues or messages may have a time to live br Message filtering some systems support filtering data so that a subscriber may only see messages matching some pre specified criteria of interest br Delivery policies do we need to guarantee that a message is delivered at least once or no more than once br Routing policies in a system with many queue servers what servers should receive a message or a queue s messages br Batching policies should messages be delivered immediately Or should the system wait a bit and try to deliver many messages at once br Queuing criteria when should a message be considered enqueued When one queue has it Or when it has been forwarded to at least one remote queue Or to all queues br Receipt notification A publisher may need to know when some or all subscribers have received a message br These are all considerations that can have substantial effects on transaction semantics system reliability and system efficiency br br br Standards and protocols br Historically message queuing has used proprietary closed protocols restricting the ability for different operating systems or programming languages to interact in a heterogeneous set of environments br An early attempt to make message queuing more ubiquitous was Sun Microsystems JMS specification which provided a Java only abstraction of a client API This allowed Java developers to switch between providers of message queuing in a fashion similar to that of developers using SQL databases In practice given the diversity of message queuing techniques and scenarios this wasn t always as practical as it could be br Three standards have emerged which are used in open source message queue implementations br br Advanced Message Queuing Protocol AMQP feature rich message queue protocol approved as ISO IEC since April br Streaming Text Oriented Messaging Protocol STOMP simple text oriented message protocol br MQTT formerly MQ Telemetry Transport lightweight message queue protocol especially for embedded devices br These protocols are at different stages of standardization and adoption The first two operate at the same level as HTTP MQTT at the level of TCP IP br Some proprietary implementations also use HTTP to provide message queuing by some implementations such as Amazon s SQS This is because it is always possible to layer asynchronous behaviour which is what is required for message queuing over a synchronous protocol using request response semantics However such implementations are constrained by the underlying protocol in this case and may not be able to offer the full fidelity or set of options required in message passing above br br br Synchronous vs asynchronous br Many of the more widely known communications protocols in use operate synchronously The HTTP protocol used in the World Wide Web and in web services offers an obvious example where a user sends a request for a web page and then waits for a reply br However scenarios exist in which synchronous behaviour is not appropriate For example AJAX Asynchronous JavaScript and XML can be used to asynchronously send text JSON or XML messages to update part of a web page with more relevant information Google uses this approach for their Google Suggest a search feature which sends the user s partially typed queries to Google s servers and returns a list of possible full queries the user might be interested in the process of typing This list is asynchronously updated as the user types br Other asynchronous examples exist in event notification systems and publish subscribe systems br br An application may need to notify another that an event has occurred but does not need to wait for a response br In publish subscribe systems an application publishes information for any number of clients to read br In both of the above examples it would not make sense for the sender of the information to have to wait if for example one of the recipients had crashed br Applications need not be exclusively synchronous or asynchronous An interactive application may need to respond to certain parts of a request immediately such as telling a customer that a sales request has been accepted and handling the promise to draw on inventory but may queue other parts such as completing calculation of billing forwarding data to the central accounting system and calling on all sorts of other services to be done some time later br In all these sorts of situations having a subsystem which performs message queuing or alternatively a broadcast messaging system can help improve the behavior of the overall system br br br Implementation in UNIX br There are two common message queue implementations in UNIX One is part of the SYS V API the other one is part of POSIX br br br SYS V br UNIX SYS V implements message passing by keeping an array of linked lists as message queues Each message queue is identified by its index in the array and has a unique descriptor A given index can have multiple possible descriptors UNIX gives standard functions to access the message passing feature br br msgget br This system call takes a key as an argument and returns a descriptor of the queue with the matching key if it exists If it does not exist and the IPC CREAT flag is set it makes a new message queue with the given key and returns its descriptor br msgrcv br Used to receive a message from a given queue descriptor The caller process must have read permissions for the queue It is of two types br Blocking receive puts the child to sleep if it cannot find a requested message type It sleeps until another message is posted in the queue and then wakes up to check again br Non blocking receive returns immediately to the caller mentioning that it failed br msgctl br Used to change message queue parameters like the owner Most importantly it is used to delete the message queue by passing the IPC RMID flag A message queue can be deleted only by its creator owner or the superuser br br br POSIX br The POSIX message queue API is the later of the two UNIX message queue APIs It is distinct from the SYS V API but provides similar function The unix man page mq overview provides an overview of POSIX message queues br br br Graphical user interfaces br Graphical user interfaces GUIs employ a message queue also called an event queue or input queue to pass graphical input actions such as mouse clicks keyboard events or other user inputs to the application program The windowing system places messages indicating user or other events such as timer ticks or messages sent by other threads into the message queue The GUI application removes these events one at a time by calling a routine called getNextEvent or similar in an event loop and then calling the appropriate application routine to process that event br br br See also br br br 