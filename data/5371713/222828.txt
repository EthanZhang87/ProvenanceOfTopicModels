title: Unit testing
id: 222828
Unit testing a k a component or module testing is a form of software testing by which isolated source code is tested to validate expected behavior br Unit testing describes tests that are run at the unit level to contrast testing at the integration or system level br br Unit testing as principle for testing separately smaller parts of large software systems dates back to the early days of software engineering In June H D Benington presented at US Navy s Symposium on Advanced Programming Methods for Digital Computers the SAGE project and its specification based approach where the coding phase was followed by parameter testing to validate component subprograms against their specification followed then by an assembly testing for parts put together br In a similar approach is described for the software of the Mercury project where individual units developed by different programmes underwent unit tests before being integrated together In testing methodologies appear more structured with unit tests component tests and integration tests with the purpose of validating individual parts written separately and their progressive assembly into larger blocks Some public standards adopted end of the s such as MIL STD and MIL STD contributed further to a wide acceptance of unit testing in large projects br Unit testing was in those times interactive or automated using either coded tests or capture and replay testing tools In Kent Beck described a testing framework for Smalltalk later called SUnit in Simple Smalltalk Testing With Patterns In Kent Beck and Erich Gamma developed and released JUnit a unit test framework that became popular with Java developers Google embraced automated testing around br br Unit is defined as a single behaviour exhibited by the system under test SUT usually corresponding to a requirement While it may imply it s a function or a module in procedural programming or a method or a class in object oriented programming it doesn t mean functions methods modules or classes always correspond to units From the system requirements perspective only the perimeter of the system is relevant thus only entry points to externally visible system behaviours define units br br Unit tests can be performed manually or via automated test execution Automated tests include benefits such as running tests often running tests without staffing cost and consistent and repeatable testing br Testing is often performed by the programmer who writes and modifies the code under test br Unit testing may be viewed as part of the process of writing code br br During development a programmer may code criteria or results that are known to be good into the test to verify the unit s correctness br During test execution frameworks log tests that fail any criterion and report them in a summary br For this the most commonly used approach is test function expected value br br A parameterized test is a test that accepts a set of values that can be used to enable the test to run with multiple different input values A testing framework that supports parametrized tests supports a way to encode parameter sets and to run the test with each set br Use of parametrized tests can reduce test code duplication br Parameterized tests are supported by TestNG JUnit XUnit and NUnit as well as in various JavaScript test frameworks br Parameters for the unit tests may be coded manually or in some cases are automatically generated by the test framework In recent years support was added for writing more powerful unit tests leveraging the concept of theories test cases that execute the same steps but using test data generated at runtime unlike regular parameterized tests that use the same execution steps with input sets that are pre defined br br Sometimes in the agile software development unit testing is done per user story and comes in the later half of the sprint after requirements gathering and development are complete Typically the developers or other members from the development team such as consultants will write step by step test scripts for the developers to execute in the tool Test scripts are generally written to prove the effective and technical operation of specific developed features in the tool as opposed to full fledged business processes that would be interfaced by the end user which is typically done during user acceptance testing If the test script can be fully executed from start to finish without incident the unit test is considered to have passed otherwise errors are noted and the user story is moved back to development in an in progress state User stories that successfully pass unit tests are moved on to the final steps of the sprint Code review peer review and then lastly a show back session demonstrating the developed tool to stakeholders br br In test driven development TDD unit tests are written while the production code is written Starting with working code the developer adds test code for a required behavior then adds just enough code to make the test pass then refactors the code including test code as makes sense and then repeats by adding another test br br Unit testing is intended to ensure that the units meet their design and behave as intended br By writing tests first for the smallest testable units then the compound behaviors between those one can build up comprehensive tests for complex applications br One goal of unit testing is to isolate each part of the program and show that the individual parts are correct A unit test provides a strict written contract that the piece of code must satisfy br br Unit testing finds problems early in the development cycle This includes both bugs in the programmer s implementation and flaws or missing parts of the specification for the unit The process of writing a thorough set of tests forces the author to think through inputs outputs and error conditions and thus more crisply define the unit s desired behavior br br The cost of finding a bug before coding begins or when the code is first written is considerably lower than the cost of detecting identifying and correcting the bug later Bugs in released code may also cause costly problems for the end users of the software Code can be impossible or difficult to unit test if poorly written thus unit testing can force developers to structure functions and objects in better ways br br Unit testing enables more frequent releases in software development By testing individual components in isolation developers can quickly identify and address issues leading to faster iteration and release cycles br br Unit testing allows the programmer to refactor code or upgrade system libraries at a later date and make sure the module still works correctly e g in regression testing The procedure is to write test cases for all functions and methods so that whenever a change causes a fault it can be identified quickly br br Unit tests detect changes which may break a design contract br br Unit testing may reduce uncertainty in the units themselves and can be used in a bottom up testing style approach By testing the parts of a program first and then testing the sum of its parts integration testing becomes much easier br br Some programmers contend that unit tests provide a form of documentation of the code Developers wanting to learn what functionality is provided by a unit and how to use it can review the unit tests to gain an understanding of it br Test cases can embody characteristics that are critical to the success of the unit These characteristics can indicate appropriate inappropriate use of a unit as well as negative behaviors that are to be trapped by the unit A test case documents these critical characteristics although many software development environments do not rely solely upon code to document the product in development br In some processes the act of writing tests and the code under test plus associated refactoring may take the place of formal design Each unit test can be seen as a design element specifying classes methods and observable behavior br br Testing will not catch every error in the program because it cannot evaluate every execution path in any but the most trivial programs This problem is a superset of the halting problem which is undecidable The same is true for unit testing Additionally unit testing by definition only tests the functionality of the units themselves Therefore it will not catch integration errors or broader system level errors such as functions performed across multiple units or non functional test areas such as performance Unit testing should be done in conjunction with other software testing activities as they can only show the presence or absence of particular errors they cannot prove a complete absence of errors To guarantee correct behavior for every execution path and every possible input and ensure the absence of errors other techniques are required namely the application of formal methods to prove that a software component has no unexpected behavior br An elaborate hierarchy of unit tests does not equal integration testing Integration with peripheral units should be included in integration tests but not in unit tests Integration testing typically still relies heavily on humans testing manually high level or global scope testing can be difficult to automate such that manual testing often appears faster and cheaper br Software testing is a combinatorial problem For example every Boolean decision statement requires at least two tests one with an outcome of true and one with an outcome of false As a result for every line of code written programmers often need to lines of test code This obviously takes time and its investment may not be worth the effort There are problems that cannot easily be tested at all for example those that are nondeterministic or involve multiple threads In addition code for a unit test is as likely to be buggy as the code it is testing Fred Brooks in The Mythical Man Month quotes Never go to sea with two chronometers take one or three Meaning if two chronometers contradict how do you know which one is correct br br Another challenge related to writing the unit tests is the difficulty of setting up realistic and useful tests It is necessary to create relevant initial conditions so the part of the application being tested behaves like part of the complete system If these initial conditions are not set correctly the test will not be exercising the code in a realistic context which diminishes the value and accuracy of unit test results br br To obtain the intended benefits from unit testing rigorous discipline is needed throughout the software development process br br It is essential to keep careful records not only of the tests that have been performed but also of all changes that have been made to the source code of this or any other unit in the software Use of a version control system is essential If a later version of the unit fails a particular test that it had previously passed the version control software can provide a list of the source code changes if any that have been applied to the unit since that time br br It is also essential to implement a sustainable process for ensuring that test case failures are reviewed regularly and addressed immediately If such a process is not implemented and ingrained into the team s workflow the application will evolve out of sync with the unit test suite increasing false positives and reducing the effectiveness of the test suite br br Unit testing embedded system software presents a unique challenge Because the software is being developed on a different platform than the one it will eventually run on you cannot readily run a test program in the actual deployment environment as is possible with desktop programs br br Unit tests tend to be easiest when a method has input parameters and some output It is not as easy to create unit tests when a major function of the method is to interact with something external to the application For example a method that will work with a database might require a mock up of database interactions to be created which probably won t be as comprehensive as the real database interactions br br Below is an example of a JUnit test suite It focuses on the Adder class br br The test suite uses assert statements to verify the expected result of various input values to the sum method br br Using unit tests as a design specification has one significant advantage over other design methods The design document the unit tests themselves can itself be used to verify the implementation The tests will never pass unless the developer implements a solution according to the design br Unit testing lacks some of the accessibility of a diagrammatic specification such as a UML diagram but they may be generated from the unit test using automated tools Most modern languages have free tools usually available as extensions to IDEs Free tools like those based on the xUnit framework outsource to another system the graphical rendering of a view for human consumption br br Unit testing is the cornerstone of extreme programming which relies on an automated unit testing framework This automated unit testing framework can be either third party e g xUnit or created within the development group br Extreme programming uses the creation of unit tests for test driven development The developer writes a unit test that exposes either a software requirement or a defect This test will fail because either the requirement isn t implemented yet or because it intentionally exposes a defect in the existing code Then the developer writes the simplest code to make the test along with other tests pass br Most code in a system is unit tested but not necessarily all paths through the code Extreme programming mandates a test everything that can possibly break strategy over the traditional test every execution path method This leads developers to develop fewer tests than classical methods but this isn t really a problem more a restatement of fact as classical methods have rarely ever been followed methodically enough for all execution paths to have been thoroughly tested Extreme programming simply recognizes that testing is rarely exhaustive because it is often too expensive and time consuming to be economically viable and provides guidance on how to effectively focus limited resources br Crucially the test code is considered a first class project artifact in that it is maintained at the same quality as the implementation code with all duplication removed Developers release unit testing code to the code repository in conjunction with the code it tests Extreme programming s thorough unit testing allows the benefits mentioned above such as simpler and more confident code development and refactoring simplified code integration accurate documentation and more modular designs These unit tests are also constantly run as a form of regression test br Unit testing is also critical to the concept of Emergent Design As emergent design is heavily dependent upon refactoring unit tests are an integral component br br An automated testing framework provides features for automating test execution and can accelerate writing and running tests Frameworks have been developed for a wide variety of programming languages br Generally frameworks are third party not distributed with a compiler or integrated development environment IDE br Tests can be written without using a framework to exercise the code under test using assertions exception handling and other control flow mechanisms to verify behavior and report failure Some note that testing without a framework is valuable since there is a barrier to entry for the adoption of a framework that having some tests is better than none but once a framework is in place adding tests can be easier br In some frameworks advanced test features are missing and must be hand coded br br Some programming languages directly support unit testing Their grammar allows the direct declaration of unit tests without importing a library whether third party or standard Additionally the Boolean conditions of the unit tests can be expressed in the same syntax as Boolean expressions used in non unit test code such as what is used for if and while statements br Languages with built in unit testing support include br br Languages with standard unit testing framework support include br br Some languages do not have built in unit testing support but have established unit testing libraries or frameworks These languages include br br Feathers Michael C Working Effectively with Legacy Code Upper Saddle River NJ Prentice Hall Professional Technical Reference ISBN br Gulati Shekhar Sharma Rahul Java Unit Testing with JUnit Apress br br Test Driven Development Ward Cunningham s Wiki 