title: Generic programming
id: 105837
Generic programming is a style of computer programming in which algorithms are written in terms of data types to be specified later that are then instantiated when needed for specific types provided as parameters This approach pioneered by the ML programming language in permits writing common functions or types that differ only in the set of types on which they operate when used thus reducing duplicate code br Generic programming was introduced to the mainstream with Ada in With templates in C generic programming became part of the repertoire of professional library design The techniques were further improved and parameterized types were introduced in the influential book Design Patterns br New techniques were introduced by Andrei Alexandrescu in his book Modern C Design Generic Programming and Design Patterns Applied Subsequently D implemented the same ideas br Such software entities are known as generics in Ada C Delphi Eiffel F Java Nim Python Go Rust Swift TypeScript and Visual Basic NET They are known as parametric polymorphism in ML Scala Julia and Haskell Haskell terminology also uses the term generic for a related but somewhat different concept br The term generic programming was originally coined by David Musser and Alexander Stepanov in a more specific sense than the above to describe a programming paradigm in which fundamental requirements on data types are abstracted from across concrete examples of algorithms and data structures and formalized as concepts with generic functions implemented in terms of these concepts typically using language genericity mechanisms as described above br br br Stepanov Musser and other generic programming paradigms br Generic programming is defined in Musser Stepanov as follows br br Generic programming centers around the idea of abstracting from concrete efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software br The generic programming paradigm is an approach to software decomposition whereby fundamental requirements on types are abstracted from across concrete examples of algorithms and data structures and formalized as concepts analogously to the abstraction of algebraic theories in abstract algebra Early examples of this programming approach were implemented in Scheme and Ada although the best known example is the Standard Template Library STL which developed a theory of iterators that is used to decouple sequence data structures and the algorithms operating on them br For example given N sequence data structures e g singly linked list vector etc and M algorithms to operate on them e g find sort etc a direct approach would implement each algorithm specifically for each data structure giving N M combinations to implement However in the generic programming approach each data structure returns a model of an iterator concept a simple value type that can be dereferenced to retrieve the current value or changed to point to another value in the sequence and each algorithm is instead written generically with arguments of such iterators e g a pair of iterators pointing to the beginning and end of the subsequence or range to process Thus only N M data structure algorithm combinations need be implemented Several iterator concepts are specified in the STL each a refinement of more restrictive concepts e g forward iterators only provide movement to the next value in a sequence e g suitable for a singly linked list or a stream of input data whereas a random access iterator also provides direct constant time access to any element of the sequence e g suitable for a vector An important point is that a data structure will return a model of the most general concept that can be implemented efficiently computational complexity requirements are explicitly part of the concept definition This limits the data structures a given algorithm can be applied to and such complexity requirements are a major determinant of data structure choice Generic programming similarly has been applied in other domains e g graph algorithms br Although this approach often uses language features of compile time genericity and templates it is independent of particular language technical details Generic programming pioneer Alexander Stepanov wrote br br Generic programming is about abstracting and classifying algorithms and data structures It gets its inspiration from Knuth and not from type theory Its goal is the incremental construction of systematic catalogs of useful efficient and abstract algorithms and data structures Such an undertaking is still a dream br I believe that iterator theories are as central to Computer Science as theories of rings or Banach spaces are central to Mathematics br Bjarne Stroustrup noted br br Following Stepanov we can define generic programming without mentioning language features Lift algorithms and data structures from concrete examples to their most general and abstract form br Other programming paradigms that have been described as generic programming include Datatype generic programming as described in Generic Programming an Introduction The Scrap your boilerplate approach is a lightweight generic programming approach for Haskell br In this article we distinguish the high level programming paradigms of generic programming above from the lower level programming language genericity mechanisms used to implement them see Programming language support for genericity For further discussion and comparison of generic programming paradigms see br br br Programming language support for genericity br Genericity facilities have existed in high level languages since at least the s in languages such as ML CLU and Ada and were subsequently adopted by many object based and object oriented languages including BETA C D Eiffel Java and DEC s now defunct Trellis Owl br Genericity is implemented and supported differently in various programming languages the term generic has also been used differently in various programming contexts For example in Forth the compiler can execute code while compiling and one can create new compiler keywords and new implementations for those words on the fly It has few words that expose the compiler behaviour and therefore naturally offers genericity capacities that however are not referred to as such in most Forth texts Similarly dynamically typed languages especially interpreted ones usually offer genericity by default as both passing values to functions and value assignment are type indifferent and such behavior is often used for abstraction or code terseness however this is not typically labeled genericity as it s a direct consequence of the dynamic typing system employed by the language The term has been used in functional programming specifically in Haskell like languages which use a structural type system where types are always parametric and the actual code on those types is generic These uses still serve a similar purpose of code saving and rendering an abstraction br Arrays and structs can be viewed as predefined generic types Every usage of an array or struct type instantiates a new concrete type or reuses a previous instantiated type Array element types and struct element types are parameterized types which are used to instantiate the corresponding generic type All this is usually built in in the compiler and the syntax differs from other generic constructs Some extensible programming languages try to unify built in and user defined generic types br A broad survey of genericity mechanisms in programming languages follows For a specific survey comparing suitability of mechanisms for generic programming see br br br In object oriented languages br When creating container classes in statically typed languages it is inconvenient to write specific implementations for each datatype contained especially if the code for each datatype is virtually identical For example in C this duplication of code can be circumvented by defining a class template br br Above T is a placeholder for whatever type is specified when the list is created These containers of type T commonly called templates allow a class to be reused with different datatypes as long as certain contracts such as subtypes and signature are kept This genericity mechanism should not be confused with inclusion polymorphism which is the algorithmic usage of exchangeable sub classes for instance a list of objects of type Moving Object containing objects of type Animal and Car Templates can also be used for type independent functions as in the Swap example below br br The C template construct used above is widely cited as the genericity construct that popularized the notion among programmers and language designers and supports many generic programming idioms The D programming language also offers fully generic capable templates based on the C precedent but with a simplified syntax The Java programming language has provided genericity facilities syntactically based on C s since the introduction of Java Platform Standard Edition J SE br C Oxygene formerly Chrome and Visual Basic NET have constructs that exploit the support for generics present in Microsoft NET Framework since version br br br Generics in Ada br br Ada has had generics since it was first designed in The standard library uses generics to provide many services Ada adds a comprehensive generic container library to the standard library which was inspired by C s standard template library br A generic unit is a package or a subprogram that takes one or more generic formal parameters br A generic formal parameter is a value a variable a constant a type a subprogram or even an instance of another designated generic unit For generic formal types the syntax distinguishes between discrete floating point fixed point access pointer types etc Some formal parameters can have default values br To instantiate a generic unit the programmer passes actual parameters for each formal The generic instance then behaves just like any other unit It is possible to instantiate generic units at run time for example inside a loop br br br Example br The specification of a generic package br br Instantiating the generic package br br Using an instance of a generic package br br br Advantages and limits br The language syntax allows precise specification of constraints on generic formal parameters For example it is possible to specify that a generic formal type will only accept a modular type as the actual It is also possible to express constraints between generic formal parameters for example br br In this example Array Type is constrained by both Index Type and Element Type When instantiating the unit the programmer must pass an actual array type that satisfies these constraints br The disadvantage of this fine grained control is a complicated syntax but because all generic formal parameters are completely defined in the specification the compiler can instantiate generics without looking at the body of the generic br Unlike C Ada does not allow specialised generic instances and requires that all generics be instantiated explicitly These rules have several consequences br br the compiler can implement shared generics the object code for a generic unit can be shared between all instances unless the programmer requests inlining of subprograms of course As further consequences br there is no possibility of code bloat code bloat is common in C and requires special care as explained below br it is possible to instantiate generics at run time and at compile time since no new object code is required for a new instance br actual objects corresponding to a generic formal object are always considered to be non static inside the generic see Generic formal objects in the Wikibook for details and consequences br all instances of a generic being exactly the same it is easier to review and understand programs written by others there are no special cases to take into account br all instantiations being explicit there are no hidden instantiations that might make it difficult to understand the program br Ada does not permit arbitrary computation at compile time because operations on generic arguments are performed at runtime br br br Templates in C br br C uses templates to enable generic programming techniques The C Standard Library includes the Standard Template Library or STL that provides a framework of templates for common data structures and algorithms Templates in C may also be used for template metaprogramming which is a way of pre evaluating some of the code at compile time rather than run time Using template specialization C Templates are Turing complete br br br Technical overview br There are many kinds of templates the most common being function templates and class templates A function template is a pattern for creating ordinary functions based upon the parameterizing types supplied when instantiated For example the C Standard Template Library contains the function template max x y that creates functions that return either x or y whichever is larger max could be defined like this br br Specializations of this function template instantiations with specific types can be called just like an ordinary function br br The compiler examines the arguments used to call max and determines that this is a call to max int int It then instantiates a version of the function where the parameterizing type T is int making the equivalent of the following function br br This works whether the arguments x and y are integers strings or any other type for which the expression x y is sensible or more specifically for any type for which operator is defined Common inheritance is not needed for the set of types that can be used and so it is very similar to duck typing A program defining a custom data type can use operator overloading to define the meaning of for that type thus allowing its use with the max function template While this may seem a minor benefit in this isolated example in the context of a comprehensive library like the STL it allows the programmer to get extensive functionality for a new data type just by defining a few operators for it Merely defining allows a type to be used with the standard sort stable sort and binary search algorithms or to be put inside data structures such as sets heaps and associative arrays br C templates are completely type safe at compile time As a demonstration the standard type complex does not define the operator because there is no strict order on complex numbers Therefore max x y will fail with a compile error if x and y are complex values Likewise other templates that rely on cannot be applied to complex data unless a comparison in the form of a functor or function is provided E g A complex cannot be used as key for a map unless a comparison is provided Unfortunately compilers historically generate somewhat esoteric long and unhelpful error messages for this sort of error Ensuring that a certain object adheres to a method protocol can alleviate this issue Languages which use compare instead of can also use complex values as keys br Another kind of template a class template extends the same concept to classes A class template specialization is a class Class templates are often used to make generic containers For example the STL has a linked list container To make a linked list of integers one writes list int A list of strings is denoted list string A list has a set of standard functions associated with it that work for any compatible parameterizing types br br br Template specialization br A powerful feature of C s templates is template specialization This allows alternative implementations to be provided based on certain characteristics of the parameterized type that is being instantiated Template specialization has two purposes to allow certain forms of optimization and to reduce code bloat br For example consider a sort template function One of the primary activities that such a function does is to swap or exchange the values in two of the container s positions If the values are large in terms of the number of bytes it takes to store each of them then it is often quicker to first build a separate list of pointers to the objects sort those pointers and then build the final sorted sequence If the values are quite small however it is usually fastest to just swap the values in place as needed Furthermore if the parameterized type is already of some pointer type then there is no need to build a separate pointer array Template specialization allows the template creator to write different implementations and to specify the characteristics that the parameterized type s must have for each implementation to be used br Unlike function templates class templates can be partially specialized That means that an alternate version of the class template code can be provided when some of the template parameters are known while leaving other template parameters generic This can be used for example to create a default implementation the primary specialization that assumes that copying a parameterizing type is expensive and then create partial specializations for types that are cheap to copy thus increasing overall efficiency Clients of such a class template just use specializations of it without needing to know whether the compiler used the primary specialization or some partial specialization in each case Class templates can also be fully specialized which means that an alternate implementation can be provided when all of the parameterizing types are known br br br Advantages and disadvantages br Some uses of templates such as the max function were previously filled by function like preprocessor macros a legacy of the C language For example here is a possible implementation of such macro br br Macros are expanded copy pasted by the preprocessor before compiling proper templates are actual real functions Macros are always expanded inline templates can also be inline functions when the compiler deems it appropriate br However templates are generally considered an improvement over macros for these purposes Templates are type safe Templates avoid some of the common errors found in code that makes heavy use of function like macros such as evaluating parameters with side effects twice Perhaps most importantly templates were designed to be applicable to much larger problems than macros br There are four primary drawbacks to the use of templates supported features compiler support poor error messages usually with pre C SFINAE and code bloat br br Templates in C lack many features which makes implementing them and using them in a straightforward way often impossible Instead programmers have to rely on complicated tricks which leads to bloated hard to understand and hard to maintain code Current developments in the C standards exacerbate this problem by making heavy use of these tricks and building a lot of new features for templates on them or with them in mind br Many compilers historically had poor support for templates thus the use of templates could have made code somewhat less portable Support may also be poor when a C compiler is being used with a linker that is not C aware or when attempting to use templates across shared library boundaries br Compilers can produce confusing long and sometimes unhelpful error messages when errors are detected in code that uses SFINAE This can make templates difficult to develop with br Finally the use of templates requires the compiler to generate a separate instance of the templated class or function for every type parameters used with it This is necessary because types in C are not all the same size and the sizes of data fields are important to how classes work So the indiscriminate use of templates can lead to code bloat resulting in excessively large executables However judicious use of template specialization and derivation can dramatically reduce such code bloat in some cases So can derivation be used to reduce the problem of code replicated because templates are used This would involve deriving a template from an ordinary class This technique proved successful in curbing code bloat in real use People who do not use a technique like this have found that replicated code can cost megabytes of code space even in moderate size programs br Templated classes or functions may require an explicit specialization of the template class which would require rewriting of an entire class for a specific template parameters used by it br The extra instantiations generated by templates can also cause some debuggers to have difficulty working gracefully with templates For example setting a debug breakpoint within a template from a source file may either miss setting the breakpoint in the actual instantiation desired or may set a breakpoint in every place the template is instantiated br Also the implementation source code for the template must be completely available e g included in a header to the translation unit source file using it Templates including much of the Standard Library if not included in header files cannot be compiled This is in contrast to non templated code which may be compiled to binary providing only a declarations header file for code using it This may be a disadvantage by exposing the implementing code which removes some abstractions and could restrict its use in closed source projects br br br Templates in D br The D language supports templates based in design on C Most C template idioms work in D without alteration but D adds some functionality br br Template parameters in D are not restricted to just types and primitive values as it was in C before C but also allow arbitrary compile time values such as strings and struct literals and aliases to arbitrary identifiers including other templates or template instantiations br Template constraints and the static if statement provide an alternative to respectively C s C concepts and if constexpr br The is expression allows speculative instantiation to verify an object s traits at compile time br The auto keyword and the typeof expression allow type inference for variable declarations and function return values which in turn allows Voldemort types types that do not have a global name br Templates in D use a different syntax than in C whereas in C template parameters are wrapped in angular brackets Template param param br D uses an exclamation sign and parentheses Template param param br This avoids the C parsing difficulties due to ambiguity with comparison operators br If there is only one parameter the parentheses can be omitted br Conventionally D combines the above features to provide compile time polymorphism using trait based generic programming br For example an input range is defined as any type that satisfies the checks performed by isInputRange which is defined as follows br br A function that accepts only input ranges can then use the above template in a template constraint br br br Code generation br In addition to template metaprogramming D also provides several features to enable compile time code generation br br The import expression allows reading a file from disk and using its contents as a string expression br Compile time reflection allows enumerating and inspecting declarations and their members during compiling br User defined attributes allow users to attach arbitrary identifiers to declarations which can then be enumerated using compile time reflection br Compile time function execution CTFE allows a subset of D restricted to safe operations to be interpreted during compiling br String mixins allow evaluating and compiling the contents of a string expression as D code that becomes part of the program br Combining the above allows generating code based on existing declarations br For example D serialization frameworks can enumerate a type s members and generate specialized functions for each serialized type br to perform serialization and deserialization br User defined attributes could further indicate serialization rules br The import expression and compile time function execution also allow efficiently implementing domain specific languages br For example given a function that takes a string containing an HTML template and returns equivalent D source code it is possible to use it in the following way br br br Genericity in Eiffel br Generic classes have been a part of Eiffel since the original method and language design The foundation publications of Eiffel use the term genericity to describe creating and using generic classes br br br Basic unconstrained genericity br Generic classes are declared with their class name and a list of one or more formal generic parameters In the following code class LIST has one formal generic parameter G br br The formal generic parameters are placeholders for arbitrary class names that will be supplied when a declaration of the generic class is made as shown in the two generic derivations below where ACCOUNT and DEPOSIT are other class names ACCOUNT and DEPOSIT are considered actual generic parameters as they provide real class names to substitute for G in actual use br br Within the Eiffel type system although class LIST G is considered a class it is not considered a type However a generic derivation of LIST G such as LIST ACCOUNT is considered a type br br br Constrained genericity br For the list class shown above an actual generic parameter substituting for G can be any other available class To constrain the set of classes from which valid actual generic parameters can be chosen a generic constraint can be specified In the declaration of class SORTED LIST below the generic constraint dictates that any valid actual generic parameter will be a class that inherits from class COMPARABLE The generic constraint ensures that elements of a SORTED LIST can in fact be sorted br br br Generics in Java br br Support for the generics or containers of type T was added to the Java programming language in as part of J SE In Java generics are only checked at compile time for type correctness The generic type information is then removed via a process called type erasure to maintain compatibility with old JVM implementations making it unavailable at runtime For example a List String is converted to the raw type List The compiler inserts type casts to convert the elements to the String type when they are retrieved from the list reducing performance compared to other implementations such as C templates br br br Genericity in NET C VB NET br Generics were added as part of NET Framework in November based on a research prototype from Microsoft Research started in Although similar to generics in Java NET generics do not apply type erasure but implement generics as a first class mechanism in the runtime using reification This design choice provides additional functionality such as allowing reflection with preservation of generic types and alleviating some of the limits of erasure such as being unable to create generic arrays This also means that there is no performance hit from runtime casts and normally expensive boxing conversions When primitive and value types are used as generic arguments they get specialized implementations allowing for efficient generic collections and methods As in C and Java nested generic types such as Dictionary string List int are valid types however are advised against for member signatures in code analysis design rules br NET allows six varieties of generic type constraints using the where keyword including restricting generic types to be value types to be classes to have constructors and to implement interfaces Below is an example with an interface constraint br br The MakeAtLeast method allows operation on arrays with elements of generic type T The method s type constraint indicates that the method is applicable to any type T that implements the generic IComparable T interface This ensures a compile time error if the method is called if the type does not support comparison The interface provides the generic method CompareTo T br The above method could also be written without generic types simply using the non generic Array type However since arrays are contravariant the casting would not be type safe and the compiler would be unable to find certain possible errors that would otherwise be caught when using generic types In addition the method would need to access the array items as objects instead and would require casting to compare two elements For value types like types such as int this requires a boxing conversion although this can be worked around using the Comparer T class as is done in the standard collection classes br A notable behavior of static members in a generic NET class is static member instantiation per run time type see example below br br br Genericity in Delphi br Delphi s Object Pascal dialect acquired generics in the Delphi release initially only with the now discontinued NET compiler before being added to the native code in the Delphi release The semantics and capabilities of Delphi generics are largely modelled on those had by generics in NET though the implementation is by necessity quite different Here s a more or less direct translation of the first C example shown above br br As with C methods and whole types can have one or more type parameters In the example TArray is a generic type defined by the language and MakeAtLeast a generic method The available constraints are very similar to the available constraints in C any value type any class a specific class or interface and a class with a parameterless constructor Multiple constraints act as an additive union br br br Genericity in Free Pascal br Free Pascal implemented generics before Delphi and with different syntax and semantics However since FPC version the Delphi style syntax is available when using the mode Delphi language mode Thus Free Pascal code supports generics in either style br Delphi and Free Pascal example br br br Functional languages br br br Genericity in Haskell br The type class mechanism of Haskell supports generic programming Six of the predefined type classes in Haskell including Eq the types that can be compared for equality and Show the types whose values can be rendered as strings have the special property of supporting derived instances This means that a programmer defining a new type can state that this type is to be an instance of one of these special type classes without providing implementations of the class methods as is usually necessary when declaring class instances All the necessary methods will be derived that is constructed automatically based on the structure of the type For example the following declaration of a type of binary trees states that it is to be an instance of the classes Eq and Show br br This results in an equality function and a string representation function show being automatically defined for any type of the form BinTree T provided that T itself supports those operations br The support for derived instances of Eq and Show makes their methods and show generic in a qualitatively different way from parametrically polymorphic functions these functions more accurately type indexed families of functions can be applied to values of various types and although they behave differently for every argument type little work is needed to add support for a new type Ralf Hinze has shown that a similar effect can be achieved for user defined type classes by certain programming techniques Other researchers have proposed approaches to this and other kinds of genericity in the context of Haskell and extensions to Haskell discussed below br br br PolyP br PolyP was the first generic programming language extension to Haskell In PolyP generic functions are called polytypic The language introduces a special construct in which such polytypic functions can be defined via structural induction over the structure of the pattern functor of a regular datatype Regular datatypes in PolyP are a subset of Haskell datatypes A regular datatype t must be of kind and if a is the formal type argument in the definition then all recursive calls to t must have the form t a These restrictions rule out higher kinded datatypes and nested datatypes where the recursive calls are of a different form br The flatten function in PolyP is here provided as an example br br br Generic Haskell br Generic Haskell is another extension to Haskell developed at Utrecht University in the Netherlands The extensions it provides are br br Type indexed values are defined as a value indexed over the various Haskell type constructors unit primitive types sums products and user defined type constructors In addition we can also specify the behaviour of a type indexed values for a specific constructor using constructor cases and reuse one generic definition in another using default cases br The resulting type indexed value can be specialized to any type br br Kind indexed types are types indexed over kinds defined by giving a case for both and k k Instances are obtained by applying the kind indexed type to a kind br Generic definitions can be used by applying them to a type or kind This is called generic application The result is a type or value depending on which sort of generic definition is applied br Generic abstraction enables generic definitions be defined by abstracting a type parameter of a given kind br Type indexed types are types that are indexed over the type constructors These can be used to give types to more involved generic values The resulting type indexed types can be specialized to any type br As an example the equality function in Generic Haskell br br br Clean br Clean offers generic programming based PolyP and the Generic Haskell as supported by the GHC It parametrizes by kind as those but offers overloading br br br Other languages br Languages in the ML family support generic programming through parametric polymorphism and generic modules called functors Both Standard ML and OCaml provide functors which are similar to class templates and to Ada s generic packages Scheme syntactic abstractions also have a connection to genericity these are in fact a superset of C templates br A Verilog module may take one or more parameters to which their actual values are assigned upon the instantiation of the module One example is a generic register array where the array width is given via a parameter Such an array combined with a generic wire vector can make a generic buffer or memory module with an arbitrary bit width out of a single module implementation br VHDL being derived from Ada also has generic abilities br C supports type generic expressions using the Generic keyword br br br See also br Concept generic programming br Partial evaluation br Template metaprogramming br Type polymorphism br br br br br br Sources br br br Further reading br Gabriel Dos Reis and Jaakko J rvi What is Generic Programming LCSD Archived August at the Wayback Machine br Gibbons Jeremy Backhouse R Gibbons J Hinze R Jeuring J eds Datatype generic programming Spring School on Datatype Generic Programming Lecture Notes in Computer Science Vol Heidelberg Springer pp CiteSeerX br Meyer Bertrand Genericity versus inheritance Conference proceedings on Object oriented programming systems languages and applications OOPSLA pp doi ISBN S CID br br br External links br generic programming org br Alexander A Stepanov Collected Papers of Alexander A Stepanov creator of the STL br C D br Walter Bright Templates Revisited br David Vandevoorde Nicolai M Josuttis C Templates The Complete Guide Addison Wesley ISBN br C NET br Jason Clark Introducing Generics in the Microsoft CLR September MSDN Magazine Microsoft br Jason Clark More on Generics in the Microsoft CLR October MSDN Magazine Microsoft br M Aamir Maniar Generics Net An open source generics library for C br Delphi Object Pascal br Nick Hodges Delphi Reviewers Guide October Embarcadero Developer Network Embarcadero br Craig Stuntz Delphi Generics and Type Constraints October br Dr Bob Delphi Generics br Free Pascal Free Pascal Reference guide Chapter Generics Micha l Van Canneyt br Delphi for Win Generics with Delphi Win S bastien DOERAENE br Delphi for NET Delphi Generics Felix COLIBRI br Eiffel br Eiffel ISO ECMA specification document br Haskell br Johan Jeuring Sean Leather Jos Pedro Magalh es and Alexey Rodriguez Yakushev Libraries for Generic Programming in Haskell Utrecht University br D v Clarke Johan Jeuring and Andres L h The Generic Haskell user s guide br Ralf Hinze Generics for the Masses In Proceedings of the ACM SIGPLAN International Conference on Functional Programming ICFP br Simon Peyton Jones editor The Haskell Language Report Revised br Ralf L mmel and Simon Peyton Jones Scrap Your Boilerplate A Practical Design Pattern for Generic Programming In Proceedings of the ACM SIGPLAN International Workshop on Types in Language Design and Implementation TLDI Also see the website devoted to this research br Andres L h Exploring Generic Haskell PhD thesis Utrecht University ISBN br Generic Haskell a language for generic programming br Java br Gilad Bracha Generics in the Java Programming Language br Maurice Naftalin and Philip Wadler Java Generics and Collections O Reilly Media Inc ISBN br Peter Sestoft Java Precisely Second Edition MIT Press ISBN br Generic Programming in Java Sun Microsystems Inc br Angelika Langer Java Generics FAQs