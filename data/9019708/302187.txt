title: Curry (programming language)
id: 302187
Curry is a declarative programming language an implementation of the functional logic programming paradigm and based on the Haskell language It merges elements of functional and logic programming including constraint programming integration br It is nearly a superset of Haskell but does not support all language extensions of Haskell In contrast to Haskell Curry has built in support for non deterministic computations involving search br br br Foundations of functional logic programming br br br Basic concepts br A functional program is a set of functions defined by equations or rules A functional computation consists of replacing subexpressions by equal with regard to the function definitions subexpressions until no more replacements or reductions are possible and a value or normal form is obtained For instance consider the function double defined by br br double x x x br br The expression double is replaced by The latter can be replaced by if we interpret the operator to be defined by an infinite set of equations e g etc In a similar way one can evaluate nested expressions where the subexpressions to be replaced are quoted br br double br br There is also another order of evaluation if we replace the arguments of operators from right to left br br double br br In this case both derivations lead to the same result a property known as confluence This follows from a fundamental property of pure functional languages termed referential transparency the value of a computed result does not depend on the order or time of evaluation due to the absence of side effects This simplifies reasoning about and maintaining pure functional programs br As many functional languages like Haskell do Curry supports the definition of algebraic data types by enumerating their constructors For instance the type of Boolean values consists of the constructors True and False that are declared as follows br br Functions on Booleans can be defined by pattern matching i e by providing several equations for different argument values br br The principle of replacing equals by equals is still valid provided that the actual arguments have the required form e g br br not not False not True False br br More complex data structures can be obtained by recursive data types For instance a list of elements where the type of elements is arbitrary denoted by br the type variable a is either the empty list or the non empty list x xs consisting of a first element x and a list xs br br The type List a is usually written as a and finite lists x x xn are written as x x xn We can define operations on recursive types by inductive definitions where pattern matching supports the convenient separation of the different cases For instance the concatenation operation on polymorphic lists can be defined as follows the optional type declaration in the first line specifies that takes two lists as input and produces an output list where all list elements are of the same unspecified type br br Beyond its application for various programming tasks the operation is also useful to specify the behavior of other functions on lists For instance the behavior of a function last that yields the last element of a list can be specified as follows for all lists xs and elements e last xs e if ys ys e xs br Based on this specification one can define a function that satisfies this specification by employing logic programming features Similarly to logic languages functional logic languages provide search for solutions for existentially quantified variables In contrast to pure logic languages they support equation solving over nested functional expressions so that an equation like ys e is solved by instantiating ys to the list and e to the value In Curry one can define the operation last as follows br br Here the symbol is used for equational constraints in order to provide a syntactic distinction from defining equations Similarly extra variables i e variables not occurring in the left hand side of the defining equation are explicitly declared by where free in order to provide some opportunities to detect bugs caused by typos A conditional equation of the form l c r is applicable for reduction if its condition c has been solved In contrast to purely functional languages where conditions are only evaluated to a Boolean value functional logic languages support the solving of conditions by guessing values for the unknowns in the condition Narrowing as discussed in the next section is used to solve this kind of conditions br br br Narrowing br Narrowing is a mechanism whereby a variable is bound to a value selected from among alternatives imposed by constraints Each possible value is tried in some order with the remainder of the program invoked in each case to determine the validity of the binding Narrowing is an extension of logic programming in that it performs a similar search but can actually generate values as part of the search rather than just being limited to testing them br Narrowing is useful because it allows a function to be treated as a relation its value can be computed in both directions The Curry examples of the previous section illustrate this br As noted in the prior section narrowing can be thought of as reduction on a program term graph and there are often many different ways strategies to reduce a given term graph Antoy et al proved in the s that a particular narrowing strategy needed narrowing is optimal in the sense of doing a number of reductions to get to a normal form corresponding to a solution that is minimal among sound and complete strategies Needed narrowing corresponds to a lazy strategy in contrast to the SLD resolution strategy of Prolog br br br Functional patterns br The rule defining last shown above expresses the fact that the actual argument must match the result of narrowing the expression ys e Curry can express this property also in the following more concise way br br Haskell does not allow such a declaration since the pattern in the left hand side contains a defined function Such a pattern is also called functional pattern Functional patterns are enabled by the combined functional and logic features of Curry and support concise definitions of tasks requiring deep pattern matching in hierarchical data structures br br br Non determinism br Since Curry is able to solve equations containing function calls with unknown values its execution mechanism is based on non deterministic computations similarly to logic programming This mechanism supports also the definition of non deterministic operations i e operations that delivers more than one result for a given input The archetype of non deterministic operations is the predefined infix operation called choice operator that returns one of its arguments This operator is defined by the following rules br br x y x br x y y br br Thus the evaluation of the expression returns as well as Computing with non deterministic operations and computing with free variables by narrowing has the same expressive power br The rules defining show an important feature of Curry all rules are tried in order to evaluate some operation Hence one can define by br br an operation to insert an element into a list at an indeterminate position so that the operation perm defined by br br returns any permutation of a given input list br br br Strategies br Due to the absence of side effects a functional logic program can be executed with different strategies To evaluate expressions Curry uses a variant of the needed narrowing strategy which combines lazy evaluation with non deterministic search strategies In contrast to Prolog which uses backtracking to search for solutions Curry does not fix a particular search strategy Hence there are implementations of Curry like KiCS where the user can easily select a search strategy like depth first search backtracking breadth first search iterative deepening or parallel search br br br br br br External links br Official website br Smap A web based execution environment for Curry and Haskell with various example programs br Curry packages A collection of software packages for Curry br MCC The M nster Curry Compiler targets C br PAKCS A major Curry implementation targets Prolog br KiCS A Curry implementation targets Haskell br Curry Go A Curry implementation targets Go and supports fair parallel search br Curry Mailing List br Michael Hanus s home page br Purely Functional Lazy Non deterministic Programming Fischer Kiselyov Shan Transforming Functional Logic Programs into Monadic Functional Programs Bra el Fischer Hanus Reck on modeling lazy non deterministic logic programming like in Curry in a purely functional language Haskell such approach might give the programmer more flexibility in the control over the strategies that in the case of Curry are built in 