title: RTLinux
id: 419232
RTLinux is a hard realtime real time operating system RTOS microkernel that runs the entire Linux operating system as a fully preemptive process The hard real time property makes it possible to control robots data acquisition systems manufacturing plants and other time sensitive instruments and machines from RTLinux applications The design was patented Despite the similar name it is not related to the Real Time Linux project of the Linux Foundation br RTLinux was developed by Victor Yodaiken Michael Barabanov Cort Dougan and others at the New Mexico Institute of Mining and Technology and then as a commercial product at FSMLabs Wind River Systems acquired FSMLabs embedded technology in February and made a version available as Wind River Real Time Core for Wind River Linux As of August Wind River has discontinued the Wind River Real Time Core product line effectively ending commercial support for the RTLinux product br br br Background br The key RTLinux design objective was to add hard real time capabilities to a commodity operating system to facilitate the development of complex control programs with both capabilities For example one might want to develop a real time motor controller that used a commodity database and exported a web operator interface Instead of attempting to build a single operating system that could support real time and non real time capabilities RTLinux was designed to share a computing device between a real time and non real time operating system so that the real time operating system could never be blocked from execution by the non real time operating system and components running in the two different environments could easily share data As the name implies RTLinux was originally designed to use Linux as the non real time system but it eventually evolved so that the RTCore real time kernel could run with either Linux or Berkeley Software Distribution BSD Unix br Multi Environment Real Time MERT was the first example of a real time operating system coexisting with a Unix system MERT relied on traditional virtualization techniques the real time kernel was the host operating system or hypervisor and Bell Systems Unix was the guest RTLinux was an attempt to update the MERT concept to the PC era and commodity hardware It was also an attempt to also overcome the performance limits of MERT particularly the overhead introduced by virtualization br Instead of encapsulating the guest OS in a virtual machine RTLinux virtualized only the guest interrupt control This method allowed the real time kernel to convert the guest operating system into a system that was completely preemptible but that could still directly control for example storage devices In particular standard drivers for the guest worked without source modification although they needed to be recompiled to use the virtualization hooks See also paravirtualization The Unix pipe was adapted to permit real time and non real time programs to communicate although other methods such as shared memory were also added br From the programmer s point of view RTLinux originally looked like a small threaded environment for real time tasks plus the standard Linux environment for everything else The real time operating system was implemented as a loadable kernel module which began by virtualizing guest interrupt control and then started a real time scheduler Tasks were assigned static priorities and scheduling was originally purely priority driven The guest operating system was incorporated as the lowest priority task and essentially acted as the idle task for the real time system Real time tasks ran in kernel mode Later development of RTLinux adopted the Portable Operating System Interface POSIX POSIX threads application programming interface API and then permitted creation of threads in user mode with real time threads running inside guest processes In multiprocessor environments threads were locked to processor cores and it was possible to prevent the guest thread from running on designated core effectively reserving cores for only real time processing br br br Implementation br RTLinux provides the ability to run special real time tasks and interrupt handlers on the same machine as standard Linux These tasks and handlers execute when they need to execute no matter what Linux is doing The worst case time between the moment a hardware interrupt is detected by the processor and the moment an interrupt handler starts to execute is under microseconds on RTLinux running on a generic x circa A RTLinux periodic task runs within microseconds of its scheduled time on the same hardware These times are hardware limited and as hardware improves RTLinux will also improve Standard Linux has excellent average performance and can even provide millisecond level scheduling precision for tasks using the POSIX soft real time capabilities Standard Linux is not however designed to provide sub millisecond precision and reliable timing guarantees RTLinux was based on a lightweight virtual machine where the Linux guest was given a virtualized interrupt controller and timer and all other hardware access was direct From the point of view of the real time host the Linux kernel is a thread Interrupts needed for deterministic processing are processed by the real time core while other interrupts are forwarded to Linux which runs at a lower priority than real time threads Linux drivers handled almost all I O First In First Out pipes FIFO or shared memory can be used to share data between the operating system and RTLinux br br br Objective br The key RTLinux design objective is that the system should be transparent modular and extensible Transparency means that there are no unopenable black boxes and the cost of any operation should be determinable Modularity means that it is possible to omit functionality and the expense of that functionality if it is not needed And extensibility means that programmers should be able to add modules and tailor the system to their requirements The base RTLinux system supports high speed interrupt handling and no more It has simple priority scheduler that can be easily replaced by schedulers more suited to the needs of some specific application When developing RTLinux it was designed to maximize the advantage we get from having Linux and its powerful capabilities available br br br Core components br RTLinux is structured as a small core component and a set of optional components The core component permits installation of very low latency interrupt handlers that cannot be delayed or preempted by Linux itself and some low level synchronization and interrupt control routines This core component has been extended to support SMP and at the same time it has been simplified by removing some functionality that can be provided outside the core br br br Functions br Most RTLinux functions are in a set of loadable kernel modules that provide optional services and levels of abstraction These modules include br br rtl sched a priority scheduler that supports both a lite POSIX interface described below and the original V RTLinux API br rtl time which controls the processor clocks and exports an abstract interface for connecting handlers to clocks br rtl posixio supports POSIX style read write open interface to device drivers br rtl fifo connects RT tasks and interrupt handlers to Linux processes through a device layer so that Linux processes can read write to RT components br semaphore a contributed package by Jerry Epplin which gives RT tasks blocking semaphores br POSIX mutex support is planned to be available in the next minor version update of RTLinux br mbuff is a contributed package written by Tomasz Motylewski for providing shared memory between RT components and Linux processes br br br Realtime tasks br RTLinux realtime tasks get implemented as kernel modules similar to the type of module that Linux uses for drivers file systems and so on Realtime tasks have direct access to the hardware and do not use virtual memory On initialization a realtime task module informs the RTLinux kernel of its deadline period and release time constraints br br br Threads br RT Linux implements a POSIX API for a thread s manipulation A thread is created by calling the pthread create function The third parameter of pthread create is a function which contains the code executed by the thread br It is necessary to set thread priorities in RTLinux Threads with higher priorities can preempt threads with lower priorities For example we can have a thread controlling a stepper motor In order to move the motor fluently it is necessary to start this thread in strictly regular intervals This can be guaranteed by assigning a high priority to this thread The example threads c sets different thread priorities Setting of thread priority is done by code shown below br br The output the program is as follows br br Thread started br Thread started br Thread started br Message this is thread br Message this is thread br Message this is thread br Message this is thread br Message this is thread br Message this is thread br Message this is thread br Message this is thread br Message this is thread br br The thread has the highest priority and the thread has the lowest priority The first message is printed by the middle priority thread because it is started a short time before the thread br br br See also br br RTAI RTAI began as a variant of RTLinux called MyRTlinux and in later releases was claimed by its authors not to use the patented RTLinux virtualization technique br RMX operating system br SCHED DEADLINE br Xenomai br Preemption computing br Linux on embedded systems br Real time testing br br br br br br Sources br br br External links br Article about RTLinux synchronization br A Real Time Linux Archived at the Wayback Machine Victor Yodaiken and Michael Barabanov New Mexico Institute of Technology br Article about RT concept at archive today archived 