title: Micro-Controller Operating Systems
id: 1350138
Micro Controller Operating Systems MicroC OS stylized as C OS or Micrium OS is a real time operating system RTOS designed by Jean J Labrosse in It is a priority based preemptive real time kernel for microprocessors written mostly in the programming language C It is intended for use in embedded systems br MicroC OS allows defining several functions in C each of which can execute as an independent thread or task Each task runs at a different priority and runs as if it owns the central processing unit CPU Lower priority tasks can be preempted by higher priority tasks at any time Higher priority tasks use operating system OS services such as a delay or event to allow lower priority tasks to execute OS services are provided for managing tasks and memory communicating between tasks and timing br br br History br The MicroC OS kernel was published originally in a three part article in Embedded Systems Programming magazine and the book C OS The Real Time Kernel by Labrosse He intended at first to simply describe the internals of a portable OS he had developed for his own use but later developed it as a commercial product in his own company Micrium Inc in versions II and III br In Micrium Inc was acquired by Silicon Laboratories and it was subsequently released as open source under the Apache license br Silicon Labs continues to maintain an open source product named Micrium OS for use on their own silicon and a group of former Micrium Inc employees including Labrosse provides consultancy and support for both C OS and Cesium RTOS a proprietary fork made just after the open source release br br br C OS II br Based on the source code written for C OS and introduced as a commercial product in C OS II is a portable ROM able scalable preemptive real time deterministic multitasking kernel for microprocessors and digital signal processors DSPs It manages up to tasks Its size can be scaled between and Kbytes to only contain the features needed for a given use br Most of C OS II is written in highly portable ANSI C with target microprocessor specific code written in assembly language Use of the latter is minimized to ease porting to other processors br br br Uses in embedded systems br C OS II was designed for embedded uses If the producer has the proper toolchain i e C compiler assembler and linker locator C OS II can be embedded as part of a product br C OS II is used in many embedded systems including br br Avionics br Medical equipment and devices br Data communications equipment br White goods appliances br Mobile phones personal digital assistants PDAs MIDs br Industrial controls br Consumer electronics br Automotive br br br Task states br C OS II is a multitasking operating system Each task is an infinite loop and can be in any one of the following five states see figure below additionally br br Dormant br Ready br Running br Waiting for an event br Interrupted interrupt service routine ISR br Further it can manage up to tasks However it is recommended that eight of these tasks be reserved for C OS II leaving an application up to tasks br br br Kernels br The kernel is the name given to the program that does most of the housekeeping tasks for the operating system The boot loader hands control over to the kernel which initializes the various devices to a known state and makes the computer ready for general operations The kernel is responsible for managing tasks i e for managing the CPU s time and communicating between tasks The fundamental service provided by the kernel is context switching br The scheduler is the part of the kernel responsible for determining which task runs next Most real time kernels are priority based In a priority based kernel control of the CPU is always given to the highest priority task ready to run Two types of priority based kernels exist non preemptive and preemptive Nonpreemptive kernels require that each task do something to explicitly give up control of the CPU A preemptive kernel is used when system responsiveness is more important Thus C OS II and most commercial real time kernels are preemptive The highest priority task ready to run is always given control of the CPU br br br Assigning tasks br Tasks with the highest rate of execution are given the highest priority using rate monotonic scheduling This scheduling algorithm is used in real time operating systems RTOS with a static priority scheduling class br br br Managing tasks br In computing a task is a unit of execution In some operating systems a task is synonymous with a process in others with a thread In batch processing computer systems a task is a unit of execution within a job br The system user of C OS II is able to control the tasks by using the following features br br Task feature br Task creation br Task stack stack checking br Task deletion br Change a task s priority br Suspend and resume a task br Get information about a task br br br Managing memory br To avoid fragmentation C OS II allows applications to obtain fixed sized memory blocks from a partition made of a contiguous memory area All memory blocks are the same size and the partition contains an integral number of blocks Allocation and deallocation of these memory blocks is done in constant time and is a deterministic system br br br Managing time br C OS II requires that a periodic time source be provided to keep track of time delays and timeouts A tick should occur between and times per second or Hertz The faster the tick rate the more overhead C OS II imposes on the system The frequency of the clock tick depends on the desired tick resolution of an application Tick sources can be obtained by dedicating a hardware timer or by generating an interrupt from an alternating current AC power line or Hz signal This periodic time source is termed a clock tick br After a clock tick is determined tasks can be br br Delaying a task br Resume a delayed task br br br Communicating between tasks br Intertask or interprocess communication in C OS II occurs via semaphores message mailbox message queues tasks and interrupt service routines ISRs They can interact with each other when a task or an ISR signals a task through a kernel object called an event control block ECB The signal is considered to be an event br br br C OS III br C OS III is the acronym for Micro Controller Operating Systems Version introduced in and adding functionality to the C OS II RTOS br C OS III offers all of the features and functions of C OS II The biggest difference is the number of supported tasks C OS II allows only task at each of priority levels for a maximum of tasks C OS III allows any number of application tasks priority levels and tasks per level limited only by processor access to memory br C OS II and C OS III are currently maintained by Micrium Inc a subsidiary of Silicon Labs and can be licensed per product or per product line br br br Uses in embedded systems br The uses are the same as for C OS II br br br Task states br C OS III is a multitasking operating system Each task is an infinite loop and can be in any one of five states dormant ready running interrupted or pending Task priorities can range from highest priority to a maximum of lowest possible priority br br br Round robin scheduling br When two or more tasks have the same priority the kernel allows one task to run for a predetermined amount of time named a quantum and then selects another task This process is termed round robin scheduling or time slicing The kernel gives control to the next task in line if br br The current task has no work to do during its time slice or br The current task completes before the end of its time slice or br The time slice ends br br br Kernels br The kernel functionality for C OS III is the same as for C OS II br br br Managing tasks br Task management also functions the same as for C OS II However C OS III supports multitasking and allows an application to have any number of tasks The maximum number of tasks is limited by only the amount of computer memory both code and data space available to the processor br A task can be implemented viarunning to scheduled completion in which the task deletes itself when it is finished or more typically as an infinite loop waiting for events to occur and processing those events br br br Managing memory br Memory management is performed in the same way as in C OS II br br br Managing time br C OS III offers the same time managing features as C OS II It also provides services to applications so that tasks can suspend their execution for user defined time delays Delays are specified by a number of either clock ticks or hours minutes seconds and milliseconds br br br Communicating between tasks br Sometimes a task or ISR must communicate information to another task because it is unsafe for two tasks to access the same specific data or hardware resource at once This can be resolved via an information transfer termed inter task communication Information can be communicated between tasks in two ways through global data or by sending messages br When using global variables each task or ISR must ensure that it has exclusive access to variables If an ISR is involved the only way to ensure exclusive access to common variables is to disable interrupts If two tasks share data each can gain exclusive access to variables by either disabling interrupts locking the scheduler using a semaphore or preferably using a mutual exclusion semaphore Messages can be sent to either an intermediate object called a message queue or directly to a task since in C OS III each task has its own built in message queue Use an external message queue if multiple tasks are to wait for messages Send a message directly to a task if only one task will process the data received While a task waits for a message to arrive it uses no CPU time br br br Ports br A port involves three aspects CPU OS and board specific BSP code C OS II and C OS III have ports for most popular processors and boards in the market and are suitable for use in safety critical embedded systems such as aviation medical systems and nuclear installations A C OS III port involves writing or changing the contents of three kernel specific files OS CPU H OS CPU A ASM and OS CPU C C Finally create or change a board support package BSP for the evaluation board or target board being used A C OS III port is similar to a C OS II port There are significantly more ports than listed here and ports are subject to continuous development Both C OS II and C OS III are supported by popular SSL TLS libraries such as wolfSSL which ensure security across all connections br br br Licensing change br After acquisition by Silicon Labs Micrium in changed to open source model licensing in February This includes uC OS III all prior versions all components USB file system GUI TCP IP etc br br br Documentation and support br Support is available via a typical support forum and several comprehensive books several tailored to a given microcontroller architecture and development platform as free PDFs or as low cost purchase in hard cover Paid support is available from Micrium and other parties br br br br br br Sources br Protocol Support for C OS II from Fusion Embedded br Micrium uCOS III UsersManual st Edition br uC OS III The Real Time Kernel for the Renesas RX N br br br External links br Official website br SiliconLabs on GitHub br Summary of Commonly Used uC OS II Functions and Data Structures br NiosII GCC with MicroC OS br C OS II Reference Manual br How to Get a C OS II Application Running