title: UTF-8
id: 32188
UTF is a variable length character encoding standard used for electronic communication Defined by the Unicode Standard the name is derived from Unicode Transformation Format bit br UTF is capable of encoding all valid Unicode code points using one to four one byte bit code units Code points with lower numerical values which tend to occur more frequently are encoded using fewer bytes It was designed for backward compatibility with ASCII the first characters of Unicode which correspond one to one with ASCII are encoded using a single byte with the same binary value as ASCII so that valid ASCII text is valid UTF encoded Unicode as well br UTF was designed as a superior alternative to UTF a proposed variable length encoding with partial ASCII compatibility which lacked some features including self synchronization and fully ASCII compatible handling of characters such as slashes Ken Thompson and Rob Pike produced the first implementation for the Plan operating system in September This led to its adoption by X Open as its specification for FSS UTF which would first be officially presented at USENIX in January and subsequently adopted by the Internet Engineering Task Force IETF in RFC BCP for future internet standards work replacing Single Byte Character Sets such as Latin in older RFCs br UTF results in fewer internationalization issues than any alternative text encoding and it has been implemented in all modern operating systems including Microsoft Windows and standards such as JSON where as is increasingly the case it is the only allowed form of Unicode br UTF is the dominant encoding for the World Wide Web and internet technologies accounting for of all web pages of the top pages and up to for many languages as of Virtually all countries and languages have or more use of UTF encodings on the web br br br Naming br The official name for the encoding is UTF the spelling used in all Unicode Consortium documents Most standards officially list it in upper case as well but all that do are also case insensitive and utf is often used in code br Some other spellings may also be accepted by standards e g web standards which include CSS HTML XML and HTTP headers explicitly allow utf and disallow unicode and many aliases for encodings Spellings with a space e g UTF should not be used The official Internet Assigned Numbers Authority also lists csUTF as the only alias which is rarely used br In Windows UTF is codepage i e CP UTF in source code br In MySQL UTF is called utf mb with utf mb and its alias utf being a subset encoding for characters in the Basic Multilingual Plane br In HP PCL the Symbol ID for UTF is N br In Oracle Database since version AL UTF means UTF See also CESU for an almost synonym with UTF that rarely should be used br UTF BOM and UTF NOBOM are sometimes used for text files which contain or do not contain a byte order mark BOM respectively In Japan especially UTF encoding without a BOM is sometimes called UTF N br br br Encoding br UTF encodes code points in one to four bytes depending on the value of the code point In the following table the x characters are replaced by the bits of the code point br br The first code points ASCII need byte The next code points need two bytes to encode which covers the remainder of almost all Latin script alphabets and also IPA extensions Greek Cyrillic Coptic Armenian Hebrew Arabic Syriac Thaana and N Ko alphabets as well as Combining Diacritical Marks Three bytes are needed for the remaining codepoints of the Basic Multilingual Plane BMP including most Chinese Japanese and Korean characters Four bytes are needed for the codepoints in the other planes of Unicode which include emoji pictographic symbols less common CJK characters various historic scripts and mathematical symbols br A whole graphic character can take more than bytes because it is made of more than one code point For instance a national flag character takes bytes since it is constructed from a pair of Unicode scalar values both from outside the BMP br br br Examples br In the following examples red green and blue digits indicate how bits from the code point are distributed among the UTF bytes Additional bits added by the UTF encoding process are shown in black br The Unicode code point for the euro sign is U AC br As this code point lies between U and U FFFF this will take three bytes to encode br Hexadecimal AC is binary The two leading zeros are added because a three byte encoding needs exactly sixteen bits from the code point br Because the encoding will be three bytes long its leading byte starts with three s then a br The four most significant bits of the code point are stored in the remaining low order four bits of this byte leaving bits of the code point yet to be encoded br All continuation bytes contain exactly six bits from the code point So the next six bits of the code point are stored in the low order six bits of the next byte and is stored in the high order two bits to mark it as a continuation byte so br Finally the last six bits of the code point are stored in the low order six bits of the final byte and again is stored in the high order two bits br The three bytes can be more concisely written in hexadecimal as E AC br The following table summarizes this conversion as well as others with different lengths in UTF br br The Vietnamese phrase M nh n i ti ng Vi t I speak Vietnamese is encoded as follows br br br Codepage layout br The following table summarizes usage of UTF code units individual bytes or octets in a code page format The upper half is for bytes used only in single byte codes so it looks like a normal code page the lower half is for continuation bytes and leading bytes and is explained further in the legend below br br br Overlong encodings br In principle it would be possible to inflate the number of bytes in an encoding by padding the code point with leading s To encode the euro sign from the above example in four bytes instead of three it could be padded with leading s until it was bits long br and encoded as or F AC in hexadecimal This is called an overlong encoding br The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point Longer encodings are called overlong and are not valid UTF representations of the code point This rule maintains a one to one correspondence between code points and their valid encodings so that there is a unique valid encoding for each code point This ensures that string comparisons and searches are well defined br br br Invalid sequences and error handling br Not all sequences of bytes are valid UTF A UTF decoder should be prepared for br br invalid bytes br an unexpected continuation byte br a non continuation byte before the end of the character br the string ending before the end of the character which can happen in simple string truncation br an overlong encoding br a sequence that decodes to an invalid code point br Many of the first UTF decoders would decode these ignoring incorrect bits and accepting overlong results Carefully crafted invalid UTF could make them either skip or create ASCII characters such as NUL slash or quotes Invalid UTF has been used to bypass security validations in high profile products including Microsoft s IIS web server br and Apache s Tomcat servlet container br RFC states Implementations of the decoding algorithm MUST protect against decoding invalid sequences The Unicode Standard requires decoders to br br treat any ill formed code unit sequence as an error condition This guarantees that it will neither interpret nor emit an ill formed code unit sequence br Since RFC November the high and low surrogate halves used by UTF U D through U DFFF and code points not encodable by UTF those after U FFFF are not legal Unicode values and their UTF encoding must be treated as an invalid byte sequence Not decoding unpaired surrogate halves makes it impossible to store invalid UTF such as Windows filenames or UTF that has been split between the surrogates as UTF br while it is possible with WTF br Some implementations of decoders throw exceptions on errors br This has the disadvantage that it can turn what would otherwise be harmless errors such as a no such file error into a denial of service For instance early versions of Python would exit immediately if the command line or environment variables contained invalid UTF br Since Unicode October br the standard chapter has recommended a best practice where the error is either one byte long or ends before the first byte that is disallowed In these decoders E A C is two errors bytes in the first one This means an error is no more than three bytes long and never contains the start of a valid character and there are different possible errors br The standard also recommends replacing each error with the replacement character U FFFD br These recommendations are not often followed It is common to consider each byte to be an error in which case E A C is three errors each byte long This means there are only different errors and it is also common to replace them with different characters to make the decoding lossless br br br Byte order mark br If the Unicode byte order mark BOM U FEFF technically the U FEFF ZERO WIDTH NO BREAK SPACE character is at the start of a UTF file the first three bytes will be xEF xBB xBF br The Unicode Standard neither requires nor recommends the use of the BOM for UTF but warns that it may be encountered at the start of a file trans coded from another encoding While ASCII text encoded using UTF is backward compatible with ASCII this is not true when Unicode Standard recommendations are ignored and a BOM is added A BOM can confuse software that isn t prepared for it but can otherwise accept UTF e g programming languages that permit non ASCII bytes in string literals but not at the start of the file Nevertheless there was and still is software that always inserts a BOM when writing UTF and refuses to correctly interpret UTF unless the first character is a BOM or the file only contains ASCII br br br Adoption br br UTF has been the most common encoding for the World Wide Web since As of May UTF is used by of surveyed web sites br Although many pages only use ASCII characters to display content very few websites now declare their encoding to only be ASCII instead of UTF br Over of the languages tracked have UTF use br Many standards only support UTF e g JSON exchange requires it without a byte order mark BOM br UTF is also the recommendation from the WHATWG for HTML and DOM specifications and stating UTF encoding is the most appropriate encoding for interchange of Unicode br and the Internet Mail Consortium recommends that all e mail programs be able to display and create mail using UTF br The World Wide Web Consortium recommends UTF as the default encoding in XML and HTML and not just using UTF also declaring it in metadata even when all characters are in the ASCII range Using non UTF encodings can have unexpected results br Lots of software has the ability to read write UTF It may though require the user to change options from the normal settings or may require a BOM byte order mark as the first character to read the file Examples of software supporting UTF include Microsoft Word br Microsoft Excel and later br Google Drive LibreOffice and most databases br However for local text files UTF usage is less prevalent where legacy single byte and a few CJK multi byte encodings remain in use The primary cause for this are outdated text editors that refuse to read UTF unless the first bytes of the file encode a byte order mark BOM br Some software can only read and write UTF or at least does not require a BOM br Windows Notepad in all currently supported versions of Windows defaults to writing UTF without a BOM a change from the outdated unsupported Windows Notepad bringing it into line with most other text editors br Some system files on Windows require UTF with no requirement for a BOM and almost all files on macOS and Linux are required to be UTF without a BOM Java defaults to reading and writing files as UTF br and in older versions e g LTS versions only the NIO API was changed to do so Many other programming languages default to UTF for I O including Ruby br and R br All current versions of Python support UTF for I O even on Windows where it is opt in for the open function and plans exist to make UTF I O the default in Python on all platforms br C adopts UTF as the only portable source code file format surprisingly there was none before br Usage of UTF in memory is much lower than in other areas UTF is often used instead This occurs particularly in Windows but also in JavaScript Python br Qt and many other cross platform software libraries Compatibility with the Windows API is the primary reason for this that choice was initially done due to the belief that direct indexing of the BMP would improve speed Translating from to external text which is in UTF slows software down and more importantly introduces bugs when different pieces of code do not do the exact same translation br Back compatibility is a serious impediment to changing code to use UTF instead of a bit encoding but this is happening The default string primitive in Go br Julia Rust Swift br and PyPy br uses UTF internally in all cases Python uses UTF internally for Python C API extensions and sometimes for strings br and a future version of Python is planned to store strings as UTF by default Modern versions of Microsoft Visual Studio use UTF internally br Microsoft s SQL Server added support for UTF and using it results in a speed increase and nearly reduction in storage requirements br All currently supported Windows versions support UTF in some way including Xbox partial support has existed since at least Windows XP As of May Microsoft has reversed its previous position of only recommending UTF the capability to set UTF as the code page for the Windows API was introduced and Microsoft recommends programmers use UTF and even states UTF is a unique burden that Windows places on code that targets multiple platforms br br br History br br The International Organization for Standardization ISO set out to compose a universal multi byte character set in The draft ISO standard contained a non required annex called UTF that provided a byte stream encoding of its bit code points This encoding was not satisfactory on performance grounds among other problems and the biggest problem was probably that it did not have a clear separation between ASCII and non ASCII new UTF tools would be backward compatible with ASCII encoded text but UTF encoded text could confuse existing code expecting ASCII or extended ASCII because it could contain continuation bytes in the range x x E that meant something else in ASCII e g x F for the Unix path directory separator and this example is reflected in the name and introductory text of its replacement The table below was derived from a textual description in the annex br br In July the X Open committee XoJIG was looking for a better encoding Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that bit ASCII characters would only represent themselves all multi byte sequences would include only bytes where the high bit was set The name File System Safe UCS Transformation Format FSS UTF and most of the text of this proposal were later preserved in the final specification br br br FSS UTF br br In August this proposal was circulated by an IBM X Open representative to interested parties A modification by Ken Thompson of the Plan operating system group at Bell Labs made it self synchronizing letting a reader start anywhere and immediately detect character boundaries at the cost of being somewhat less bit efficient than the previous proposal It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed the additional loss in compactness is relatively insignificant but readers now have to look out for invalid encodings to avoid reliability and especially security issues Thompson s design was outlined on September on a placemat in a New Jersey diner with Rob Pike In the following days Pike and Thompson implemented it and updated Plan to use it throughout and then communicated their success back to X Open which accepted it as the specification for FSS UTF br br UTF was first officially presented at the USENIX conference in San Diego from January to The Internet Engineering Task Force adopted UTF in its Policy on Character Sets and Languages in RFC BCP for future internet standards work in January replacing Single Byte Character Sets such as Latin in older RFCs br In November UTF was restricted by RFC to match the constraints of the UTF character encoding explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than of the three byte sequences and ending at U FFFF removed more than of the four byte sequences and all five and six byte sequences br br br Standards br There are several current definitions of UTF in various standards documents br br RFC STD which establishes UTF as a standard internet protocol element br RFC defines UTF NFC for Network Interchange br ISO IEC br The Unicode Standard Version br They supersede the definitions given in the following obsolete works br br The Unicode Standard Version Appendix A br ISO IEC Amendment Annex R br RFC br RFC br The Unicode Standard Version plus Corrigendum UTF Shortest Form br Unicode Standard Annex Unicode br The Unicode Standard Version br The Unicode Standard Version br They are all the same in their general mechanics with the main differences being on issues such as allowed range of code point values and safe handling of invalid input br br br Comparison with other encodings br br Some of the important features of this encoding are as follows br br Backward compatibility Backward compatibility with ASCII and the enormous amount of software designed to process ASCII encoded text was the main driving force behind the design of UTF In UTF single bytes with values in the range of to map directly to Unicode code points in the ASCII range Single bytes in this range represent characters as they do in ASCII Moreover bit bytes bytes where the most significant bit is never appear in a multi byte sequence and no valid multi byte sequence decodes to an ASCII code point A sequence of bit bytes is both valid ASCII and valid UTF and under either interpretation represents the same sequence of characters Therefore the bit bytes in a UTF stream represent all and only the ASCII characters in the stream Thus many text processors parsers protocols file formats text display programs etc which use ASCII characters for formatting and control purposes will continue to work as intended by treating the UTF byte stream as a sequence of single byte characters without decoding the multi byte sequences ASCII characters on which the processing turns such as punctuation whitespace and control characters will never be encoded as multi byte sequences It is therefore safe for such processors to simply ignore or pass through the multi byte sequences without decoding them For example ASCII whitespace may be used to tokenize a UTF stream into words ASCII line feeds may be used to split a UTF stream into lines and ASCII NUL characters can be used to split UTF encoded data into null terminated strings Similarly many format strings used by library functions like printf will correctly handle UTF encoded input arguments br Fallback and auto detection Only a small subset of possible byte strings are a valid UTF string several bytes cannot appear a byte with the high bit set cannot be alone and further requirements mean that it is extremely unlikely that a readable text in any extended ASCII is valid UTF Part of the popularity of UTF is due to it providing a form of backward compatibility for these as well A UTF processor which erroneously receives extended ASCII as input can thus auto detect this with very high reliability A UTF stream may simply contain errors resulting in the auto detection scheme producing false positives but auto detection is successful in the vast majority of cases especially with longer texts and is widely used It also works to fall back or replace bit bytes using the appropriate code point for a legacy encoding when errors in the UTF are detected allowing recovery even if UTF and legacy encoding is concatenated in the same file br Prefix code The first byte indicates the number of bytes in the sequence Reading from a stream can instantaneously decode each individual fully received sequence without first having to wait for either the first byte of a next sequence or an end of stream indication The length of multi byte sequences is easily determined by humans as it is simply the number of high order s in the leading byte An incorrect character will not be decoded if a stream ends mid sequence br Self synchronization The leading bytes and the continuation bytes do not share values continuation bytes start with the bits while single bytes start with and longer lead bytes start with This means a search will not accidentally find the sequence for one character starting in the middle of another character It also means the start of a character can be found from a random position by backing up at most bytes to find the leading byte An incorrect character will not be decoded if a stream starts mid sequence and a shorter sequence will never appear inside a longer one br Sorting order The chosen values of the leading bytes means that a list of UTF strings can be sorted in code point order by sorting the corresponding byte sequences br br br Single byte br UTF can encode any Unicode character avoiding the need to figure out and set a code page or otherwise indicate what character set is in use and allowing output in multiple scripts at the same time For many scripts there have been more than one single byte encoding in usage so even knowing the script was insufficient information to display it correctly br The bytes xFE and xFF do not appear so a valid UTF stream never matches the UTF byte order mark BOM and thus cannot be confused with it The absence of xFF also eliminates the need to escape this byte in Telnet and FTP control connection br UTF encoded text is larger than specialized single byte encodings except for plain ASCII characters In the case of scripts which used bit character sets with non Latin characters encoded in the upper half such as most Cyrillic and Greek alphabet code pages characters in UTF will be double the size For some scripts such as Thai and Devanagari which is used by various South Asian languages characters will triple in size There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF This has caused objections in India and other countries br It is possible in UTF or any other multi byte encoding to split or truncate a string in the middle of a character If the two pieces are not re appended later before interpretation as characters this can introduce an invalid sequence at both the end of the previous section and the start of the next and some decoders will not preserve these bytes and result in data loss Because UTF is self synchronizing this will however never introduce a different valid character and it is also fairly easy to move the truncation point backward to the start of a character br If the code points are all the same size measurements of a fixed number of them is easy Due to ASCII era documentation where character is used as a synonym for byte this is often considered important However by measuring string positions using bytes instead of characters most algorithms can be easily and efficiently adapted for UTF Searching for a string within a long string can for example be done byte by byte the self synchronization property prevents false positives br br br Other multi byte br UTF can encode any Unicode character Files in different scripts can be displayed correctly without having to choose the correct code page or font For instance Chinese and Arabic can be written in the same file without specialized markup or manual settings that specify an encoding br UTF is self synchronizing character boundaries are easily identified by scanning for well defined bit patterns in either direction If bytes are lost due to error or corruption one can always locate the next valid character and resume processing If there is a need to shorten a string to fit a specified field the previous valid character can easily be found Many multi byte encodings such as Shift JIS are much harder to resynchronize This also means that byte oriented string searching algorithms can be used with UTF as a character is the same as a word made up of that many bytes optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only entries Self synchronization does however require that bits be reserved for these markers in every byte increasing the size br Efficient to encode using simple bitwise operations UTF does not require slower mathematical operations such as multiplication or division unlike Shift JIS GB and other encodings br UTF will take more space than a multi byte encoding designed for a specific script East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF br br br UTF br br Byte encodings and UTF are represented by byte arrays in programs and often nothing needs to be done to a function when converting source code from a byte encoding to UTF UTF is represented by bit word arrays and converting to UTF while maintaining compatibility with existing ASCII based programs such as was done with Windows requires every API and data structure that takes a string to be duplicated one version accepting byte strings and another version accepting UTF If backward compatibility is not needed all string handling still must be modified br Text encoded in UTF will be smaller than the same text encoded in UTF if there are more code points below U than in the range U U FFFF This is true for all modern European languages It is often true even for languages like Chinese due to the large number of spaces newlines digits and HTML markup in typical files br Most communication e g HTML and IP and storage e g for Unix was designed for a stream of bytes A UTF string must use a pair of bytes for each code unit br The order of those two bytes becomes an issue and must be specified in the UTF protocol such as with a byte order mark BOM br If an odd number of bytes is missing from UTF the whole rest of the string will be meaningless text Any bytes missing from UTF will still allow the text to be recovered accurately starting with the next character after the missing bytes br br br Derivatives br The following implementations show slight differences from the UTF specification They are incompatible with the UTF specification and may be rejected by conforming UTF applications br br br CESU br br Unicode Technical Report assigns the name CESU to a nonstandard variant of UTF in which Unicode characters in supplementary planes are encoded using six bytes rather than the four bytes required by UTF CESU encoding treats each half of a four byte UTF surrogate pair as a two byte UCS character yielding two three byte UTF characters which together represent the original supplementary character Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF The Report was written to acknowledge and formalize the existence of data encoded as CESU despite the Unicode Consortium discouraging its use and notes that a possible intentional reason for CESU encoding is preservation of UTF binary collation br CESU encoding can result from converting UTF data with supplementary characters to UTF using conversion methods that assume UCS data meaning they are unaware of four byte UTF supplementary characters It is primarily an issue on operating systems which extensively use UTF internally such as Microsoft Windows br In Oracle Database the UTF character set uses CESU encoding and is deprecated The AL UTF character set uses standards compliant UTF encoding and is preferred br CESU is prohibited for use in HTML documents br br br MySQL utf mb br In MySQL the utf mb character set is defined to be UTF encoded data with a maximum of three bytes per character meaning only Unicode characters in the Basic Multilingual Plane i e from UCS are supported Unicode characters in supplementary planes are explicitly not supported utf mb is deprecated in favor of the utf mb character set which uses standards compliant UTF encoding utf is an alias for utf mb but is intended to become an alias to utf mb in a future release of MySQL It is possible though unsupported to store CESU encoded data in utf mb by handling UTF data with supplementary characters as though it is UCS br br br Modified UTF br Modified UTF MUTF originated in the Java programming language In Modified UTF the null character U uses the two byte overlong encoding hexadecimal C instead of hexadecimal Modified UTF strings never contain any actual null bytes but can contain all Unicode code points including U which allows such strings with a null byte appended to be processed by traditional null terminated string functions All known Modified UTF implementations also treat the surrogate pairs as in CESU br In normal usage the language supports standard UTF when reading and writing strings through InputStreamReader and OutputStreamWriter if it is the platform s default character set or as requested by the program However it uses Modified UTF for object serialization among other applications of DataInput and DataOutput for the Java Native Interface and for embedding constant strings in class files br The dex format defined by Dalvik also uses the same modified UTF to represent string values Tcl also uses the same modified UTF as Java for internal representation of Unicode data but uses strict CESU for external data br br br WTF br br In WTF Wobbly Transformation Format bit unpaired surrogate halves U D through U DFFF are allowed This is necessary to store possibly invalid UTF such as Windows filenames Many systems that deal with UTF work this way without considering it a different encoding as it is simpler br The term WTF has also been used humorously to refer to erroneously doubly encoded UTF sometimes with the implication that CP bytes are the only ones encoded br br br PEP br Version of the Python programming language treats each byte of an invalid UTF bytestream as an error see also changes with new UTF mode in Python this gives different possible errors Extensions have been created to allow any byte sequence that is assumed to be UTF to be losslessly transformed to UTF or UTF by translating the possible error bytes to reserved code points and transforming those code points back to error bytes to output UTF The most common approach is to translate the codes to U DC U DCFF which are low trailing surrogate values and thus invalid UTF as used by Python s PEP or surrogateescape approach Another encoding called MirBSD OPTU converts them to U EF U EFFF in a Private Use Area In either approach the byte value is encoded in the low eight bits of the output code point br These encodings are very useful because they avoid the need to deal with invalid byte strings until much later if at all and allow text and data byte arrays to be the same object If a program wants to use UTF internally these are required to preserve and use filenames that can use invalid UTF as the Windows filesystem API uses UTF the need to support invalid UTF is less there br For the encoding to be reversible the standard UTF encodings of the code points used for erroneous bytes must be considered invalid This makes the encoding incompatible with WTF or CESU though only for code points When re encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF which may be used by malicious software to get unexpected characters in the output though this cannot produce ASCII characters so it is considered comparatively safe since malicious sequences such as cross site scripting usually rely on ASCII characters br br br See also br Alt code br Comparison of email clients Features br Comparison of Unicode encodings br GB a Chinese encoding that fully supports Unicode br UTF EBCDIC a rarely used encoding even for mainframes it was made for br Iconv br Percent encoding Current standard br Specials Unicode block br Unicode and email br Unicode and HTML br Character encodings in HTML br br br Notes br br br br br br External links br Original UTF paper or pdf for Plan from Bell Labs br History of UTF by Rob Pike br UTF test pages br Andreas Prilop Archived at the Wayback Machine br Jost Gippert br World Wide Web Consortium br Unix Linux UTF Unicode FAQ Linux Unicode HOWTO UTF and Gentoo br Characters Symbols and the Unicode Miracle on YouTube