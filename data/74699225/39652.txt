title: OCaml
id: 39652
OCaml oh KAM l formerly Objective Caml is a general purpose high level multi paradigm programming language which extends the Caml dialect of ML with object oriented features OCaml was created in by Xavier Leroy J r me Vouillon Damien Doligez Didier R my Asc nder Su rez and others br The OCaml toolchain includes an interactive top level interpreter a bytecode compiler an optimizing native code compiler a reversible debugger and a package manager OPAM OCaml was initially developed in the context of automated theorem proving and is used in static analysis and formal methods software Beyond these areas it has found use in systems programming web development and specific financial utilities among other application domains br The acronym CAML originally stood for Categorical Abstract Machine Language but OCaml omits this abstract machine OCaml is a free and open source software project managed and principally maintained by the French Institute for Research in Computer Science and Automation Inria In the early s elements from OCaml were adopted by many languages notably F and Scala br br br Philosophy br ML derived languages are best known for their static type systems and type inferring compilers OCaml unifies functional imperative and object oriented programming under an ML like type system Thus programmers need not be highly familiar with the pure functional language paradigm to use OCaml br By requiring the programmer to work within the constraints of its static type system OCaml eliminates many of the type related runtime problems associated with dynamically typed languages Also OCaml s type inferring compiler greatly reduces the need for the manual type annotations that are required in most statically typed languages For example the data types of variables and the signatures of functions usually need not be declared explicitly as they do in languages like Java and C because they can be inferred from the operators and other functions that are applied to the variables and other values in the code Effective use of OCaml s type system can require some sophistication on the part of a programmer but this discipline is rewarded with reliable high performance software br OCaml is perhaps most distinguished from other languages with origins in academia by its emphasis on performance Its static type system prevents runtime type mismatches and thus obviates runtime type and safety checks that burden the performance of dynamically typed languages while still guaranteeing runtime safety except when array bounds checking is turned off or when some type unsafe features like serialization are used These are rare enough that avoiding them is quite possible in practice br Aside from type checking overhead functional programming languages are in general challenging to compile to efficient machine language code due to issues such as the funarg problem Along with standard loop register and instruction optimizations OCaml s optimizing compiler employs static program analysis methods to optimize value boxing and closure allocation helping to maximize the performance of the resulting code even if it makes extensive use of functional programming constructs br Xavier Leroy has stated that OCaml delivers at least of the performance of a decent C compiler although a direct comparison is impossible Some functions in the OCaml standard library are implemented with faster algorithms than equivalent functions in the standard libraries of other languages For example the implementation of set union in the OCaml standard library in theory is asymptotically faster than the equivalent function in the standard libraries of imperative languages e g C Java because the OCaml implementation can exploit the immutability of sets to reuse parts of input sets in the output see persistent data structure br br br History br br br Development of ML Meta Language br Between the s and s Robin Milner a British computer scientist and Turing Award winner worked at the University of Edinburgh s Laboratory for Foundations of Computer Science Milner and others were working on theorem provers which were historically developed in languages such as Lisp Milner repeatedly ran into the issue that the theorem provers would attempt to claim a proof was valid by putting non proofs together As a result he went on to develop the meta language for his Logic for Computable Functions a language that would only allow the writer to construct valid proofs with its polymorphic type system ML was turned into a compiler to simplify using LCF on different machines and by the s was turned into a complete system of its own ML would eventually serve as a basis for the creation of OCaml br In the early s there were some developments that prompted INRIA s Formel team to become interested in the ML language Luca Cardelli a research professor at University of Oxford used his functional abstract machine to develop a faster implementation of ML and Robin Milner proposed a new definition of ML to avoid divergence between various implementations Simultaneously Pierre Louis Curien a senior researcher at Paris Diderot University developed a calculus of categorical combinators and linked it to lambda calculus which led to the definition of the categorical abstract machine CAM Guy Cousineau a researcher at Paris Diderot University recognized that this could be applied as a compiling method for ML br br br First implementation br Caml was initially designed and developed by INRIA s Formel team headed by G rard Huet The first implementation of Caml was created in and was further developed until Though it was spearheaded by Asc nder Su rez Pierre Weis and Michel Mauny carried on with development after he left in br Guy Cousineau is quoted recalling that his experience with programming language implementation was initially very limited and that there were multiple inadequacies for which he is responsible Despite this he believes that Ascander Pierre and Michel did quite a nice piece of work br br br Caml Light br Between and Xavier Leroy designed a new implementation of Caml based on a bytecode interpreter written in C In addition to this Damien Doligez wrote a memory management system also known as a sequential garbage collector for this implementation This new implementation known as Caml Light replaced the old Caml implementation and ran on small desktop machines In the following years libraries such as Michel Mauny s syntax manipulation tools appeared and helped promote the use of Caml in educational and research teams br br br Caml Special Light br In Xavier Leroy released Caml Special Light which was an improved version of Caml An optimizing native code compiler was added to the bytecode compiler which greatly increased performance to comparable levels with mainstream languages such as C Also Leroy designed a high level module system inspired by the module system of Standard ML which provided powerful facilities for abstraction and parameterization and made larger scale programs easier to build br br br Objective Caml br Didier R my and J r me Vouillon designed an expressive type system for objects and classes which was integrated within Caml Special Light This led to the emergence of the Objective Caml language first released in and subsequently renamed to OCaml in This object system notably supported many prevalent object oriented idioms in a statically type safe way while those same idioms caused unsoundness or required runtime checks in languages such as C or Java In Jacques Garrigue extended Objective Caml with multiple new features such as polymorphic methods variants and labeled and optional arguments br br br Ongoing development br Language improvements have been incrementally added for the last two decades to support the growing commercial and academic codebases in OCaml The OCaml release in added Generalized Algebraic Data Types GADTs and first class modules to increase the flexibility of the language The OCaml release in is a complete rewrite of the language runtime removing the global GC lock and adding effect handlers via delimited continuations These changes enable support for shared memory parallelism and color blind concurrency respectively br OCaml s development continued within the Cristal team at INRIA until when it was succeeded by the Gallium team Subsequently Gallium was succeeded by the Cambium team in As of there are core developers of the compiler distribution from a variety of organizations and developers for the broader OCaml tooling and packaging ecosystem br br br Features br OCaml features a static type system type inference parametric polymorphism tail recursion pattern matching first class lexical closures functors parametric modules exception handling effect handling and incremental generational automatic garbage collection br OCaml is notable for extending ML style type inference to an object system in a general purpose language This permits structural subtyping where object types are compatible if their method signatures are compatible regardless of their declared inheritance an unusual feature in statically typed languages br A foreign function interface for linking to C primitives is provided including language support for efficient numerical arrays in formats compatible with both C and Fortran OCaml also supports creating libraries of OCaml functions that can be linked to a main program in C so that an OCaml library can be distributed to C programmers who have no knowledge or installation of OCaml br The OCaml distribution contains br br Lexical analysis and parsing tools called ocamllex and ocamlyacc br Debugger that supports stepping backwards to investigate errors br Documentation generator br Profiler to measure performance br Many general purpose libraries br The native code compiler is available for many platforms including Unix Microsoft Windows and Apple macOS Portability is achieved through native code generation support for major architectures br br X AMD RISC V and ARM in OCaml and higher br IBM Z before OCaml and back in OCaml br Power before OCaml and due to reappear in OCaml br IA and ARM before OCaml br SPARC before OCaml br DEC Alpha HPPA IA and MIPS before OCaml br The bytecode compiler supports operation on any or bit architecture when native code generation is not available requiring only a C compiler br OCaml bytecode and native code programs can be written in a multithreaded style with preemptive context switching OCaml threads in the same domain execute by time sharing only However an OCaml program can contain several domains br br br Code examples br br Snippets of OCaml code are most easily studied by entering them into the top level REPL This is an interactive OCaml session that prints the inferred types of resulting or defined expressions The OCaml top level is started by simply executing the OCaml program br br Code can then be entered at the prompt For example to calculate br br OCaml infers the type of the expression to be int a machine precision integer and gives the result br br br Hello World br The following program hello ml br br can be compiled into a bytecode executable br br ocamlc hello ml o hello br br or compiled into an optimized native code executable br br ocamlopt hello ml o hello br br and executed br br The first argument to ocamlc hello ml specifies the source file to compile and the o hello flag specifies the output file br br br Option br The option type constructor in OCaml similar to the Maybe type in Haskell augments a given data type to either return Some value of the given data type or to return None This is used to express that a value might or might not be present This is an example of a function that either extracts an int from an option if there is one inside and converts it into a string or if not returns an empty string br br br Summing a list of integers br Lists are one of the fundamental datatypes in OCaml The following code example defines a recursive function sum that accepts one argument integers which is supposed to be a list of integers Note the keyword rec which denotes that the function is recursive The function recursively iterates over the given list of integers and provides a sum of the elements The match statement has similarities to C s switch element though it is far more general br br Another way is to use standard fold function that works with lists br br Since the anonymous function is simply the application of the operator this can be shortened to br br Furthermore one can omit the list argument by making use of a partial application br br br Quicksort br OCaml lends itself to concisely expressing recursive algorithms The following code example implements an algorithm similar to quicksort that sorts a list in increasing order br br Or using partial application of the operator br br br Birthday problem br The following program calculates the smallest number of people in a room for whom the probability of completely unique birthdays is less than the birthday problem where for person the probability is or for it is for it is etc answer br br br Church numerals br The following code defines a Church encoding of natural numbers with successor succ and addition add A Church numeral n is a higher order function that accepts a function f and a value x and applies f to x exactly n times To convert a Church numeral from a functional value to a string we pass it a function that prepends the string S to its input and the constant string br br br Arbitrary precision factorial function libraries br A variety of libraries are directly accessible from OCaml For example OCaml has a built in library for arbitrary precision arithmetic As the factorial function grows very rapidly it quickly overflows machine precision numbers typically or bits Thus factorial is a suitable candidate for arbitrary precision arithmetic br In OCaml the Num module now superseded by the ZArith module provides arbitrary precision arithmetic and can be loaded into a running top level using br br The factorial function may then be written using the arbitrary precision numeric operators and br br This function can compute much larger factorials such as br br br Triangle graphics br The following program renders a rotating triangle in D using OpenGL br br The LablGL bindings to OpenGL are required The program may then be compiled to bytecode with br br ocamlc I lablGL lablglut cma lablgl cma simple ml o simple br br or to nativecode with br br ocamlopt I lablGL lablglut cmxa lablgl cmxa simple ml o simple br br or more simply using the ocamlfind build command br br ocamlfind opt simple ml package lablgl glut linkpkg o simple br br and run br br simple br br Far more sophisticated high performance D and D graphical programs can be developed in OCaml Thanks to the use of OpenGL and OCaml the resulting programs can be cross platform compiling without any changes on many major platforms br br br Fibonacci sequence br The following code calculates the Fibonacci sequence of a number n inputted It uses tail recursion and pattern matching br br br Higher order functions br Functions may take functions as input and return functions as result For example applying twice to a function f yields a function that applies f two times to its argument br br The function twice uses a type variable a to indicate that it can be applied to any function f mapping from a type a to itself rather than only to int int functions In particular twice can even be applied to itself br br br Derived languages br br br MetaOCaml br MetaOCaml is a multi stage programming extension of OCaml enabling incremental compiling of new machine code during runtime Under some circumstances significant speedups are possible using multistage programming because more detailed information about the data to process is available at runtime than at the regular compile time so the incremental compiler can optimize away many cases of condition checking etc br As an example if at compile time it is known that some power function x x n is needed often but the value of n is known only at runtime a two stage power function can be used in MetaOCaml br br As soon as n is known at runtime a specialized and very fast power function can be created br br The result is br br The new function is automatically compiled br br br Other derived languages br F is a NET framework language based on OCaml br JoCaml integrates constructions for developing concurrent and distributed programs br Reason is an alternative OCaml syntax and toolchain for OCaml created at Facebook which can compile to both native code and JavaScript br br br Software written in OCaml br Alt Ergo a SMT solver br Astr e a static analyzer br Be Sport a social network br Coccinelle a utility for transforming the source code of C programs br Coq a formal proof management system br Easycrypt a toolset for writing computer aided proofs br FFTW a library for computing discrete Fourier transforms Several C routines have been generated by an OCaml program named genfft br The web version of Facebook Messenger br Flow a static analyzer created at Facebook that infers and checks static types for JavaScript br Ocsigen a client server Web and mobile development framework br Owl Scientific Computing a dedicated system for scientific and engineering computing br Frama C a framework for analyzing C programs br GeneWeb free and open source multi platform genealogy software br The Hack programming language compiler created at Facebook extending PHP with static types br The Haxe programming language compiler br HOL Light a formal proof assistant br Infer a static analyzer created at Facebook for Java C C and Objective C used to detect bugs in iOS and Android apps br Liquidsoap a scripting language for generating multimedia streams br MirageOS a unikernel programming framework written in pure OCaml br MLdonkey a peer to peer file sharing application based on the EDonkey network br Opa a free and open source programming language for web development br Tezos a self amending smart contract platform using XTZ as a native currency br Unison a file synchronization program to synchronize files between two directories br The reference interpreter for WebAssembly a low level bytecode intended for execution inside web browsers br Xen Cloud Platform XCP a turnkey virtualization solution for the Xen hypervisor br br br Users br At least several dozen companies use OCaml to some degree Notable examples include br br Bloomberg L P which created BuckleScript an OCaml compiler backend targeting JavaScript br Citrix Systems which uses OCaml in XenServer rebranded as Citrix Hypervisor during br Facebook which developed Flow Hack Infer Pfff and ReasonML in OCaml br Jane Street Capital a proprietary trading firm which adopted OCaml as its preferred language in its early days and continues to use it as of br Docker which uses OCaml in the desktop editions on macOS and Windows br br br br br br External links br br Official website br OCaml manual br OCaml Package Manager br Real World OCaml